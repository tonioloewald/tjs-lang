function parseVersion(version: '') -> { major: 0, minor: 0, patch: 0 } {
    const [major = 0, minor = 0, patch = 0] = version.split('.').map(Number);
    return { major, minor, patch };
}

function compareVersions(a: '', b: '') {
    const va = parseVersion(a);
    const vb = parseVersion(b);
    if (va.major !== vb.major)
        return va.major < vb.major ? -1 : 1;
    if (va.minor !== vb.minor)
        return va.minor < vb.minor ? -1 : 1;
    if (va.patch !== vb.patch)
        return va.patch < vb.patch ? -1 : 1;
    return 0;
}

function versionsCompatible(a: '', b: '') -> true {
    const va = parseVersion(a);
    const vb = parseVersion(b);
    return va.major === vb.major;
}

Type TJSError {
  example: { $error: true, message: '', path: '', stack: [''], expected: '', actual: '', cause: null, loc: { start: 0, end: 0 }, errors: [null] }
}

Union SafetyLevel 'SafetyLevel' 'none' | 'inputs' | 'all'

Type TJSConfig {
  example: { debug: true, safety: null, requireReturnTypes: true, maxStackSize: 0 }
}

function enterUnsafe() {
    unsafeDepth++;
}

function exitUnsafe() {
    if (unsafeDepth > 0)
        unsafeDepth--;
}

function isUnsafeMode() -> true {
    return unsafeDepth > 0;
}

function configure(options: any) {
    config = { ...config, ...options };
}

function getConfig() {
    return { ...config };
}

function pushStack(name: '') {
    if (config.debug && name) {
        callStack.push(name);
        // Enforce max stack size by removing oldest entries
        const maxSize = config.maxStackSize ?? 100;
        while (callStack.length > maxSize) {
            callStack.shift();
        }
    }
}

function popStack() {
    if (config.debug) {
        callStack.pop();
    }
}

function getStack() -> [''] {
    return [...callStack];
}

function isError(value: any) {
    return (value !== null &&
        typeof value === 'object' &&
        value.$error === true);
}

function error(message: '', details: any) {
    const err = {
        $error: true,
        message,
        ...details,
    };
    // In debug mode, capture the call stack
    if (config.debug && callStack.length > 0) {
        // Add the path to the stack if it exists
        const fullStack = details?.path
            ? [...callStack, details.path]
            : [...callStack];
        err.stack = fullStack;
    }
    return err;
}

function composeErrors(errors: [null], funcName = '') {
    if (errors.length === 0) {
        return error('Unknown error');
    }
    if (errors.length === 1) {
        return errors[0];
    }
    // Build a message listing all failed parameters
    const paramNames = errors
        .map((e) => {
        // Extract param name from path (e.g., "func.paramName" -> "paramName")
        if (e.path) {
            const parts = e.path.split('.');
            return parts[parts.length - 1];
        }
        return 'unknown';
    })
        .join(', ');
    const message = `Multiple parameter errors in ${funcName || 'function'}: ${paramNames}`;
    return error(message, {
        path: funcName,
        errors,
    });
}

function typeOf(value: any) -> '' {
    if (value === null)
        return 'null';
    if (value === undefined)
        return 'undefined';
    if (Array.isArray(value))
        return 'array';
    const t = typeof value;
    if (t !== 'object')
        return t;
    // For objects, return constructor name for pragmatic native type checking
    // This enables checking for HTMLElement, Buffer, Event, etc.
    const constructorName = value.constructor?.name;
    if (constructorName && constructorName !== 'Object') {
        return constructorName;
    }
    return 'object';
}

function isNativeType(value: any, typeName: '') -> true {
    if (value === null || value === undefined)
        return false;
    if (typeof value !== 'object' && typeof value !== 'function')
        return false;
    // Check constructor name
    let proto = value;
    while (proto !== null) {
        const constructorName = proto.constructor?.name;
        if (constructorName === typeName)
            return true;
        proto = Object.getPrototypeOf(proto);
    }
    return false;
}

function checkType(value: any, expected: '', path = '') -> any | null {
    // If value is already an error, propagate it
    if (isError(value))
        return value;
    // Handle RuntimeType instances (Type() results)
    if (typeof expected === 'object' &&
        expected !== null &&
        'check' in expected) {
        if (expected.check(value))
            return null;
        return error(`Expected ${expected.description} but got ${typeOf(value)}`, {
            path,
            expected: expected.description,
            actual: typeOf(value),
        });
    }
    const actual = typeOf(value);
    // Handle special cases
    if (expected === 'any')
        return null;
    if (expected === actual)
        return null;
    // Number accepts both number types
    if (expected === 'number' && actual === 'number')
        return null;
    if (expected === 'integer' && actual === 'number' && Number.isInteger(value))
        return null;
    // Object matching (basic)
    if (expected === 'object' && actual === 'object')
        return null;
    return error(`Expected ${expected} but got ${actual}`, {
        path,
        expected,
        actual,
    });
}

Type TypeSpec ''

Type ParamMeta {
  example: { type: null, required: true, default: null, loc: { start: 0, end: 0 } }
}

function validateArgs(args: {}, meta: { params: {} }, funcName = '') -> any | null {
    for (const [name, param] of Object.entries(meta.params)) {
        const value = args[name];
        // Check if any arg is already an error - propagate first one
        if (isError(value))
            return value;
        // Check required
        if (param.required && value === undefined) {
            const expectedDesc = typeof param.type === 'string' ? param.type : param.type.description;
            return error(`Missing required parameter '${name}'`, {
                path: funcName ? `${funcName}.${name}` : name,
                expected: expectedDesc,
                actual: 'undefined',
                loc: param.loc,
            });
        }
        // Skip type check for undefined optional params
        if (value === undefined)
            continue;
        // Type check
        const typeError = checkType(value, param.type, funcName ? `${funcName}.${name}` : name);
        if (typeError) {
            // Add location info if available
            if (param.loc) {
                typeError.loc = param.loc;
            }
            return typeError;
        }
    }
    return null;
}

Type FunctionMeta {
  example: { params: {}, returns: { type: null, safe: true }, unsafe: true, safe: true, unsafeReturn: true, safeReturn: true, name: '' }
}

function shouldValidateInputs(meta: any) -> true {
    // Per-function flags take precedence
    if (meta.unsafe)
        return false;
    if (meta.safe)
        return true;
    // Block-level override
    if (unsafeDepth > 0)
        return false;
    // Global safety level
    return config.safety !== 'none';
}

function shouldValidateOutputs(meta: any) -> true {
    // No return type declared = no validation
    if (!meta.returns)
        return false;
    // Per-function return flags take precedence
    if (meta.unsafeReturn)
        return false;
    if (meta.safeReturn)
        return true;
    // Block-level override
    if (unsafeDepth > 0)
        return false;
    // Global safety level: 'all' validates outputs, others don't by default
    return config.safety === 'all';
}

function wrap(fn: any, meta: any) {
    // Always attach metadata for introspection/autocomplete
    ;
    fn.__tjs = meta;
    // Determine if we need a wrapper at all
    const needsWrapper =
    // Has forced safety that requires validation
    meta.safe ||
        meta.safeReturn ||
        // Global safety requires validation (and not explicitly unsafe)
        (config.safety !== 'none' && !meta.unsafe) ||
        // Has return type that might need validation
        (meta.returns && config.safety === 'all' && !meta.unsafeReturn);
    if (!needsWrapper) {
        return fn;
    }
    // Pre-compute flags at wrap time
    const hasReturns = !!meta.returns;
    const metaUnsafe = !!meta.unsafe;
    const metaSafe = !!meta.safe;
    const metaUnsafeReturn = !!meta.unsafeReturn;
    const metaSafeReturn = !!meta.safeReturn;
    const paramEntries = Object.entries(meta.params);
    const paramCount = paramEntries.length;
    // Use meta.name as fallback when fn.name is empty (anonymous functions)
    const funcName = fn.name || meta.name || 'anonymous';
    const wrapped = function (...args) {
        // Fast path: inside unsafe block, skip all validation
        if (unsafeDepth > 0) {
            return fn.apply(this, args);
        }
        // Compute validation flags
        const validateInputs = metaSafe || (!metaUnsafe && config.safety !== 'none');
        const validateOutputs = hasReturns &&
            (metaSafeReturn || (!metaUnsafeReturn && config.safety === 'all'));
        // Fast path: no validation needed
        if (!validateInputs && !validateOutputs) {
            return fn.apply(this, args);
        }
        // Fast path: check for error as first arg
        if (args.length > 0 && isError(args[0])) {
            return args[0];
        }
        // Input validation
        if (validateInputs) {
            // Detect if single object arg (named params) vs positional
            const isNamedCall = args.length === 1 &&
                typeof args[0] === 'object' &&
                args[0] !== null &&
                !Array.isArray(args[0]);
            // Collect all errors to compose them
            const collectedErrors = [];
            // Fast positional validation (avoids object allocation)
            if (!isNamedCall) {
                for (let i = 0; i < paramCount; i++) {
                    const [name, param] = paramEntries[i];
                    const value = args[i];
                    // Check for error propagation (passed-in errors)
                    if (isError(value)) {
                        collectedErrors.push(value);
                        continue;
                    }
                    // Check required
                    if (param.required && value === undefined) {
                        collectedErrors.push(error(`Missing required parameter '${name}'`, {
                            path: `${funcName}.${name}`,
                            expected: typeof param.type === 'string'
                                ? param.type
                                : param.type?.description || 'value',
                            actual: 'undefined',
                            loc: param.loc,
                        }));
                        continue;
                    }
                    // Type check (skip undefined optional)
                    if (value !== undefined) {
                        const typeErr = checkType(value, param.type, `${funcName}.${name}`);
                        if (typeErr) {
                            if (param.loc)
                                typeErr.loc = param.loc;
                            collectedErrors.push(typeErr);
                        }
                    }
                }
            }
            else {
                // Named args path (slower, but supports object destructuring)
                const namedArgs = args[0];
                for (let i = 0; i < paramCount; i++) {
                    const [name, param] = paramEntries[i];
                    const value = namedArgs[name];
                    if (isError(value)) {
                        collectedErrors.push(value);
                        continue;
                    }
                    if (param.required && value === undefined) {
                        collectedErrors.push(error(`Missing required parameter '${name}'`, {
                            path: `${funcName}.${name}`,
                            expected: typeof param.type === 'string'
                                ? param.type
                                : param.type?.description || 'value',
                            actual: 'undefined',
                            loc: param.loc,
                        }));
                        continue;
                    }
                    if (value !== undefined) {
                        const typeErr = checkType(value, param.type, `${funcName}.${name}`);
                        if (typeErr) {
                            if (param.loc)
                                typeErr.loc = param.loc;
                            collectedErrors.push(typeErr);
                        }
                    }
                }
            }
            // If we collected any errors, compose and return them
            if (collectedErrors.length > 0) {
                return composeErrors(collectedErrors, funcName);
            }
        }
        // Push onto call stack in debug mode
        pushStack(funcName);
        try {
            // Execute function
            const result = fn.apply(this, args);
            // Output validation
            if (validateOutputs && meta.returns && !isError(result)) {
                const returnError = checkType(result, meta.returns.type, `${funcName}()`);
                if (returnError) {
                    popStack();
                    return returnError;
                }
            }
            popStack();
            return result;
        }
        catch (e) {
            popStack();
            // Convert thrown errors to TJS errors
            return error(e.message || String(e), {
                path: funcName,
                cause: e,
            });
        }
    };
    // Preserve function name and metadata
    Object.defineProperty(wrapped, 'name', { value: fn.name });
    wrapped.__tjs = meta;
    return wrapped;
}

function wrapClass(cls: any) {
    // Use a Proxy to intercept both `new Wrapper()` and `Wrapper()` calls
    const wrapped = new Proxy(cls, {
        // Called when using `new Wrapper(...)`
        construct(target, args, newTarget) {
            return Reflect.construct(target, args, newTarget);
        },
        // Called when using `Wrapper(...)` without new
        apply(target, _thisArg, args) {
            return Reflect.construct(target, args);
        },
    });
    // Preserve class name
    Object.defineProperty(wrapped, 'name', { value: cls.name });
    // Copy static properties and methods
    for (const key of Object.getOwnPropertyNames(cls)) {
        if (key !== 'length' && key !== 'name' && key !== 'prototype') {
            Object.defineProperty(wrapped, key, Object.getOwnPropertyDescriptor(cls, key));
        }
    }
    return wrapped;
}

function typeSpecToCheck(spec: any) {
    if (isRuntimeType(spec)) {
        return (v) => spec.check(v);
    }
    // Infer schema from example value
    const schema = s.infer(spec);
    return (v) => validate(v, schema);
}

Type SafeCapabilities {
  example: { fetch: undefined, console: undefined }
}

Generic SafeFunctionOptions<TInputs, TOutput> {
  description: 'SafeFunctionOptions'
  predicate(x, TInputs, TOutput) { return typeof x === 'object' && x !== null && 'inputs' in x && TInputs(x.inputs) && 'output' in x && TOutput(x.output) && 'body' in x && 'timeoutMs' in x && 'fuel' in x && 'capabilities' in x }
}

async function SafeFunction(options: any) {
    const { inputs, output, body, timeoutMs = 5000, capabilities = {} } = options;
    // Build input validators
    const paramNames = Object.keys(inputs);
    const inputChecks = paramNames.map((name) => ({
        name,
        check: typeSpecToCheck(inputs[name]),
    }));
    const outputCheck = typeSpecToCheck(output);
    // Build capability names and values for injection
    const capNames = Object.keys(capabilities);
    const capValues = Object.values(capabilities);
    // Create the async function with capabilities injected
    // Wrap body in async IIFE to support await
    const asyncBody = `
    return (async () => {
      ${body}
    })()
  `;
    // Function signature: capabilities first, then params
    const fn = new Function(...capNames, ...paramNames, asyncBody);
    // Return wrapped function with validation
    return async (...args) => {
        // Validate inputs
        for (let i = 0; i < inputChecks.length; i++) {
            const { name, check } = inputChecks[i];
            const value = args[i];
            if (!check(value)) {
                return error(`SafeFunction: invalid input '${name}'`, 'SafeFunction', {
                    expected: name,
                    received: value,
                });
            }
        }
        // Execute with timeout
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('SafeFunction timeout')), timeoutMs);
        });
        try {
            // Call with capabilities first, then args
            const result = await Promise.race([
                fn(...capValues, ...args),
                timeoutPromise,
            ]);
            // Validate output
            if (!outputCheck(result)) {
                return error('SafeFunction: invalid output', 'SafeFunction', {
                    received: result,
                });
            }
            return result;
        }
        catch (err) {
            return error(`SafeFunction error: ${err.message || err}`, 'SafeFunction', { cause: err });
        }
    };
}

Generic EvalOptions<TOutput> {
  description: 'EvalOptions'
  predicate(x, TOutput) { return typeof x === 'object' && x !== null && 'code' in x && 'context' in x && 'output' in x && TOutput(x.output) && 'timeoutMs' in x && 'capabilities' in x }
}

async function Eval(options: any) {
    const { code, context = {}, output, timeoutMs = 5000, capabilities = {}, } = options;
    // Combine capabilities and context (capabilities take precedence)
    const allNames = [...Object.keys(capabilities), ...Object.keys(context)];
    const allValues = [...Object.values(capabilities), ...Object.values(context)];
    const outputCheck = typeSpecToCheck(output);
    // Wrap code in async IIFE to support await and return the expression
    // If code doesn't have 'return', treat it as an expression
    const hasReturn = /\breturn\b/.test(code);
    const asyncBody = hasReturn
        ? `return (async () => { ${code} })()`
        : `return (async () => { return (${code}) })()`;
    const fn = new Function(...allNames, asyncBody);
    // Execute with timeout
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Eval timeout')), timeoutMs);
    });
    try {
        const result = await Promise.race([fn(...allValues), timeoutPromise]);
        // Validate output
        if (!outputCheck(result)) {
            return error('Eval: invalid output', 'Eval', {
                received: result,
            });
        }
        return result;
    }
    catch (err) {
        return error(`Eval error: ${err.message || err}`, 'Eval', { cause: err });
    }
}

function installRuntime() {
    const g = globalThis;
    if (g.__tjs) {
        const existingVersion = g.__tjs.version;
        const comparison = compareVersions(TJS_VERSION, existingVersion);
        if (comparison === 0) {
            // Exact same version - just reuse
            return g.__tjs;
        }
        if (versionsCompatible(TJS_VERSION, existingVersion)) {
            // Same major version - compatible, use newer
            if (comparison > 0) {
                console.info(`TJS runtime: upgrading ${existingVersion} â†’ ${TJS_VERSION}`);
                g.__tjs = runtime;
            }
            else {
                console.info(`TJS runtime: keeping ${existingVersion} (newer than ${TJS_VERSION})`);
            }
        }
        else {
            // Different major version - breaking change potential
            console.warn(`TJS runtime version conflict: ${existingVersion} vs ${TJS_VERSION} (major version mismatch)`);
            // Use the newer one but warn about potential issues
            if (comparison > 0) {
                console.warn(`Upgrading to ${TJS_VERSION} - check for breaking changes`);
                g.__tjs = runtime;
            }
        }
        return g.__tjs;
    }
    g.__tjs = runtime;
    return runtime;
}

function emitRuntimeWrapper(funcName: '') -> '' {
    return `
// TJS runtime wrapper (skips unsafe functions)
if (typeof ${funcName}.__tjs === 'object' && !${funcName}.__tjs.unsafe && typeof globalThis.__tjs?.wrap === 'function') {
  ${funcName} = globalThis.__tjs.wrap(${funcName}, ${funcName}.__tjs)
}
`.trim();
}

function emitClassWrapper(className: '') -> '' {
    return `
// TJS class wrapper (callable without new)
if (typeof globalThis.__tjs?.wrapClass === 'function') {
  ${className} = globalThis.__tjs.wrapClass(${className})
}
`.trim();
}
