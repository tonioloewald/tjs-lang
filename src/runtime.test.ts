import { describe, it, expect } from 'bun:test'
import { defineAtom } from './runtime'
import { AgentVM } from './vm'
import { s } from 'tosijs-schema'
import { ajs } from './transpiler'

describe('Agent99 Runtime (VM)', () => {
  const vm = new AgentVM()

  it('should execute a manually constructed AST with ExprNode', async () => {
    // Manually constructing AST with ExprNode for arithmetic
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'varSet',
          key: 'res',
          value: {
            $expr: 'binary',
            op: '+',
            left: { $expr: 'ident', name: 'val' },
            right: { $expr: 'literal', value: 10 },
          },
        },
        {
          op: 'return',
          schema: { type: 'object', properties: { res: { type: 'number' } } },
        },
      ],
    } as any

    const result = await vm.run(ast, { val: 5 })
    expect(result.result).toEqual({ res: 15 })
  })

  it('should run an AST generated by js() transpiler', async () => {
    // Calculates: price * (1 + tax)
    const ast = ajs(`
      function calc({ price, tax }) {
        let total = price * (1 + tax)
        return { total }
      }
    `)

    const result = await vm.run(ast, { price: 100, tax: 0.2 })

    // 100 * 1.2 = 120
    expect(result.result).toBeDefined()
    expect(result.result.total).toBe(120)
  })

  it('should handle complex math expressions using precedence', async () => {
    // (a + b) * c / 2
    // (10 + 20) * 4 / 2 = 30 * 4 / 2 = 60
    const ast = ajs(`
      function calc({ a, b, c }) {
        let res = (a + b) * c / 2
        return { res }
      }
    `)

    const result = await vm.run(ast, { a: 10, b: 20, c: 4 })
    expect(result.result.res).toBe(60)
  })

  it('should enforce fuel limits', async () => {
    const ast = {
      op: 'seq',
      steps: [
        // Use varSet atoms which have cost 0.1 each
        { op: 'varSet', key: 'a', value: 1 },
        { op: 'varSet', key: 'b', value: 2 },
        { op: 'varSet', key: 'c', value: 3 },
      ],
    } as any

    // Logic:
    // Fuel 0.2 provided.
    // Step 1: Fuel 0.2 -> 0.1. OK.
    // Step 2: Fuel 0.1 -> 0. OK.
    // Step 3: Fuel 0. Error.
    const result = await vm.run(ast, {}, { fuel: 0.2 })
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe('Out of Fuel')
  })

  it('should return strict subsets of state based on schema', async () => {
    // Test that the return op filters the state
    const ast = ajs(`
      function test() {
        let secret = 100
        let publicVal = 200
        return { publicVal }
      }
    `)

    const result = await vm.run(ast, {})
    expect(result.result.publicVal).toBe(200)
    expect(result.result.secret).toBeUndefined()
  })

  it('should enforce atom timeouts', async () => {
    const slowAtom = defineAtom(
      'testSlow',
      s.any,
      undefined,
      async () => {
        await new Promise((resolve) => setTimeout(resolve, 50))
      },
      { timeoutMs: 10 }
    )

    const vm = new AgentVM({ testSlow: slowAtom })

    const ast = {
      op: 'seq',
      steps: [{ op: 'testSlow' }],
    } as any

    const result = await vm.run(ast, {})
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe("Atom 'testSlow' timed out")
  })

  it('should set multiple variables with varsLet and compute expressions', async () => {
    const ast = ajs(`
      function test() {
        let a = 10
        let b = 20
        let c = "hello"
        let calcResult = a + b
        return { calcResult, a, c }
      }
    `)

    const result = await vm.run(ast, {})

    expect(result.result).toBeDefined()
    expect(result.result.calcResult).toBe(30)
    expect(result.result.a).toBe(10)
    expect(result.result.c).toBe('hello')
  })

  it('should generate a trace when trace mode is enabled', async () => {
    const ast = {
      op: 'seq',
      steps: [
        { op: 'varSet', key: 'x', value: 10 },
        {
          op: 'varSet',
          key: 'res',
          value: {
            $expr: 'binary',
            op: '+',
            left: { $expr: 'ident', name: 'x' },
            right: { $expr: 'ident', name: 'val' },
          },
        },
      ],
    } as any

    const { result, trace } = await vm.run(ast, { val: 5 }, { trace: true })

    expect(result).toBeUndefined() // No return op
    expect(trace).toBeDefined()
    if (!trace) throw new Error('Trace is undefined')
    expect(trace).toHaveLength(3)

    // The trace is in post-order traversal, so seq is last.
    // 1. varSet
    expect(trace[0].op).toBe('varSet')
    expect(trace[0].input).toEqual({ key: 'x', value: 10 })
    expect(trace[0].stateDiff).toEqual({ x: 10 })

    // 2. varSet (with expression)
    expect(trace[1].op).toBe('varSet')
    expect(trace[1].stateDiff).toEqual({ res: 15 })

    // 3. seq
    expect(trace[2].op).toBe('seq')
    // The seq atom's diff captures the cumulative changes of its children
    expect(trace[2].stateDiff).toEqual({ x: 10, res: 15 })
  })
})
