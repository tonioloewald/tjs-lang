import { describe, it, expect } from 'bun:test'
import { defineAtom } from './runtime'
import { AgentVM } from './vm'
import { s } from 'tosijs-schema'
import { ajs } from './transpiler'

describe('Agent99 Runtime (VM)', () => {
  const vm = new AgentVM()

  it('should execute a manually constructed AST with ExprNode', async () => {
    // Manually constructing AST with ExprNode for arithmetic
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'varSet',
          key: 'res',
          value: {
            $expr: 'binary',
            op: '+',
            left: { $expr: 'ident', name: 'val' },
            right: { $expr: 'literal', value: 10 },
          },
        },
        {
          op: 'return',
          schema: { type: 'object', properties: { res: { type: 'number' } } },
        },
      ],
    } as any

    const result = await vm.run(ast, { val: 5 })
    expect(result.result).toEqual({ res: 15 })
  })

  it('should run an AST generated by js() transpiler', async () => {
    // Calculates: price * (1 + tax)
    const ast = ajs(`
      function calc({ price, tax }) {
        let total = price * (1 + tax)
        return { total }
      }
    `)

    const result = await vm.run(ast, { price: 100, tax: 0.2 })

    // 100 * 1.2 = 120
    expect(result.result).toBeDefined()
    expect(result.result.total).toBe(120)
  })

  it('should handle complex math expressions using precedence', async () => {
    // (a + b) * c / 2
    // (10 + 20) * 4 / 2 = 30 * 4 / 2 = 60
    const ast = ajs(`
      function calc({ a, b, c }) {
        let res = (a + b) * c / 2
        return { res }
      }
    `)

    const result = await vm.run(ast, { a: 10, b: 20, c: 4 })
    expect(result.result.res).toBe(60)
  })

  it('should enforce fuel limits', async () => {
    const ast = {
      op: 'seq',
      steps: [
        // Use varSet atoms which have cost 0.1 each
        { op: 'varSet', key: 'a', value: 1 },
        { op: 'varSet', key: 'b', value: 2 },
        { op: 'varSet', key: 'c', value: 3 },
      ],
    } as any

    // Logic:
    // Fuel 0.2 provided.
    // Step 1: Fuel 0.2 -> 0.1. OK.
    // Step 2: Fuel 0.1 -> 0. OK.
    // Step 3: Fuel 0. Error.
    const result = await vm.run(ast, {}, { fuel: 0.2 })
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe('Out of Fuel')
  })

  it('should return strict subsets of state based on schema', async () => {
    // Test that the return op filters the state
    const ast = ajs(`
      function test() {
        let secret = 100
        let publicVal = 200
        return { publicVal }
      }
    `)

    const result = await vm.run(ast, {})
    expect(result.result.publicVal).toBe(200)
    expect(result.result.secret).toBeUndefined()
  })

  it('should enforce atom timeouts', async () => {
    const slowAtom = defineAtom(
      'testSlow',
      s.any,
      undefined,
      async () => {
        await new Promise((resolve) => setTimeout(resolve, 50))
      },
      { timeoutMs: 10 }
    )

    const vm = new AgentVM({ testSlow: slowAtom })

    const ast = {
      op: 'seq',
      steps: [{ op: 'testSlow' }],
    } as any

    const result = await vm.run(ast, {})
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe("Atom 'testSlow' timed out")
  })

  it('should set multiple variables with varsLet and compute expressions', async () => {
    const ast = ajs(`
      function test() {
        let a = 10
        let b = 20
        let c = "hello"
        let calcResult = a + b
        return { calcResult, a, c }
      }
    `)

    const result = await vm.run(ast, {})

    expect(result.result).toBeDefined()
    expect(result.result.calcResult).toBe(30)
    expect(result.result.a).toBe(10)
    expect(result.result.c).toBe('hello')
  })

  it('should generate a trace when trace mode is enabled', async () => {
    const ast = {
      op: 'seq',
      steps: [
        { op: 'varSet', key: 'x', value: 10 },
        {
          op: 'varSet',
          key: 'res',
          value: {
            $expr: 'binary',
            op: '+',
            left: { $expr: 'ident', name: 'x' },
            right: { $expr: 'ident', name: 'val' },
          },
        },
      ],
    } as any

    const { result, trace } = await vm.run(ast, { val: 5 }, { trace: true })

    expect(result).toBeUndefined() // No return op
    expect(trace).toBeDefined()
    if (!trace) throw new Error('Trace is undefined')
    expect(trace).toHaveLength(3)

    // The trace is in post-order traversal, so seq is last.
    // 1. varSet
    expect(trace[0].op).toBe('varSet')
    expect(trace[0].input).toEqual({ key: 'x', value: 10 })
    expect(trace[0].stateDiff).toEqual({ x: 10 })

    // 2. varSet (with expression)
    expect(trace[1].op).toBe('varSet')
    expect(trace[1].stateDiff).toEqual({ res: 15 })

    // 3. seq
    expect(trace[2].op).toBe('seq')
    // The seq atom's diff captures the cumulative changes of its children
    expect(trace[2].stateDiff).toEqual({ x: 10, res: 15 })
  })
})

describe('Edge Cases', () => {
  const vm = new AgentVM()

  it('should handle division by zero (returns Infinity)', async () => {
    const ast = ajs(`
      function test({ n = 10 }) {
        let result = n / 0
        return { result }
      }
    `)
    const result = await vm.run(ast, { n: 10 })
    expect(result.result.result).toBe(Infinity)

    const result2 = await vm.run(ast, { n: -5 })
    expect(result2.result.result).toBe(-Infinity)

    const result3 = await vm.run(ast, { n: 0 })
    expect(Number.isNaN(result3.result.result)).toBe(true)
  })

  it('should handle zero fuel (immediate exhaustion)', async () => {
    const ast = ajs(`
      function test({ x = 1 }) {
        let y = x + 1
        return { y }
      }
    `)
    const result = await vm.run(ast, { x: 1 }, { fuel: 0 })
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe('Out of Fuel')
  })

  it('should handle unicode in state keys', async () => {
    const ast = ajs(`
      function test({ emoji = 'ðŸš€' }) {
        let result = emoji
        return { result }
      }
    `)
    const result = await vm.run(ast, { emoji: 'ðŸŽ‰' })
    expect(result.result.result).toBe('ðŸŽ‰')
  })

  it('should handle nested try/catch', async () => {
    const ast = ajs(`
      function test({ shouldFail = false }) {
        let outerResult = 'initial'
        try {
          try {
            if (shouldFail) {
              outerResult = Error('inner error')
            }
            outerResult = 'inner success'
          } catch (innerErr) {
            outerResult = 'caught inner'
          }
        } catch (outerErr) {
          outerResult = 'caught outer'
        }
        return { outerResult }
      }
    `)
    const result = await vm.run(ast, { shouldFail: false })
    expect(result.result.outerResult).toBe('inner success')
  })

  it('should handle complex optional chaining', async () => {
    const ast = ajs(`
      function test({ obj = null }) {
        let a = obj?.level1?.level2?.value
        let b = obj?.missing?.also?.missing
        return { a, b }
      }
    `)

    // With null input
    const result1 = await vm.run(ast, { obj: null })
    expect(result1.result.a).toBeUndefined()
    expect(result1.result.b).toBeUndefined()

    // With nested object
    const result2 = await vm.run(ast, {
      obj: { level1: { level2: { value: 42 } } },
    })
    expect(result2.result.a).toBe(42)
    expect(result2.result.b).toBeUndefined()
  })

  it('should handle deeply nested expressions', async () => {
    const ast = ajs(`
      function test({ x = 1 }) {
        let result = ((((x + 1) * 2) - 3) / 2) + 10
        return { result }
      }
    `)
    // ((((1 + 1) * 2) - 3) / 2) + 10 = (((2 * 2) - 3) / 2) + 10 = ((4 - 3) / 2) + 10 = (1 / 2) + 10 = 10.5
    const result = await vm.run(ast, { x: 1 })
    expect(result.result.result).toBe(10.5)
  })

  it('should emit warning when using default in-memory store', async () => {
    const vm = new AgentVM()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'storeSet', key: 'test', value: 'hello' },
        { op: 'storeGet', key: 'test' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(ast, {})
    expect(result.warnings).toBeDefined()
    expect(result.warnings).toContain(
      'Using default in-memory store (not suitable for production)'
    )
  })

  it('should not emit store warning when custom store is provided', async () => {
    const vm = new AgentVM()
    const customStore = new Map<string, any>()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'storeSet', key: 'test', value: 'hello' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(
      ast,
      {},
      {
        capabilities: {
          store: {
            get: async (key) => customStore.get(key),
            set: async (key, value) => {
              customStore.set(key, value)
            },
          },
        },
      }
    )
    expect(result.warnings).toBeUndefined()
  })

  it('should support console.warn in code', async () => {
    const vm = new AgentVM()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'consoleWarn', message: 'This is a warning' },
        { op: 'consoleWarn', message: 'Another warning' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(ast, {})
    expect(result.warnings).toBeDefined()
    expect(result.warnings).toContain('This is a warning')
    expect(result.warnings).toContain('Another warning')
  })

  it('should include console.warn in trace', async () => {
    const vm = new AgentVM()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'consoleWarn', message: 'traced warning' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(ast, {}, { trace: true })
    const warnEvent = result.trace?.find((e) => e.op === 'console.warn')
    expect(warnEvent).toBeDefined()
    expect(warnEvent?.input.message).toBe('traced warning')
  })

  it('should support console.log in trace', async () => {
    const vm = new AgentVM()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'consoleLog', message: 'debug message' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(ast, {}, { trace: true })
    const logEvent = result.trace?.find((e) => e.op === 'console.log')
    expect(logEvent).toBeDefined()
    expect(logEvent?.input.message).toBe('debug message')
  })

  it('should support console.error to stop execution', async () => {
    const vm = new AgentVM()
    const ast = {
      op: 'seq',
      steps: [
        { op: 'varSet', key: 'before', value: 'set' },
        { op: 'consoleError', message: 'Fatal error occurred' },
        { op: 'varSet', key: 'after', value: 'should not run' },
        { op: 'return', schema: {} },
      ],
    } as any

    const result = await vm.run(ast, {})
    expect(result.error).toBeDefined()
    expect(result.error?.message).toBe('Fatal error occurred')
  })

  it('should execute dynamically generated code with runCode', async () => {
    const vm = new AgentVM()

    // Code that generates and runs another piece of code
    const ast = ajs(`
      function dynamicExec({ multiplier = 3 }) {
        let code = 'function calc() { let x = 5 * 7; return { result: x } }'
        let output = runCode({ code, args: {} })
        let final = output.result * multiplier
        return { dynamicResult: output.result, final }
      }
    `)

    // Provide the code.transpile capability
    const { transpile } = await import('./transpiler')
    const result = await vm.run(
      ast,
      { multiplier: 2 },
      {
        capabilities: {
          code: {
            transpile: (source: string) => transpile(source).ast,
          },
        },
      }
    )

    expect(result.result.dynamicResult).toBe(35) // 5 * 7
    expect(result.result.final).toBe(70) // 35 * 2
  })

  it('should share fuel budget between parent and runCode', async () => {
    const vm = new AgentVM()

    // Code that runs a loop in dynamic code - should consume shared fuel
    const ast = ajs(`
      function fuelTest() {
        let code = 'function loop() { let i = 0; while (i < 100) { i = i + 1 }; return { count: i } }'
        let output = runCode({ code, args: {} })
        return { result: output.count }
      }
    `)

    const { transpile } = await import('./transpiler')
    const result = await vm.run(
      ast,
      {},
      {
        fuel: 500,
        capabilities: {
          code: {
            transpile: (source: string) => transpile(source).ast,
          },
        },
      }
    )

    expect(result.result.result).toBe(100)
    // The loop should have consumed fuel (while loop + iterations)
    expect(result.fuelUsed).toBeGreaterThan(10)
  })

  it('should fail gracefully when code.transpile capability is missing', async () => {
    const vm = new AgentVM()

    const ast = ajs(`
      function noCapability() {
        let output = runCode({ code: 'function x() { return { y: 1 } }', args: {} })
        return { output }
      }
    `)

    const result = await vm.run(
      ast,
      {},
      {
        capabilities: {}, // No code capability
      }
    )

    expect(result.error).toBeDefined()
    expect(result.error?.message).toContain('code.transpile')
  })

  it('should transpile code without executing via transpileCode', async () => {
    const vm = new AgentVM()

    const ast = ajs(`
      function getAst() {
        let code = 'function add(a: 1, b: 2) { return { sum: a + b } }'
        let ast = transpileCode({ code })
        return { ast }
      }
    `)

    const { transpile } = await import('./transpiler')
    const result = await vm.run(
      ast,
      {},
      {
        capabilities: {
          code: {
            transpile: (source: string) => transpile(source).ast,
          },
        },
      }
    )

    expect(result.result.ast).toBeDefined()
    expect(result.result.ast.op).toBe('seq')
    expect(result.result.ast.steps).toBeDefined()
  })

  it('should limit runCode recursion depth', async () => {
    const vm = new AgentVM()

    // Code that tries to recursively call runCode
    const ast = ajs(`
      function recursiveCode() {
        let code = 'function inner() { let x = runCode({ code: "function f() { return { v: 1 } }", args: {} }); return { x } }'
        let result = runCode({ code, args: {} })
        return { result }
      }
    `)

    const { transpile } = await import('./transpiler')

    // This should work - only 2 levels deep
    const result = await vm.run(
      ast,
      {},
      {
        capabilities: {
          code: {
            transpile: (source: string) => transpile(source).ast,
          },
        },
      }
    )

    // The nested runCode should succeed (2 levels is fine)
    expect(result.result.result.x.v).toBe(1)
  })

  it('should validate atom output against outputSchema', async () => {
    // Define an atom that returns the wrong type
    const badAtom = defineAtom(
      'badOutput',
      s.object({}),
      s.object({ value: s.number }), // Expects { value: number }
      async () => {
        return { value: 'not a number' } // Returns string instead
      }
    )

    const vm = new AgentVM({ badOutput: badAtom })

    const ast = {
      op: 'seq',
      steps: [{ op: 'badOutput', result: 'res' }],
    } as any

    const result = await vm.run(ast, {})

    // Should fail with output validation error
    expect(result.error).toBeDefined()
    expect(result.error?.message).toContain('Output validation failed')
    expect(result.error?.op).toBe('badOutput')
  })

  it('should allow valid atom output that matches outputSchema', async () => {
    // Define an atom that returns the correct type
    const goodAtom = defineAtom(
      'goodOutput',
      s.object({}),
      s.object({ value: s.number }), // Expects { value: number }
      async () => {
        return { value: 42 } // Returns correct type
      }
    )

    const vm = new AgentVM({ goodOutput: goodAtom })

    const ast = {
      op: 'seq',
      steps: [
        { op: 'goodOutput', result: 'res' },
        {
          op: 'return',
          schema: { type: 'object', properties: { res: { type: 'object' } } },
        },
      ],
    } as any

    const result = await vm.run(ast, {})

    // Should succeed
    expect(result.error).toBeUndefined()
    expect(result.result.res).toEqual({ value: 42 })
  })

  describe('structural equality in expressions', () => {
    it('== compares arrays structurally', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '==',
              left: { $expr: 'literal', value: [1, 2, 3] },
              right: { $expr: 'literal', value: [1, 2, 3] },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(true)
    })

    it('== compares objects structurally', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '==',
              left: { $expr: 'literal', value: { a: 1, b: 2 } },
              right: { $expr: 'literal', value: { a: 1, b: 2 } },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(true)
    })

    it('== does not coerce types', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '==',
              left: { $expr: 'literal', value: '1' },
              right: { $expr: 'literal', value: 1 },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(false) // no coercion
    })

    it('!= returns true for structurally different objects', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '!=',
              left: { $expr: 'literal', value: { a: 1 } },
              right: { $expr: 'literal', value: { a: 2 } },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(true)
    })

    it('null == undefined is true (nullish equality)', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '==',
              left: { $expr: 'literal', value: null },
              right: { $expr: 'ident', name: 'missing' },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(true) // null == undefined
    })

    it('=== still uses identity comparison', async () => {
      const ast = {
        op: 'seq',
        steps: [
          {
            op: 'varSet',
            key: 'res',
            value: {
              $expr: 'binary',
              op: '===',
              left: { $expr: 'literal', value: [1, 2] },
              right: { $expr: 'literal', value: [1, 2] },
            },
          },
          { op: 'return', value: { $expr: 'ident', name: 'res' } },
        ],
      } as any
      const result = await vm.run(ast, {})
      expect(result.result).toBe(false) // different references
    })
  })
})
