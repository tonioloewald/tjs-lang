import { describe, it, expect } from 'bun:test'
import { VM, defineAtom } from './runtime'
import { A99 } from './builder'
import { s } from 'tosijs-schema'

describe('Agent99 Runtime (VM)', () => {
  it('should execute a manually constructed AST', async () => {
    // Manually constructing AST to test VM in isolation
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'math.calc',
          expr: 'x + 10',
          vars: { x: { $kind: 'arg', path: 'val' } },
          result: 'res',
        },
        {
          op: 'return',
          schema: { type: 'object', properties: { res: { type: 'number' } } },
        },
      ],
    } as any

    const result = await VM.run(ast, { val: 5 })
    expect(result).toEqual({ res: 15 })
  })

  it('should run an AST generated by the Builder', async () => {
    // 1. Build
    // Calculates: price * (1 + tax)
    const logic = A99.take(s.object({ price: s.number, tax: s.number }))
      .calc('price * (1 + tax)', {
        price: A99.args('price'),
        tax: A99.args('tax'),
      })
      .as('total')
      .return(s.object({ total: s.number }))

    // 2. Serialize
    const ast = logic.toJSON()

    // 3. Run
    const result = await VM.run(ast, { price: 100, tax: 0.2 })

    // 100 * 1.2 = 120
    expect(result).toBeDefined()
    expect(result.total).toBe(120)
  })

  it('should handle complex math expressions using precedence', async () => {
    // (a + b) * c / 2
    // (10 + 20) * 4 / 2 = 30 * 4 / 2 = 60
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'math.calc',
          expr: '(a + b) * c / 2',
          vars: {
            a: { $kind: 'arg', path: 'a' },
            b: { $kind: 'arg', path: 'b' },
            c: { $kind: 'arg', path: 'c' },
          },
          result: 'res',
        },
        { op: 'return', schema: { properties: { res: {} } } },
      ],
    } as any

    const result = await VM.run(ast, { a: 10, b: 20, c: 4 })
    expect(result.res).toBe(60)
  })

  it('should enforce fuel limits', async () => {
    const ast = {
      op: 'seq',
      steps: [
        // Fuel is checked at start of step loop.
        { op: 'math.calc', expr: '1+1', vars: {} },
        { op: 'math.calc', expr: '1+1', vars: {} },
        { op: 'math.calc', expr: '1+1', vars: {} },
      ],
    } as any

    // Logic:
    // Fuel 2 provided.
    // Step 1: Fuel 2 -> 1. OK.
    // Step 2: Fuel 1 -> 0. OK.
    // Step 3: Fuel 0. Error.
    expect(VM.run(ast, {}, { fuel: 2 })).rejects.toThrow('Agent99: Out of Fuel')
  })

  it('should return strict subsets of state based on schema', async () => {
    // Test that the return op filters the state
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'math.calc',
          expr: '100',
          vars: {},
          result: 'secret',
        },
        {
          op: 'math.calc',
          expr: '200',
          vars: {},
          result: 'public',
        },
        {
          op: 'return',
          // Only ask for 'public'
          schema: { properties: { public: { type: 'number' } } },
        },
      ],
    } as any

    const result = await VM.run(ast, {})
    expect(result.public).toBe(200)
    expect(result.secret).toBeUndefined()
  })

  it('should enforce atom timeouts', async () => {
    defineAtom(
      'test.slow',
      s.any,
      undefined,
      async () => {
        await new Promise((resolve) => setTimeout(resolve, 50))
      },
      { timeoutMs: 10 }
    )

    const ast = {
      op: 'seq',
      steps: [{ op: 'test.slow' }],
    } as any

    expect(VM.run(ast, {})).rejects.toThrow("Atom 'test.slow' timed out after 10ms")
  })
})
