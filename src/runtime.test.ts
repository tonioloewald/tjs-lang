import { describe, it, expect } from 'bun:test'
import { defineAtom } from './runtime'
import { AgentVM } from './vm'
import { A99 } from './builder'
import { s } from 'tosijs-schema'

describe('Agent99 Runtime (VM)', () => {
  const vm = new AgentVM()

  it('should execute a manually constructed AST', async () => {
    // Manually constructing AST to test VM in isolation
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'mathCalc',
          expr: 'x + 10',
          vars: { x: { $kind: 'arg', path: 'val' } },
          result: 'res',
        },
        {
          op: 'return',
          schema: { type: 'object', properties: { res: { type: 'number' } } },
        },
      ],
    } as any

    const result = await vm.run(ast, { val: 5 })
    expect(result.result).toEqual({ res: 15 })
  })

  it('should run an AST generated by the Builder', async () => {
    // 1. Build
    // Calculates: price * (1 + tax)
    const logic = A99.take(s.object({ price: s.number, tax: s.number }))
      .mathCalc({
        expr: 'price * (1 + tax)',
        vars: {
          price: A99.args('price'),
          tax: A99.args('tax'),
        },
      })
      .as('total')
      .return(s.object({ total: s.number }))

    // 2. Serialize
    const ast = logic.toJSON()

    // 3. Run
    const result = await vm.run(ast, { price: 100, tax: 0.2 })

    // 100 * 1.2 = 120
    expect(result.result).toBeDefined()
    expect(result.result.total).toBe(120)
  })

  it('should handle complex math expressions using precedence', async () => {
    // (a + b) * c / 2
    // (10 + 20) * 4 / 2 = 30 * 4 / 2 = 60
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'mathCalc',
          expr: '(a + b) * c / 2',
          vars: {
            a: { $kind: 'arg', path: 'a' },
            b: { $kind: 'arg', path: 'b' },
            c: { $kind: 'arg', path: 'c' },
          },
          result: 'res',
        },
        { op: 'return', schema: { properties: { res: {} } } },
      ],
    } as any

    const result = await vm.run(ast, { a: 10, b: 20, c: 4 })
    expect(result.result.res).toBe(60)
  })

  it('should enforce fuel limits', async () => {
    const ast = {
      op: 'seq',
      steps: [
        // Fuel is checked at start of step loop.
        { op: 'mathCalc', expr: '1+1', vars: {} },
        { op: 'mathCalc', expr: '1+1', vars: {} },
        { op: 'mathCalc', expr: '1+1', vars: {} },
      ],
    } as any

    // Logic:
    // Fuel 2 provided.
    // Step 1: Fuel 2 -> 1. OK.
    // Step 2: Fuel 1 -> 0. OK.
    // Step 3: Fuel 0. Error.
    expect(vm.run(ast, {}, { fuel: 2 })).rejects.toThrow('Out of Fuel')
  })

  it('should return strict subsets of state based on schema', async () => {
    // Test that the return op filters the state
    const ast = {
      op: 'seq',
      steps: [
        {
          op: 'mathCalc',
          expr: '100',
          vars: {},
          result: 'secret',
        },
        {
          op: 'mathCalc',
          expr: '200',
          vars: {},
          result: 'public',
        },
        {
          op: 'return',
          // Only ask for 'public'
          schema: { properties: { public: { type: 'number' } } },
        },
      ],
    } as any

    const result = await vm.run(ast, {})
    expect(result.result.public).toBe(200)
    expect(result.result.secret).toBeUndefined()
  })

  it('should enforce atom timeouts', async () => {
    const slowAtom = defineAtom(
      'testSlow',
      s.any,
      undefined,
      async () => {
        await new Promise((resolve) => setTimeout(resolve, 50))
      },
      { timeoutMs: 10 }
    )

    const vm = new AgentVM({ testSlow: slowAtom })

    const ast = {
      op: 'seq',
      steps: [{ op: 'testSlow' }],
    } as any

    expect(vm.run(ast, {})).rejects.toThrow("Atom 'testSlow' timed out")
  })

  it('should set multiple variables with varsLet', async () => {
    const logic = A99.take()
      .varsLet({ a: 10, b: 20, c: 'hello' })
      .mathCalc({ expr: 'a + b' })
      .as('calcResult')
      .return(s.object({ calcResult: s.number, a: s.number, c: s.string }))

    const ast = logic.toJSON()
    const result = await vm.run(ast, {})

    expect(result.result).toBeDefined()
    expect(result.result.calcResult).toBe(30)
    expect(result.result.a).toBe(10)
    expect(result.result.c).toBe('hello')
  })

  it('should generate a trace when trace mode is enabled', async () => {
    const logic = A99.take(s.object({ val: s.number }))
      .varSet({ key: 'x', value: 10 })
      .mathCalc({
        expr: 'x + val',
        vars: {
          val: A99.args('val'),
        },
      })
      .as('res')

    const ast = logic.toJSON()
    const { result, trace /* , fuelUsed */ } = await vm.run(
      ast,
      { val: 5 },
      { trace: true }
    )

    expect(result).toBeUndefined() // No return op
    expect(trace).toBeDefined()
    expect(trace).toHaveLength(3)
    if (!trace) throw new Error('Trace is missing')

    // The trace is in post-order traversal, so seq is last.
    // 1. varSet
    expect(trace[0].op).toBe('varSet')
    expect(trace[0].input).toEqual({ key: 'x', value: 10 })
    expect(trace[0].stateBefore).toEqual({})
    expect(trace[0].stateAfter).toEqual({ x: 10 })

    // 2. mathCalc
    expect(trace[1].op).toBe('mathCalc')
    expect(trace[1].stateBefore).toEqual({ x: 10 })
    expect(trace[1].stateAfter).toEqual({ x: 10, res: 15 })
    expect(trace[1].result).toBe(15)

    // 3. seq
    expect(trace[2].op).toBe('seq')
  })
})
