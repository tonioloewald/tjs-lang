/*#
# TJS Platform Cloud Functions

Cloud Functions for the TJS Platform.
Modular architecture with separate concerns:
- crypto.tjs - Encryption/decryption
- llm.tjs - LLM capability (multi-provider)
- schema.tjs - JSON schema validation
- rbac.tjs - Security rules & access shortcuts
- indexes.tjs - Automatic index management
- store.tjs - Store capability with RBAC
- routing.tjs - URL pattern matching & function cache

## Future Work
- Benchmark `safety none` vs `safety inputs` - likely negligible overhead for small payloads
*/

safety none
TjsSafeEval

import { onRequest } from 'firebase-functions/v2/https'
import { onCall, HttpsError } from 'firebase-functions/v2/https'
import { initializeApp } from 'firebase-admin/app'
import { getFirestore, FieldValue } from 'firebase-admin/firestore'

// Local modules (use .js extension for bundler compatibility)
import { decrypt } from './crypto.js'
import { createLlmCapability } from './llm.js'
import { createStoreCapability } from './store.js'
import { matchUrlPattern, getStoredFunctions } from './routing.js'

// Initialize Firebase Admin
initializeApp()

const db = getFirestore()

/*#
## Get User API Keys

Loads and decrypts the user's API keys from Firestore.
*/
async function getUserApiKeys(uid) {
  const userDoc = await db.collection('users').doc(uid).get()

  if (!userDoc.exists) {
    return {}
  }

  const userData = userDoc.data()
  const { encryptionKey, apiKeys } = userData

  if (!encryptionKey || !apiKeys) {
    return {}
  }

  const decrypted = {}

  for (const [provider, encryptedKey] of Object.entries(apiKeys)) {
    if (encryptedKey) {
      try {
        decrypted[provider] = await decrypt(encryptedKey, encryptionKey)
      } catch (e) {
        console.error(`Failed to decrypt ${provider} key:`, e.message)
      }
    }
  }

  return decrypted
}

/*#
## Health Check

Simple endpoint to verify functions are deployed and running.
*/
export const health = onRequest((req, res) => {
  res.json({
    status: 'ok',
    timestamp: Date.now(),
    version: '0.4.0'
  })
})

/*#
## Agent Run Endpoint

Universal AJS endpoint - accepts code, args, and fuel limit.
Executes the code in a sandboxed VM with user's API keys as capabilities.
*/

// Simple hash for payload checksum
function hashPayload(payload) {
  const str = JSON.stringify(payload)
  let hash = 0
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = ((hash << 5) - hash) + char
    hash = hash & hash
  }
  return hash.toString(16)
}

export const agentRun = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError('unauthenticated', 'Must be authenticated to run agents')
  }

  const uid = request.auth.uid
  const { code, args = {}, fuel = 1000 } = request.data

  if (!code || typeof code !== 'string') {
    throw new HttpsError('invalid-argument', 'code must be a non-empty string')
  }

  if (fuel > 10000) {
    throw new HttpsError('invalid-argument', 'fuel limit cannot exceed 10000')
  }

  const startTime = Date.now()
  let result = null
  let error = null

  try {
    const apiKeys = await getUserApiKeys(uid)
    const llm = createLlmCapability(apiKeys)
    const store = createStoreCapability(uid)

    result = await Eval({
      code,
      context: args,
      fuel,
      timeoutMs: 30000,
      capabilities: { llm, store }
    })
  } catch (err) {
    console.error('Agent execution error:', err)
    error = { message: err.message || 'Execution failed' }
  }

  // Log usage
  const fuelUsed = result?.fuelUsed || 0
  const duration = Date.now() - startTime
  const usageLog = {
    timestamp: Date.now(),
    duration,
    payloadHash: hashPayload({ code, args }),
    fuelRequested: fuel,
    fuelUsed,
    hasError: !!(error || result?.error),
    resultHash: result?.result ? hashPayload(result.result) : null
  }

  const usageRef = db.collection('users').doc(uid).collection('usage')
  usageRef.add(usageLog).catch(err => console.error('Failed to log usage:', err))
  usageRef.doc('total').set({
    totalCalls: FieldValue.increment(1),
    totalFuelUsed: FieldValue.increment(fuelUsed),
    totalDuration: FieldValue.increment(duration),
    totalErrors: FieldValue.increment(error || result?.error ? 1 : 0),
    lastUpdated: Date.now()
  }, { merge: true }).catch(err => console.error('Failed to update totals:', err))

  if (error) {
    return { result: null, fuelUsed: 0, error }
  }

  return {
    result: result.result,
    fuelUsed: result.fuelUsed || 0,
    error: result.error || null
  }
})

/*#
## REST Agent Endpoint

Same as agentRun but as a simple POST endpoint.
Auth via Bearer token (Firebase ID token).
*/
export const run = onRequest(async (req, res) => {
  // CORS
  res.set('Access-Control-Allow-Origin', '*')
  if (req.method === 'OPTIONS') {
    res.set('Access-Control-Allow-Methods', 'POST')
    res.set('Access-Control-Allow-Headers', 'Authorization, Content-Type')
    res.set('Access-Control-Max-Age', '3600')
    return res.status(204).send('')
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Verify auth
  const authHeader = req.headers.authorization
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing or invalid Authorization header' })
  }

  const idToken = authHeader.slice(7)
  let uid
  try {
    const { getAuth } = await import('firebase-admin/auth')
    const decoded = await getAuth().verifyIdToken(idToken)
    uid = decoded.uid
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' })
  }

  const { code, args = {}, fuel = 1000 } = req.body

  if (!code || typeof code !== 'string') {
    return res.status(400).json({ error: 'code must be a non-empty string' })
  }

  if (fuel > 10000) {
    return res.status(400).json({ error: 'fuel limit cannot exceed 10000' })
  }

  const startTime = Date.now()
  let result = null
  let error = null

  try {
    const apiKeys = await getUserApiKeys(uid)
    const llm = createLlmCapability(apiKeys)
    const store = createStoreCapability(uid)

    result = await Eval({
      code,
      context: args,
      fuel,
      timeoutMs: 30000,
      capabilities: { llm, store }
    })
  } catch (err) {
    console.error('Agent execution error:', err)
    error = { message: err.message || 'Execution failed' }
  }

  // Log usage
  const fuelUsed = result?.fuelUsed || 0
  const duration = Date.now() - startTime
  const usageLog = {
    timestamp: Date.now(),
    duration,
    payloadHash: hashPayload({ code, args }),
    fuelRequested: fuel,
    fuelUsed,
    hasError: !!(error || result?.error),
    resultHash: result?.result ? hashPayload(result.result) : null
  }

  const usageRef = db.collection('users').doc(uid).collection('usage')
  usageRef.add(usageLog).catch(err => console.error('Failed to log usage:', err))
  usageRef.doc('total').set({
    totalCalls: FieldValue.increment(1),
    totalFuelUsed: FieldValue.increment(fuelUsed),
    totalDuration: FieldValue.increment(duration),
    totalErrors: FieldValue.increment(error || result?.error ? 1 : 0),
    lastUpdated: Date.now()
  }, { merge: true }).catch(err => console.error('Failed to update totals:', err))

  if (error) {
    return res.status(200).json({ result: null, fuelUsed: 0, error })
  }

  res.json({
    result: result.result,
    fuelUsed: result.fuelUsed || 0,
    error: result.error || null
  })
})

/*#
## Page Endpoint

Serves stored functions based on URL routing.
Matches incoming path against stored function URL patterns.
Executes matched function's AJS code and returns with appropriate content-type.
*/
export const page = onRequest(async (req, res) => {
  // CORS
  res.set('Access-Control-Allow-Origin', '*')
  if (req.method === 'OPTIONS') {
    res.set('Access-Control-Allow-Methods', 'GET, POST')
    res.set('Access-Control-Allow-Headers', 'Authorization, Content-Type')
    res.set('Access-Control-Max-Age', '3600')
    return res.status(204).send('')
  }

  const path = req.path || '/'

  try {
    const storedFunctions = await getStoredFunctions()

    // Find matching function
    let matchedFunction = null
    let params = null

    for (const fn of storedFunctions) {
      if (!fn.urlPattern || !fn.code) continue

      const match = matchUrlPattern(fn.urlPattern, path)
      if (match !== null) {
        matchedFunction = fn
        params = match
        break
      }
    }

    if (!matchedFunction) {
      return res.status(404).json({ error: 'Not found', path })
    }

    // Check auth for non-public functions
    let uid = null
    if (!matchedFunction.public) {
      const authHeader = req.headers.authorization
      if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Authentication required' })
      }

      const idToken = authHeader.slice(7)
      try {
        const { getAuth } = await import('firebase-admin/auth')
        const decoded = await getAuth().verifyIdToken(idToken)
        uid = decoded.uid
      } catch (err) {
        return res.status(401).json({ error: 'Invalid token' })
      }
    }

    // Build args from URL params, query string, and body
    const args = {
      ...params,
      ...req.query,
      ...(req.body || {}),
      _path: path,
      _method: req.method,
      _uid: uid
    }

    // Execute the stored function
    let result = null
    let error = null

    try {
      let llm = null
      if (uid) {
        const apiKeys = await getUserApiKeys(uid)
        llm = createLlmCapability(apiKeys)
      }

      result = await Eval({
        code: matchedFunction.code,
        context: args,
        fuel: matchedFunction.fuel || 1000,
        timeoutMs: matchedFunction.timeoutMs || 10000,
        capabilities: llm ? { llm } : {}
      })
    } catch (err) {
      console.error('Stored function execution error:', err)
      error = { message: err.message || 'Execution failed' }
    }

    if (error || result?.error) {
      const errorMessage = error?.message || result?.error?.message || 'Unknown error'
      return res.status(500).json({ error: errorMessage })
    }

    // Set content type and return result
    const contentType = matchedFunction.contentType || 'application/json'
    res.set('Content-Type', contentType)

    if (contentType.includes('text/') || contentType.includes('html')) {
      return res.send(result.result)
    } else {
      return res.json(result.result)
    }

  } catch (err) {
    console.error('Page endpoint error:', err)
    return res.status(500).json({ error: 'Internal server error' })
  }
})
