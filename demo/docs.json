[
  {
    "text": "<!--{\"pin\": \"top\"}-->\n\n# tosijs-agent\n\n[github](https://github.com/tonioloewald/tosijs-agent#readme) | [npm](https://www.npmjs.com/package/tosijs-agent) | [discord](https://discord.gg/ramJ9rgky5)\n\n![tosijs-agent logo](/tosijs-agent.svg)\n\nA **type-safe-by-design, cost-limited virtual machine** that enables the **safe execution of untrusted code** anywhere.\n\nIt's **safe eval** in the cloud.\n\nAnd it's **tiny**, ![bundlejs bundle including dependencies](https://deno.bundlejs.com/badge?q=tosijs-agent).\n\ntosijs-agent allows you to define complex logic chains, agents, and data pipelines—_computer programs_—using a fluent TypeScript builder. These definitions compile to a safe, JSON-serializable AST ([Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)) that can be executed in the browser, on the server, or at the edge.\n\nFor a deeper dive into the architecture and security model, see the [Technical Context](./CONTEXT.md).\n\n### Why do you care?\n\n- **Service-as-a-Service:** Define a complete backend service—including database fetches, API calls, and logic—entirely as data, and execute it safely on a server.\n- **Agents-as-Data:** Build AI agents entirely as JSON objects. Send them to a server to run instantly—no deployment, no build steps, no spin-up time.\n- **Universal Runtime:** Run your agent logic in the browser for zero-latency UI updates, or move it to the server for heavy lifting. Because the AST is strongly typed JSON, it is easy to build a runtime for any language or hardware stack, or even compile it directly to LLVM.\n\n### The Holy Grail\n\ntosijs-agent solves fundamental problems in distributed computing:\n\n- **Safe \"Useful Mining\":** Allows distributed nodes to execute productive, arbitrary work safely (sandboxed & gas-limited) — e.g. replacing Proof-of-Work with distributed data processing.\n- **Code is Data:** Logic is defined as a portable AST, making execution language-agnostic and portable.\n- **True Network Agents:** Write code that travels to the data, rather than moving petabytes of data to the code.\n- **Type-Safe Composition:** Build robust pipelines where inputs and outputs are strictly validated at every step.\n\n## Comparison: tosijs-agent vs LangChain\n\nConsider building a \"Research Agent\" that searches for a topic, summarizes it, critiques the summary, and refines the search if needed.\n\n### LangChain\n\nRequires defining Tools, PromptTemplates, Chains (or Graph nodes), and wiring them up with complex state management classes. To refine the logic, you must redeploy the application code.\n\n### tosijs-agent\n\nThe entire logic is a single, fluent expression that compiles to JSON. You can refine the agent's behavior by simply sending a new JSON payload to the server—no deployment required.\n\n```typescript\n// Research Agent: Search -> Summarize -> Critique -> Loop\nconst agent = Agent.take(s.object({ topic: s.string })).while(\n  '!good && tries < 3',\n  {},\n  (loop) =>\n    loop\n      .storeSearch({ query: 'topic' })\n      .as('results')\n      .llmPredict({ system: 'Summarize', user: 'results' })\n      .as('summary')\n      .llmPredict({ system: 'Critique', user: 'summary' })\n      .as('feedback')\n      .if(\n        'feedback == \"OK\"',\n        {},\n        (yes) => yes.varSet({ key: 'good', value: true }),\n        (no) => no.llmPredict({ system: 'Refine', user: 'topic' }).as('topic')\n      )\n)\n```\n\n## Interactive Example: Cover Version Finder\n\nThis example shows the complete loop: a UI form captures user input, AsyncJS code processes it (calling an API and using an LLM to analyze results), and displays the output.\n\n```html\n<!-- HTML: Simple search form -->\n<form id=\"cover-search\">\n  <input type=\"text\" id=\"song\" placeholder=\"Song name\" value=\"Yesterday\" />\n  <input type=\"text\" id=\"artist\" placeholder=\"Original artist\" value=\"Beatles\" />\n  <button type=\"submit\">Find Covers</button>\n</form>\n<div id=\"results\"></div>\n```\n```js\n// Wire up the form to AsyncJS\n// Uses demoRuntime which gets LLM settings from the Settings dialog\nimport { ajs } from 'tosijs-agent'\n\n// The AsyncJS code - searches iTunes and uses LLM to find covers\nconst findCovers = ajs`\n  function findCovers({ song, artist }) {\n    let query = song + ' ' + artist\n    let url = \\`https://itunes.apple.com/search?term=\\${query}&limit=25&media=music\\`\n    let response = httpFetch({ url, cache: 3600 })\n    \n    let results = response.results || []\n    let tracks = results.map(x => \\`\"\\${x.trackName}\" by \\${x.artistName} (\\${x.collectionName})\\`)\n    let trackList = tracks.join('\\\\n')\n    \n    // Define schema for structured output - guarantees valid JSON\n    let schema = {\n      type: 'json_schema',\n      json_schema: {\n        name: 'cover_versions',\n        strict: true,\n        schema: {\n          type: 'object',\n          properties: {\n            covers: {\n              type: 'array',\n              items: {\n                type: 'object',\n                properties: {\n                  track: { type: 'string' },\n                  artist: { type: 'string' },\n                  album: { type: 'string' }\n                },\n                required: ['track', 'artist', 'album'],\n                additionalProperties: false\n              }\n            }\n          },\n          required: ['covers'],\n          additionalProperties: false\n        }\n      }\n    }\n    \n    let prompt = \\`Search results for \"\\${song}\" by \\${artist}:\n\n\\${trackList}\n\nList cover versions (tracks NOT by \\${artist}).\\`\n\n    let llmResponse = llmPredict({ prompt, options: { responseFormat: schema } })\n    let parsed = JSON.parse(llmResponse)\n    return { song, artist, covers: parsed.covers }\n  }\n`\n\n// Handle form submission\ndocument.getElementById('cover-search').onsubmit = async (e) => {\n  e.preventDefault()\n  const resultsDiv = document.getElementById('results')\n  resultsDiv.textContent = 'Searching...'\n\n  // demoRuntime uses API keys from Settings dialog\n  const { result, error } = await demoRuntime.run(\n    findCovers,\n    {\n      song: document.getElementById('song').value,\n      artist: document.getElementById('artist').value,\n    },\n    { fuel: 1000 }\n  )\n\n  if (error) {\n    resultsDiv.textContent = `Error: ${error.message}`\n  } else if (result.covers.length === 0) {\n    resultsDiv.textContent = 'No cover versions found.'\n  } else {\n    resultsDiv.innerHTML = `<h3>Cover versions of \"${result.song}\":</h3><ul>` +\n      result.covers.map(c => `<li>\"${c.track}\" by ${c.artist} (${c.album})</li>`).join('') +\n      '</ul>'\n  }\n}\n```\n\nThis demonstrates:\n- **Safe execution**: The AsyncJS code runs in a sandboxed VM with fuel limits\n- **Capability injection**: LLM access is provided by the host, not the untrusted code\n- **Portable logic**: The `findCovers` AST could be sent to a server for execution instead\n\n## Example Project\n\nTo see a complete, working example of how to build an agent with a simple UI, check out the official playground project:\n\n**[https://github.com/brainsnorkel/agent99-playground](https://github.com/brainsnorkel/agent99-playground)**\n\n## Installation\n\n```bash\nbun add tosijs-agent\n# or\nnpm install tosijs-agent\n```\n\n## Quick Start\n\n### 1. Define Logic (The Builder)\n\nUse the fluent builder to create a logic chain.\n\n```typescript\nimport { Agent, s } from 'tosijs-agent'\n\n// Define a simple calculation agent\nconst calculateTotal = Agent.take(\n  s.object({\n    price: s.number,\n    taxRate: s.number,\n  })\n)\n  // Use varSet with expression nodes for arithmetic\n  .varSet({\n    key: 'total',\n    value: {\n      $expr: 'binary',\n      op: '*',\n      left: Agent.args('price'),\n      right: {\n        $expr: 'binary',\n        op: '+',\n        left: { $expr: 'literal', value: 1 },\n        right: Agent.args('taxRate'),\n      },\n    },\n  })\n  .return(s.object({ total: s.number }))\n\n// Compile to JSON AST\nconst ast = calculateTotal.toJSON()\nconsole.log(JSON.stringify(ast, null, 2))\n```\n\n### 2. Execute (The VM)\n\nRun the AST in the VM. The VM is stateless and isolated.\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\n\nconst vm = new AgentVM()\n\nconst result = await vm.run(\n  ast,\n  { price: 100, taxRate: 0.2 }, // Input Args\n  { fuel: 1000 } // Execution Options\n)\n\nconsole.log(result.result) // { total: 120 }\nconsole.log(result.fuelUsed) // Gas consumed\n```\n\n## Tracing and Debugging\n\nFor debugging and testing, you can enable trace mode to get a detailed log of the agent's execution path.\n\n```typescript\nconst { result, trace } = await vm.run(\n  ast,\n  { price: 100, taxRate: 0.2 },\n  { trace: true } // Enable trace mode\n)\n\nconsole.log(trace)\n```\n\nThe `trace` output is an array of `TraceEvent` objects, where each event records the state of the agent before and after an atom's execution, along with the inputs, outputs, and fuel consumption.\n\n```typescript\ninterface TraceEvent {\n  op: string\n  input: any\n  stateBefore: any\n  stateAfter: any\n  result?: any\n  error?: string\n  fuelBefore: number\n  fuelAfter: number\n  timestamp: string\n}\n```\n\n## Core Atoms\n\nThe standard library includes essential primitives:\n\n| Category         | Atoms                                                              | Description                                                                                                           |\n| ---------------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | `seq`, `if`, `while`, `return`, `try`                              | Control flow and loops.                                                                                               |\n| **State**        | `varSet`, `varGet`, `varsLet`, `varsImport`, `varsExport`, `scope` | Variable management, including batch operations for importing variables from arguments and exporting them as results. |\n| **Expressions**  | ExprNode (`$expr`)                                                 | Safe expression evaluation via AST nodes (binary, unary, member, etc.).                                               |\n| **Logic**        | `eq`, `gt`, `and`, `not`, ...                                      | Boolean logic.                                                                                                        |\n| **IO**           | `httpFetch`                                                        | HTTP requests.                                                                                                        |\n| **Store**        | `storeGet`, `storeSet`                                             | Key-Value storage.                                                                                                    |\n| **AI**           | `llmPredict`, `agentRun`                                           | LLM calls and sub-agent recursion.                                                                                    |\n| **Utils**        | `random`, `uuid`, `hash`                                           | Random generation, UUIDs, and hashing.                                                                                |\n| **Optimization** | `memoize`, `cache`                                                 | In-memory memoization and persistent caching. Keys are optional and will be auto-generated if not provided.           |\n\n## Capabilities & Security\n\ntosijs-agent uses a **[Capability-Based Security](https://en.wikipedia.org/wiki/Capability-based_security)** model. The VM cannot access the network, file system, or database unless provided with a Capability.\n\n**Zero Config Defaults:** The runtime provides sensible defaults for local development:\n\n- `httpFetch` uses the global `fetch`.\n- `store` uses an in-memory `Map` (ephemeral).\n- `random`/`uuid` use `crypto` or `Math`.\n\nIn production, you should inject secure, instrumented, or cloud-native implementations (e.g., restricted fetch, Postgres, Redis).\n\n### Execution Timeout\n\nThe VM enforces a hard timeout to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n- **Automatic Safety Net:** Defaults to `fuel × 10ms` (e.g., 1000 fuel ≈ 10s budget). _Note: For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n- **Explicit Control:** Pass `timeoutMs` to enforce a strict Service Level Agreement (SLA).\n- **Cancellation:** Pass an `AbortSignal` to integrate with external cancellation controllers (e.g., user cancellation buttons or HTTP request timeouts).\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom (via `ctx.signal`). Atoms implementing cancellation (like `httpFetch`) will abort their network requests immediately.\n\n```typescript\n// 1. Default Safety Net (good for compute-heavy logic)\nawait vm.run(ast, args, { fuel: 1000 })\n\n// 2. SLA Enforcement: \"This agent must finish in 5s or we drop it\"\nawait vm.run(ast, args, { fuel: 5000, timeoutMs: 5000 })\n\n// 3. User Cancellation: connect UI \"Stop\" button to the Agent\nconst controller = new AbortController()\nstopButton.onClick(() => controller.abort())\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Fuel vs Timeout:** Fuel protects against CPU-bound abuse (tight loops). Timeout protects against IO-bound abuse (slow network calls). Together they ensure the VM cannot be held hostage.\n\n### Cost Overrides\n\nDefault fuel costs are context-agnostic guesses. In production, you'll want to tune costs for your specific deployment—an LLM call to a local model vs OpenAI has very different resource implications.\n\n```typescript\n// Static overrides\nawait vm.run(ast, args, {\n  fuel: 1000,\n  costOverrides: {\n    httpFetch: 50, // We pay per API request\n    llmPredict: 500, // LLM calls are expensive\n    storeGet: 0.5, // Redis is cheap\n  },\n})\n\n// Dynamic overrides based on input\nawait vm.run(ast, args, {\n  costOverrides: {\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n  },\n})\n```\n\nThis lets operators tune fuel costs for their reality rather than relying on universal defaults.\n\n### Request Context\n\nFor production deployments, you often need to pass request-scoped metadata (auth, permissions, request IDs) to atoms. The `context` option provides a clean mechanism for this.\n\n```typescript\n// Pass auth/permissions from your request handler\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    permissions: ['read:data', 'fetch:external'],\n    requestId: crypto.randomUUID(),\n  },\n})\n```\n\nAtoms access context via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    const permissions = ctx.context?.permissions ?? []\n    if (!permissions.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\nUse cases:\n\n- **Authorization:** Check user permissions before executing sensitive operations\n- **Multi-tenancy:** Route storage/database calls to tenant-specific resources\n- **Audit logging:** Include request IDs in all log entries\n- **Dynamic costs:** Combine with `costOverrides` for user-tier-based pricing\n\n**Security Note:** The sandbox protects against malicious _agents_, not malicious _atom implementations_. Atoms are registered by the host and are trusted to be non-blocking and to respect `ctx.signal` for cancellation.\n\n## Batteries Included (Zero-Dependency Local AI)\n\nFor local AI development, Agent99 provides a \"Batteries Included\" setup that runs out-of-the-box with **zero external dependencies or API keys**. It features a built-in vector search and connects to [LM Studio](https://lmstudio.ai/) for local model inference.\n\n### 1. Setup LM Studio\n\nTo use the batteries, you need to have LM Studio running in the background.\n\n1.  **Download and Install:** Get LM Studio from [lmstudio.ai](https://lmstudio.ai/).\n2.  **Download Models:** You'll need at least one LLM and one embedding model. We recommend:\n    - **LLM:** Search for a [GGUF](https://github.com/ggerganov/ggml/blob/master/docs/gguf.md) model like `Meta-Llama-3-8B-Instruct.Q4_K_M.gguf` for a good balance of performance and size.\n    - **Embedding:** Search for `nomic-embed-text-v1.5.Q8_0.gguf`.\n3.  **Start the Server:** Go to the \"Local Server\" tab (icon: `<-->`) and click \"Start Server\".\n\n### 2. How it Works\n\nWhen you first import the `batteries` from `tosijs-agent`, the runtime performs a one-time audit of the models available on your LM Studio server. It automatically detects which models are for embeddings and which are for chat, and caches the results to avoid re-auditing during the same session.\n\nThis allows Agent99 to automatically select the correct models for different tasks without any configuration. The cache uses `localStorage` if available (in a browser environment), or a simple in-memory cache otherwise.\n\n### 3. Usage\n\nThe `batteries` export contains the necessary capabilities. To use them, register the `batteryAtoms` with the `AgentVM` and pass the `batteries` object to the `run` method's capabilities.\n\n> **Note on Breaking Change:** Previously, battery atoms were exported individually. They are now consolidated into a single `batteryAtoms` object. This simplifies registration with the `AgentVM`.\n>\n> **Old Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, storeVectorize, storeSearch } from 'tosijs-agent'\n> const vm = new AgentVM({ storeVectorize, storeSearch, ... })\n> ```\n>\n> **New Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, batteryAtoms } from 'tosijs-agent'\n> const vm = new AgentVM(batteryAtoms)\n> ```\n\n```typescript\nimport { AgentVM, batteries, batteryAtoms, Agent } from 'tosijs-agent'\n\n// Register the battery atoms\nconst vm = new AgentVM(batteryAtoms)\n\n// The batteries are audited on import.\nconst logic = vm.Agent.storeVectorize({ text: 'Hello' }).as('vector')\n\nconst { result } = await vm.run(logic.toJSON(), {}, { capabilities: batteries })\n\nconsole.log(result)\n```\n\n### 4. Vector Search Performance\n\nThe built-in vector search is implemented with a highly optimized **[cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity) function** that operates directly on arrays. It is designed for serverless and edge environments where low-latency is critical. Benchmarks run on a 2023 M3 Max using `bun test` show the following performance characteristics:\n\n| Vector Count | Dimensions | Search Time |\n| :----------- | :--------- | :---------- |\n| 10,000       | 500        | ~15 ms      |\n| 10,000       | 1000       | ~22 ms      |\n| 100,000      | 500        | ~101 ms     |\n\nThese results demonstrate that the in-memory vector store is suitable for a wide range of real-time applications without requiring a dedicated vector database.\n\n> **cosine similarity** is the most popular algorithm for vector search, but there are many others (along with strategies for dealing with extremely large data-sets). For more information you can start with this Wikipedia article [Vector database](https://en.wikipedia.org/wiki/Vector_database).\n\n### 5. Structured Outputs\n\nYou can request structured JSON responses (e.g., JSON Schema) from compatible models using `responseFormat`:\n\n```typescript\nconst logic = vm.Agent.llmPredictBattery({\n  system: 'Extract data.',\n  user: 'John Doe, 30',\n  responseFormat: {\n    type: 'json_schema',\n    json_schema: {\n      name: 'person',\n      schema: {\n        type: 'object',\n        properties: {\n          name: { type: 'string' },\n          age: { type: 'number' },\n        },\n        required: ['name', 'age'],\n      },\n    },\n  },\n})\n```\n\n### 5. Troubleshooting\n\n- **Connection Error:** If you see an error like `Failed to connect to LM Studio`, make sure the LM Studio server is running on the default port (`1234`).\n- **No Models Found:** Ensure you have downloaded compatible GGUF models and they are loaded in LM Studio. The audit process will warn you if it cannot find suitable LLM or embedding models.\n\n## Self-Documentation for Agents\n\nThe VM can describe itself to an LLM, generating an [OpenAI-compatible Tool Schema](https://platform.openai.com/docs/guides/function-calling) for its registered atoms.\n\n```typescript\n// Get all tools\nconst tools = vm.getTools()\n\n// Get only flow control tools\nconst flowTools = vm.getTools('flow')\n\n// Get specific tools\nconst myTools = vm.getTools(['httpFetch', 'template'])\n```\n\n## Implementing Real-World Atoms\n\nTo enable custom capabilities like Database Access or Web Scraping, you inject them into the `VM.run` call.\n\n#### Example: Providing a Database\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\n\nconst vm = new AgentVM()\n\nconst capabilities = {\n  store: {\n    get: async (key) => {\n      // Connect to Redis/Postgres here\n      return await db.find(key)\n    },\n    set: async (key, value) => {\n      await db.insert(key, value)\n    },\n  },\n}\n\nawait vm.run(ast, args, { capabilities })\n```\n\n#### Example: Web Scraping Agent\n\nYou can expose a custom capability or use the standard `httpFetch` if trusted.\n\n```typescript\nconst capabilities = {\n  fetch: async (url, options) => {\n    // Implement secure fetch, possibly with proxy rotation or rate limiting\n    return fetch(url, options)\n  },\n}\n```\n\n## Custom Atoms\n\nYou can extend the runtime with your own atomic operations.\n\n```typescript\nimport { defineAtom, AgentVM, s, Agent } from 'tosijs-agent'\n\n// 1. Define the Atom\nconst myScraper = defineAtom(\n  'scrape', // OpCode\n  s.object({ url: s.string }), // Input Schema\n  s.string, // Output Schema\n  async ({ url }, ctx) => {\n    // Implementation logic\n    const res = await ctx.capabilities.fetch(url)\n    return await res.text()\n  },\n  { cost: 5 } // Gas cost\n)\n\n// 2. Register with Custom VM\nconst myVM = new AgentVM({ scrape: myScraper })\n\n// 3. Use in Builder (Types are inferred!)\n// The `vm.Agent` property is the recommended way to get a builder\n// that includes any custom atoms you have registered.\nconst builder = myVM.Agent\n\nconst logic = builder\n  .scrape({ url: 'https://example.com' })\n  .as('html')\n  .return(s.object({ html: s.string }))\n```\n\n## Control Flow\n\nAtoms like `if` and `while` evaluate expression strings. For security and predictability, these expressions are not granted access to the full agent state. Instead, you must use the `vars` parameter to explicitly pass in any state variables that the expression needs.\n\nThis mapping allows you to alias variables, making your expressions cleaner and more readable.\n\n### If / Else\n\n```typescript\nchain.if(\n  'p > 100 && itemsLeft > 0',\n  { p: 'product.price', itemsLeft: 'inventory.stockCount' }, // Map state to expression variables\n  (then) => then.varSet({ key: 'discount', value: true }),\n  (elseBranch) => elseBranch.varSet({ key: 'discount', value: false })\n)\n```\n\n### While Loop\n\n```typescript\n// The `vars` map works identically here, creating a scope for the condition.\n// Use ExprNode for arithmetic operations\nchain.while('n > 0', { n: 'counter' }, (loop) =>\n  loop.varSet({\n    key: 'counter',\n    value: {\n      $expr: 'binary',\n      op: '-',\n      left: { $expr: 'ident', name: 'counter' },\n      right: { $expr: 'literal', value: 1 },\n    },\n  })\n)\n```\n\n### Try / Catch\n\n```typescript\nchain.try({\n  try: (b) => b.httpFetch({ url: '...' }),\n  catch: (b) => b.varSet({ key: 'error', value: 'failed' }),\n})\n```\n\n## Editor Support\n\ntosijs-agent includes syntax highlighting for AsyncJS (the JavaScript subset used by `ajs` template literals).\n\n### Quick Install\n\n```bash\n# VS Code\nnpx ajs-install-vscode\n\n# Cursor\nnpx ajs-install-cursor\n```\n\nFeatures:\n\n- Syntax highlighting for `.ajs` files\n- Embedded highlighting inside `ajs`...`` template literals\n- Error highlighting for forbidden syntax (`new`, `class`, `async`, etc.)\n\n### Web Editors\n\n**Monaco:**\n\n```typescript\nimport { registerAjsLanguage } from 'tosijs-agent/editors/monaco'\nregisterAjsLanguage(monaco)\n```\n\n**CodeMirror 6:**\n\n```typescript\nimport { ajs } from 'tosijs-agent/editors/codemirror'\n// Use ajs() in your extensions\n```\n\n### Tree-sitter Editors (Zed, Nova, Helix)\n\nAssociate `.ajs` files with JavaScript syntax in your editor config. See [editors/README.md](./editors/README.md) for details.\n\n> **Note:** If you modify AsyncJS syntax (e.g., adding/removing forbidden keywords), update the grammar files in `editors/` to match. See [editors/README.md](./editors/README.md) for grammar locations.\n\n## Development\n\n### Testing\n\nThe test suite includes performance benchmarks for the in-memory vector search. These benchmarks can be sensitive to the performance of the host machine and may fail in slower CI/CD environments. To avoid this, you can skip the benchmark tests by setting the `AGENT99_TESTS_SKIP_BENCHMARKS` environment variable.\n\n```bash\n# Run tests\nbun test\n\n# Skip benchmark tests\nAGENT99_TESTS_SKIP_BENCHMARKS=1 bun test\n\n# Type check\nbun run typecheck\n\n# Build blueprint\nbun run make\n```\n",
    "title": "tosijs-agent",
    "filename": "README.md",
    "path": "README.md",
    "pin": "top"
  },
  {
    "text": "# AsyncJS (.ajs) - A Better JavaScript for AI Agents\n\nAsyncJS is a JavaScript subset designed for writing AI agent logic. It compiles to Agent99's secure JSON AST format, providing familiar syntax with cleaner semantics.\n\n> **For LLM Integration:** See [ASYNCJS_LLM_PROMPT.md](./ASYNCJS_LLM_PROMPT.md) for a system prompt optimized for code generation.\n\n## File Extension\n\nAsyncJS files use the `.ajs` extension to distinguish them from standard JavaScript:\n\n```\nmy-agent.ajs\nsearch-tool.ajs\n```\n\n## Why AsyncJS?\n\n| Problem with JavaScript       | AsyncJS Solution                                |\n| ----------------------------- | ----------------------------------------------- |\n| `async/await` boilerplate     | All calls are implicitly async                  |\n| Complex error handling        | Monadic error flow - errors propagate as values |\n| No built-in type safety       | Types through example values                    |\n| Security concerns with `eval` | Compiles to sandboxed VM                        |\n\n## Quick Example\n\n```javascript\n// search-agent.ajs\n\n/**\n * Search and summarize information about a topic\n * @param topic - The topic to research\n * @param maxResults - Maximum number of results\n */\nfunction searchAgent(topic: 'climate change', maxResults = 5) {\n  let results = search({ query: topic, limit: maxResults })\n\n  if (results.length == 0) {\n    return { summary: 'No results found', sources: [] }\n  }\n\n  let summary = llmPredict({\n    system: 'Summarize these search results concisely',\n    user: results,\n  })\n\n  return { summary, sources: results }\n}\n```\n\n## Core Differences from JavaScript\n\n### 1. Implicit Async\n\nAll function calls that invoke atoms are automatically awaited. No `async/await` keywords needed.\n\n```javascript\n// AsyncJS - clean and simple\nfunction agent(topic: 'machine learning') {\n  let results = search({ query: topic })\n  let summary = summarize({ text: results })\n  return { summary }\n}\n\n// Equivalent JavaScript would require:\n// async function agent(topic) {\n//   let results = await search({ query: topic })\n//   let summary = await summarize({ text: results })\n//   return { summary }\n// }\n```\n\n### 2. Types Through Example Values\n\nTypes are inferred from example values. The example shows both the type AND a realistic value:\n\n```javascript\nfunction greet(\n  name: 'Anne Example', // required string\n  age: 21, // required number\n  greeting = 'Hello' // optional string, defaults to 'Hello'\n) {\n  // ...\n}\n```\n\n- **Colon (`:`)** = required parameter, example shows the type\n- **Equals (`=`)** = optional parameter with default value\n\nThe example value IS the type. `age: 21` means \"required number\". `name: 'Anne'` means \"required string\".\n\n### 3. Monadic Error Flow\n\nErrors propagate automatically as values. When an atom fails, subsequent steps are skipped and the error flows through to the result.\n\n```javascript\nfunction pipeline(topic: 'quantum computing') {\n  let results = search({ query: topic }) // might fail\n  let summary = summarize({ text: results }) // skipped if search fails\n  let formatted = format({ content: summary }) // skipped if any above fails\n  return { formatted }\n}\n// If search() fails, the error flows through without executing subsequent steps\n// The result will have an `error` property containing the AgentError\n```\n\nThe VM returns a `RunResult` with both `result` and `error` fields:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  console.log('Failed:', error.message)\n  console.log('Failed at atom:', error.op)\n} else {\n  console.log('Success:', result)\n}\n```\n\nUse `try/catch` to recover from errors:\n\n```javascript\nfunction resilientPipeline(topic: 'neural networks') {\n  let data = null\n  try {\n    data = fetchData({ topic })\n  } catch (e) {\n    data = fallbackData({ topic })\n  }\n  return { data }\n}\n```\n\n### 4. Function Introspection\n\nEvery function has a `.signature` property for self-documentation:\n\n```javascript\n/**\n * Search the knowledge base\n * @param query - The search query\n * @param limit - Max results to return\n */\nfunction search(\n  query: 'example query',\n  limit = 10\n) -> [{ title: 'Example Title', url: 'https://example.com' }] {\n  // implementation\n}\n\n// Automatically gets:\nsearch.signature = {\n  name: 'search',\n  description: 'Search the knowledge base',\n  parameters: {\n    query: { type: 'string', required: true, description: 'The search query' },\n    limit: { type: 'number', required: false, default: 10, description: 'Max results to return' }\n  },\n  returns: { type: 'array', items: { type: 'object', shape: { title: 'string', url: 'string' } } }\n}\n```\n\n## Type System Reference\n\n### Parameter Types\n\n| Syntax                  | Meaning          | Example                          |\n| ----------------------- | ---------------- | -------------------------------- |\n| `name: 'Anne'`          | Required string  | The example value shows the type |\n| `age: 21`               | Required number  |                                  |\n| `active: true`          | Required boolean |                                  |\n| `tags: ['a', 'b']`      | Required array   |                                  |\n| `user: { name: 'Bob' }` | Required object  |                                  |\n| `limit = 10`            | Optional number  | Defaults to 10                   |\n| `query = 'default'`     | Optional string  | Defaults to 'default'            |\n\n### Destructured Parameter Defaults\n\nAsyncJS supports default values in destructured object parameters. Unlike JavaScript/TypeScript where destructuring defaults can be tricky, AsyncJS makes them work reliably:\n\n```javascript\nfunction calculate({ a = 10, b = 5 }) {\n  return { sum: a + b, product: a * b }\n}\n\n// Called with no arguments - uses defaults\ncalculate({})  // { sum: 15, product: 50 }\n\n// Called with partial arguments - missing ones use defaults\ncalculate({ a: 20 })  // { sum: 25, product: 100 }\n\n// Called with all arguments - no defaults used\ncalculate({ a: 3, b: 7 })  // { sum: 10, product: 21 }\n```\n\nThis works seamlessly with type annotations too:\n\n```javascript\nfunction greet({ name: 'World', greeting = 'Hello' }) {\n  return { message: `${greeting}, ${name}!` }\n}\n\ngreet({})  // { message: \"Hello, World!\" }\ngreet({ name: 'Alice' })  // { message: \"Hello, Alice!\" }\ngreet({ greeting: 'Hi' })  // { message: \"Hi, World!\" }\n```\n\n### Return Types\n\nReturn types can be specified with arrow syntax:\n\n```javascript\nfunction search(query: 'search term') -> { results: [], count: 0 } {\n  // Must return object with results array and count number\n}\n```\n\nOr inferred from the return statement:\n\n```javascript\nfunction search(query: 'search term') {\n  return { results: [], count: 0 } // Return type inferred\n}\n```\n\n## Supported Constructs\n\n### Variables\n\n```javascript\nlet x = 5 // Variable declaration\nx = 10 // Assignment\nlet { a, b } = obj // Destructuring (limited)\n```\n\n### Control Flow\n\n```javascript\n// Conditionals\nif (condition) {\n  // ...\n} else {\n  // ...\n}\n\n// Loops\nwhile (condition) {\n  // ...\n}\n\nfor (const item of items) {\n  // Becomes a map operation\n}\n\n// Error handling\ntry {\n  // ...\n} catch (e) {\n  // ...\n}\n```\n\n### Expressions\n\n```javascript\n// Arithmetic\na + b, a - b, a * b, a / b, a % b\n\n// Comparison\na == b, a != b, a < b, a > b, a <= b, a >= b\n\n// Logical\na && b, a || b, !a\n\n// Member access\nobj.property\nobj.nested.property\narr[0]\n\n// Optional chaining (safe access)\nobj?.property\nobj?.nested?.value\narr?.[0]\n\n// Template literals\n`Hello ${name}!`\n\n// Function calls\natomName({ param1: value1, param2: value2 })\n```\n\n### Built-in Objects\n\nAsyncJS provides safe implementations of common JavaScript built-in objects:\n\n#### Math\n\nAll standard Math methods and constants are available:\n\n```javascript\nlet floor = Math.floor(3.7) // 3\nlet ceil = Math.ceil(3.2) // 4\nlet abs = Math.abs(-5) // 5\nlet max = Math.max(1, 5, 3) // 5\nlet sqrt = Math.sqrt(16) // 4\nlet pi = Math.PI // 3.14159...\nlet random = Math.random() // Cryptographically secure when available\n```\n\n**Note:** `Math.random()` uses `crypto.getRandomValues()` when available for cryptographically secure random numbers.\n\n#### JSON\n\n```javascript\nlet obj = { name: 'test', value: 42 }\nlet str = JSON.stringify(obj) // '{\"name\":\"test\",\"value\":42}'\nlet parsed = JSON.parse(str) // { name: 'test', value: 42 }\n```\n\n#### Array Static Methods\n\n```javascript\nlet isArr = Array.isArray([1, 2, 3]) // true\nlet arr = Array.from([1, 2, 3]) // Creates new array\nlet created = Array.of(1, 2, 3) // [1, 2, 3]\n```\n\n#### Object Static Methods\n\n```javascript\nlet obj = { a: 1, b: 2, c: 3 }\nlet keys = Object.keys(obj) // ['a', 'b', 'c']\nlet values = Object.values(obj) // [1, 2, 3]\nlet entries = Object.entries(obj) // [['a',1], ['b',2], ['c',3]]\n```\n\n#### Number Static Methods\n\n```javascript\nlet isInt = Number.isInteger(5) // true\nlet isNan = Number.isNaN(NaN) // true\nlet max = Number.MAX_SAFE_INTEGER // 9007199254740991\n```\n\n#### Global Functions\n\n```javascript\nlet n = parseInt('42') // 42\nlet f = parseFloat('3.14') // 3.14\nlet encoded = encodeURIComponent('hello world') // 'hello%20world'\n```\n\n#### String Instance Methods\n\n```javascript\nlet str = 'hello world'\nlet upper = str.toUpperCase() // 'HELLO WORLD'\nlet parts = str.split(' ') // ['hello', 'world']\nlet trimmed = '  padded  '.trim() // 'padded'\nlet replaced = str.replace('world', 'there') // 'hello there'\n```\n\n#### Array Instance Methods\n\n```javascript\nlet arr = [3, 1, 4, 1, 5]\nlet joined = arr.join('-') // '3-1-4-1-5'\nlet has = arr.includes(4) // true\nlet idx = arr.indexOf(1) // 1\nlet sliced = arr.slice(1, 3) // [1, 4]\n```\n\n### Set and Date Builtins\n\nAsyncJS provides `Set()` and `Date()` as factory functions - no `new` keyword needed.\n\n#### Set\n\nCreate sets with `Set([items])`. Sets have both mutable operations (modify in place) and immutable set algebra (return new sets):\n\n```javascript\n// Create a Set\nlet tags = Set(['javascript', 'typescript', 'rust'])\nlet empty = Set()\n\n// Mutable operations (modify the set, return this for chaining)\ntags.add('go') // Add item\ntags.remove('rust') // Remove item\ntags.clear() // Remove all items\n\n// Query operations\nlet has = tags.has('typescript') // true/false\nlet count = tags.size // Number of items\nlet arr = tags.toArray() // Convert to array\n\n// Immutable set algebra (return NEW sets)\nlet a = Set([1, 2, 3])\nlet b = Set([2, 3, 4])\n\nlet union = a.union(b) // Set([1, 2, 3, 4])\nlet inter = a.intersection(b) // Set([2, 3])\nlet diff = a.diff(b) // Set([1]) - items in a but not b\n```\n\n#### Date\n\nCreate dates with `Date()` or `Date(initializer)`. Date objects are **immutable** - methods like `add()` return new Date objects:\n\n```javascript\n// Create a Date\nlet now = Date() // Current date/time\nlet specific = Date('2024-06-15') // From ISO string\nlet fromTs = Date(1718409600000) // From timestamp\n\n// Static methods\nlet timestamp = Date.now() // Current timestamp (number)\nlet parsed = Date.parse('2024-06-15T10:30:00Z') // Parse to Date object\n\n// Component accessors (read-only)\nlet d = Date('2024-06-15T10:30:45Z')\nd.year // 2024\nd.month // 6 (1-12, not 0-11 like JS!)\nd.day // 15\nd.hours // 10\nd.minutes // 30\nd.seconds // 45\nd.timestamp // Unix timestamp in ms\nd.value // ISO string\n\n// Immutable arithmetic (returns NEW Date)\nlet later = d.add({ days: 5, hours: 3 })\nlet earlier = d.add({ months: -1 })\n// Supported: years, months, days, hours, minutes, seconds\n\n// Comparison\nlet before = d.isBefore(later) // true\nlet after = later.isAfter(d) // true\nlet diffDays = d.diff(later, 'days') // -5\n\n// Formatting\nlet formatted = d.format('date') // '2024-06-15'\nlet iso = d.format('iso') // '2024-06-15T10:30:45.000Z'\nlet time = d.format('time') // '10:30:45'\n```\n\n**Note:** Unlike JavaScript's `Date`, months are 1-12 (not 0-11), and all methods are immutable.\n\n#### Serialization\n\nSets and Dates serialize cleanly to JSON:\n\n```javascript\nlet result = {\n  tags: Set(['a', 'b', 'c']),\n  created: Date('2024-06-15'),\n}\n// JSON.stringify(result) produces:\n// { \"tags\": [\"a\", \"b\", \"c\"], \"created\": \"2024-06-15T00:00:00.000Z\" }\n```\n\n- **Sets** serialize to arrays\n- **Dates** serialize to ISO 8601 strings\n\n### Schema Filtering\n\nThe `filter()` builtin validates and strips extra properties from objects based on a schema:\n\n```javascript\n// Strip extra properties from an object\nlet raw = { name: 'Alice', age: 30, secret: 'password', extra: 123 }\nlet clean = filter(raw, { name: 'string', age: 0 })\n// clean = { name: 'Alice', age: 30 }\n\n// Works with nested objects\nlet data = {\n  user: { name: 'Bob', age: 25, ssn: '123-45-6789' },\n  tags: ['a', 'b'],\n  internal: 'hidden',\n}\nlet filtered = filter(data, {\n  user: { name: 'string', age: 0 },\n  tags: ['string'],\n})\n// filtered = { user: { name: 'Bob', age: 25 }, tags: ['a', 'b'] }\n\n// Throws on validation failure (missing required fields)\nlet bad = filter({ name: 'Alice' }, { name: 'string', age: 0 })\n// Error: Missing age\n```\n\n**Use cases:**\n\n- Sanitize LLM outputs - strip unexpected properties from JSON responses\n- API input validation - accept only the fields you expect\n- Data projection - reduce objects to a known shape\n\n**Note:** Return values are automatically filtered when a return type is declared. This makes return types act as projections:\n\n```javascript\nfunction getUser(id: 'user-123') -> { name: 'string', email: 'string' } {\n  let user = fetchUser({ id })  // might return { name, email, password, ... }\n  return { user }               // password automatically stripped\n}\n```\n\n### Array Methods with Lambdas\n\n```javascript\n// Map - transform each element\nitems.map((x) => x * 2)\nitems.map((x) => {\n  let doubled = x * 2\n  return doubled\n})\n\n// Filter - keep elements matching condition\nitems.filter((x) => x > 5)\nitems.filter((x) => x % 2 == 0)\n\n// Find - get first matching element\nitems.find((x) => x.id == targetId)\nusers.find((u) => u.age >= 18)\n\n// Reduce - accumulate to single value\nitems.reduce((acc, x) => acc + x, 0)\nitems.reduce((sum, item) => sum + item.price, 0)\n\n// Other array operations\nitems.push(newItem) // Add to array\nstr.split(',') // Split string to array\nparts.join('-') // Join array to string\n```\n\nLambdas support closures - they can access variables from the outer scope:\n\n```javascript\nfunction processItems({ items, threshold }) {\n  let above = items.filter((x) => x >= threshold) // threshold from outer scope\n  let scaled = above.map((x) => x * threshold) // still accessible\n  return { scaled }\n}\n```\n\n## Unsupported Constructs\n\nThese JavaScript features are intentionally not supported:\n\n| Feature            | Reason                       | Alternative         |\n| ------------------ | ---------------------------- | ------------------- |\n| `class`            | Use functional composition   | Plain functions     |\n| `this`             | Implicit state is confusing  | Explicit parameters |\n| `new`              | Classes not supported        | Factory functions   |\n| `import/require`   | Atoms must be registered     | Register with VM    |\n| `async/await`      | Implicit async               | Just call functions |\n| `yield/generators` | Complex control flow         | Use `map`/`while`   |\n| `eval`             | Security (though VM is safe) | Use transpiler      |\n| `with`             | Deprecated                   | Explicit references |\n| `var`              | Scoping issues               | Use `let`           |\n\n## API Usage\n\n### transpile()\n\nFull transpilation with signature and metadata:\n\n```typescript\nimport { transpile } from 'tosijs-agent'\n\nconst { ast, signature, warnings } = transpile(`\n  function greet(name: 'World') {\n    let msg = template({ tmpl: 'Hello {{name}}!', vars: { name } })\n    return { msg }\n  }\n`)\n\nconsole.log(signature.parameters.name.type) // 'string'\nconsole.log(signature.parameters.name.required) // true\n```\n\n### ajs()\n\nConvenience function returning just the AST (works as both a function and tagged template literal):\n\n```typescript\nimport { ajs } from 'tosijs-agent'\n\nconst ast = ajs(`\n  function add(a: 5, b: 3) {\n    let sum = a + b\n    return { sum }\n  }\n`)\n\n// Execute with VM\nconst vm = new AgentVM()\nconst result = await vm.run(ast, { a: 5, b: 3 })\nconsole.log(result.result.sum) // 8\n```\n\n### agent\\`\\`\n\nTagged template for inline definitions:\n\n```typescript\nimport { agent } from 'tosijs-agent'\n\nconst searchAST = agent`\n  function search(query: 'example search', limit = 10) {\n    let results = storeSearch({ query, limit })\n    return { results }\n  }\n`\n```\n\n### getToolDefinitions()\n\nGenerate OpenAI-compatible tool schemas for LLM integration:\n\n```typescript\nimport { getToolDefinitions, transpile } from 'tosijs-agent'\n\nconst { signature } = transpile(source)\nconst tools = getToolDefinitions([signature])\n\n// Returns format compatible with OpenAI/Anthropic tool calling:\n// [{\n//   type: 'function',\n//   function: {\n//     name: 'search',\n//     description: 'Search the knowledge base',\n//     parameters: { type: 'object', properties: {...}, required: [...] }\n//   }\n// }]\n```\n\n## Error Handling\n\n### Monadic Error Flow\n\nAgent99 uses monadic error flow - when an atom fails, the error becomes a value that propagates through the pipeline:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  // error is an AgentError with:\n  // - message: string - the error message\n  // - op: string - the atom that failed\n  // - cause?: Error - the original exception\n  console.log(`Error in ${error.op}: ${error.message}`)\n} else {\n  // Success - use result\n  console.log(result)\n}\n```\n\n### Checking for Errors\n\n```typescript\nimport { isAgentError } from 'tosijs-agent'\n\nconst { result, error } = await vm.run(ast, args)\n\nif (isAgentError(result)) {\n  // result itself is the error (when error occurs before return)\n}\n```\n\n### Recovery with try/catch\n\nUse `try/catch` in your AsyncJS code to handle errors gracefully:\n\n```javascript\nfunction resilientAgent({ query }) {\n  let result = null\n\n  try {\n    result = riskyOperation({ query })\n  } catch (e) {\n    // e contains the error message\n    result = safeDefault({ error: e })\n  }\n\n  return { result }\n}\n```\n\n### Triggering Errors with Error()\n\nUse the `Error()` built-in to trigger monadic error flow from your AsyncJS code:\n\n```javascript\nfunction validateInput({ value }) {\n  if (value < 0) {\n    Error('Value must be non-negative')\n    // Execution stops here - subsequent code is skipped\n  }\n  \n  return { validated: value }\n}\n```\n\nWhen `Error()` is called:\n- The error message is stored in the context\n- Subsequent operations are skipped (monadic error flow)\n- The error can be caught with `try/catch` or returned to the caller\n\n```javascript\nfunction safeDivide({ a, b }) {\n  if (b === 0) {\n    Error('Division by zero')\n  }\n  return { result: a / b }\n}\n\nfunction calculate({ x, y }) {\n  let result = null\n  \n  try {\n    result = safeDivide({ a: x, b: y })\n  } catch (e) {\n    result = { result: 0, error: e }\n  }\n  \n  return result\n}\n```\n\n### Why No `throw` Statement?\n\nAsyncJS intentionally does not support the `throw` statement. Instead, use `Error()`:\n\n```javascript\n// DON'T DO THIS - throw is not supported:\nif (invalid) {\n  throw new Error('Something went wrong')  // Transpiler error!\n}\n\n// DO THIS INSTEAD:\nif (invalid) {\n  Error('Something went wrong')  // Triggers monadic error flow\n}\n```\n\nThe `throw` keyword will show as an error in your editor (red underline) and the transpiler will provide a helpful error message pointing you to use `Error()` instead.\n\n## Gotchas and Common Pitfalls\n\n### Unavailable JavaScript Features\n\nThese common JavaScript APIs are **not available** in AsyncJS. The transpiler will catch these and provide helpful error messages:\n\n| Feature          | Error Message              | Alternative                            |\n| ---------------- | -------------------------- | -------------------------------------- |\n| `setTimeout`     | Use the `delay` atom       | `delay({ ms: 1000 })`                  |\n| `setInterval`    | Use while loops with delay | `while (cond) { delay({ ms: 1000 }) }` |\n| `fetch`          | Use the `httpFetch` atom   | `httpFetch({ url })`                   |\n| `RegExp`         | Use string methods         | `str.match()`, `str.replace()`         |\n| `Promise`        | Implicit async             | All calls are automatically awaited    |\n| `Map`            | Use plain objects          | `{ key: value }`                       |\n| `require/import` | Register atoms with VM     | `new AgentVM({ customAtom })`          |\n\n### The `new` Keyword\n\nThe `new` keyword is not supported. AsyncJS provides factory functions instead:\n\n```javascript\n// DON'T DO THIS - the transpiler catches these with helpful errors:\nlet date = new Date() // Error: Use Date() or Date('2024-01-15') instead\nlet set = new Set([1, 2]) // Error: Use Set([items]) instead\nlet arr = new Array(5) // Error: Use array literals like [1, 2, 3] instead\n\n// DO THIS INSTEAD - no 'new' needed:\nlet date = Date() // Current date/time\nlet date2 = Date('2024-06-15') // Specific date\nlet set = Set([1, 2, 3]) // Create a Set\nlet arr = [1, 2, 3, 4, 5] // Array literal\n```\n\nSee [Set and Date Builtins](#set-and-date-builtins) for full documentation.\n\n### No `this` or Classes\n\nAsyncJS is purely functional. There's no `this`, no classes, no prototypes:\n\n```javascript\n// DON'T DO THIS\nclass Agent {\n  constructor(name) {\n    this.name = name\n  }\n}\n\n// DO THIS INSTEAD\nfunction createAgent(name: 'Agent Smith') {\n  return { name }\n}\n```\n\n### Equality Semantics\n\nAsyncJS uses JavaScript's standard equality (`==` and `===`). There is no special deep equality:\n\n```javascript\nlet a = { x: 1 }\nlet b = { x: 1 }\nlet same = a == b // false (reference comparison)\n\n// For deep comparison, use JSON.stringify or write a comparison function\nlet equal = JSON.stringify(a) == JSON.stringify(b) // true\n```\n\n### Optional Chaining (`?.`)\n\nOptional chaining is fully supported for safe property access:\n\n```javascript\nlet x = obj?.nested?.value // Returns null if any step is null/undefined\nlet result = user?.profile?.name\n\n// Works with method calls too\nlet len = items?.length\nlet upper = str?.toUpperCase()\n```\n\n**Note:** Nullish coalescing (`??`) is not yet supported. Use explicit checks:\n\n```javascript\nlet x = obj?.nested?.value\nif (x == null) {\n  x = 'default'\n}\n```\n\n### Atom Calls vs Built-in Methods\n\nAtoms use object parameter syntax, while built-ins use normal function syntax:\n\n```javascript\n// Atom call - object parameter\nlet result = search({ query: 'hello', limit: 10 })\n\n// Built-in method - normal parameters\nlet floor = Math.floor(3.7)\nlet upper = str.toUpperCase()\n```\n\n### Async Is Implicit\n\nAll atom calls are automatically awaited. Don't use `async/await`:\n\n```javascript\n// DON'T DO THIS\nasync function search(query) {\n  let result = await fetch(query) // Error: async/await not supported\n}\n\n// DO THIS INSTEAD\nfunction search(query: 'https://api.example.com') {\n  let result = httpFetch({ url: query }) // Automatically awaited\n  return { result }\n}\n```\n\n### Error Propagation\n\nErrors propagate monadically - if one step fails, subsequent steps are skipped:\n\n```javascript\nfunction pipeline(input: 'raw data') {\n  let a = stepOne({ input }) // If this fails...\n  let b = stepTwo({ data: a }) // ...this is skipped\n  let c = stepThree({ data: b }) // ...and this too\n  return { c } // Result contains the error\n}\n```\n\nUse `try/catch` to recover from expected errors:\n\n```javascript\nfunction resilient(input: 'user input') {\n  let result = null\n  try {\n    result = riskyStep({ input })\n  } catch (e) {\n    result = fallback({ error: e })\n  }\n  return { result }\n}\n```\n\n### Fuel Limits\n\nAll operations consume fuel. Complex operations may hit limits:\n\n```javascript\n// This might run out of fuel for large arrays\nfunction processLarge({ items }) {\n  let mapped = items.map((x) => complexOperation({ x }))\n  return { mapped }\n}\n\n// Run with higher fuel limit\nconst result = await vm.run(ast, args, { fuel: 10000 })\n```\n\n## Security Model\n\nAsyncJS compiles to Agent99's JSON AST, which executes in a completely sandboxed VM:\n\n- **No file system access** - unless explicitly provided via atoms\n- **No network access** - unless explicitly provided via atoms\n- **No global state** - each execution is isolated\n- **Fuel-limited execution** - prevents infinite loops and runaway expressions\n- **Type-checked at runtime** - invalid operations fail safely\n- **Prototype access blocked** - `__proto__`, `constructor`, `prototype` are forbidden\n\nThe transpiler is permissive because security is enforced at the VM level, not the language level. Even if malicious code somehow made it through, the VM cannot execute dangerous operations unless atoms for those operations are registered.\n\n### Fuel System\n\nEvery operation consumes fuel. When fuel runs out, execution stops with an `Out of Fuel` error:\n\n```typescript\nconst result = await vm.run(ast, args, { fuel: 100 })\n// Limits total computation to prevent infinite loops\n```\n\nExpression evaluation also consumes fuel (0.01 per node), preventing deeply nested or recursive expressions from running unchecked.\n\n## Migration from TypedBuilder\n\nIf you have existing TypedBuilder code, here's how to convert:\n\n```typescript\n// Before: TypedBuilder\nconst ast = Agent.take()\n  .varsImport(['topic'])\n  .step({ op: 'search', query: 'topic', result: 'results' })\n  .if('results.length > 0', { results: 'results' }, (b) =>\n    b.step({ op: 'summarize', text: 'results', result: 'summary' })\n  )\n  .return({ properties: { results: {}, summary: {} } })\n  .toJSON()\n\n// After: AsyncJS\nconst ast = ajs(`\n  function searchAgent(topic: 'climate change') {\n    let results = search({ query: topic })\n    if (results.length > 0) {\n      let summary = summarize({ text: results })\n    }\n    return { results, summary }\n  }\n`)\n```\n\n## Best Practices\n\n1. **Use descriptive JSDoc comments** - They become part of the function signature for LLM agents\n2. **Prefer explicit types** - Even though inference works, explicit types document intent\n3. **Keep functions small** - Each function should do one thing\n4. **Use meaningful variable names** - The VM state is inspectable during debugging\n5. **Return structured objects** - Makes output types clear and composable\n6. **Handle errors appropriately** - Use try/catch for expected failures, let others propagate\n7. **Set appropriate fuel limits** - Balance between allowing complex operations and preventing abuse\n",
    "title": "AsyncJS (.ajs) - A Better JavaScript for AI Agents",
    "filename": "ASYNCJS.md",
    "path": "ASYNCJS.md"
  },
  {
    "text": "# AsyncJS LLM System Prompt\n\n> **Maintenance Note:** This prompt must be updated when [ASYNCJS.md](./ASYNCJS.md) changes.\n> Key areas to sync: type syntax, built-ins (Set/Date), control flow, and forbidden constructs.\n\nUse this system prompt when asking an LLM to generate AsyncJS code.\n\n---\n\n## System Prompt\n\n````\nYou are an expert code generator for **AsyncJS**, a specialized subset of JavaScript for AI Agents.\nAsyncJS looks like JavaScript but has strict differences. You must adhere to these rules:\n\n### 1. SYNTAX & TYPES\n- **Types by Example:** Do NOT use TypeScript types (`x: string`). Use \"Example Types\" where the value implies the type.\n  - WRONG: `function search(query: string, limit?: number)`\n  - RIGHT: `function search(query: 'search term', limit = 10)`\n  - `name: 'value'` means REQUIRED. `name = 'value'` means OPTIONAL.\n- **No Classes:** Do NOT use `class`, `new`, `this`, or `prototype`.\n- **No Async/Await:** Do NOT use `async` or `await`. All functions are implicitly asynchronous.\n  - WRONG: `let x = await fetch(...)`\n  - RIGHT: `let x = httpFetch({ url: '...' })`\n\n### 2. BUILT-INS & FACTORIES\n- **No `new` Keyword:** Never use `new`. Use factory functions.\n  - WRONG: `new Date()`, `new Set()`, `new Array()`\n  - RIGHT: `Date()`, `Set([1,2])`, `['a','b']`\n- **Date Objects:** `Date()` returns an **immutable** object.\n  - Months are 1-indexed (1=Jan, not 0=Jan).\n  - Methods like `.add({ days: 5 })` return a NEW Date object.\n  - Access components: `.year`, `.month`, `.day`, `.hours`, `.minutes`, `.seconds`\n  - Format: `.format('date')`, `.format('iso')`, `.format('YYYY-MM-DD')`\n- **Set Objects:** `Set([items])` returns an object with:\n  - Mutable: `.add(x)`, `.remove(x)`, `.clear()`\n  - Immutable algebra: `.union(other)`, `.intersection(other)`, `.diff(other)` - return NEW Sets\n  - Query: `.has(x)`, `.size`, `.toArray()`\n- **Optional Chaining:** Use `?.` for safe property access: `obj?.nested?.value`\n- **Schema Filtering:** `filter(data, schema)` strips extra properties:\n  - `filter({ a: 1, b: 2, extra: 3 }, { a: 0, b: 0 })` returns `{ a: 1, b: 2 }`\n  - Useful for sanitizing LLM outputs or API responses\n\n### 3. ATOMS VS. BUILT-INS\n- **Atoms (External Tools):** ALWAYS accept a single object argument.\n  - Pattern: `atomName({ param: value })`\n  - Examples: `search({ query: topic })`, `llmPredict({ system: '...', user: '...' })`\n- **Built-ins (Math, JSON, String, Array):** Use standard JS syntax.\n  - `Math.max(1, 2)`, `JSON.parse(str)`, `str.split(',')`, `arr.map(x => x * 2)`\n\n### 4. ERROR HANDLING\n- Errors propagate automatically (Monadic flow). If one step fails, subsequent steps are skipped.\n- Only use `try/catch` if you need to recover from a failure and continue.\n\n### 5. FORBIDDEN CONSTRUCTS\nThese will cause transpile errors:\n- `async`, `await` - not needed, all calls are implicitly async\n- `new` - use factory functions instead\n- `class`, `this` - use plain functions and objects\n- `var` - use `let` instead\n- `import`, `require` - atoms must be registered with the VM\n- `console.log` - use trace capabilities if needed\n\n### EXAMPLE\n**User Task:** Create an agent that searches for a topic and summarizes it.\n\n**AsyncJS Response:**\n```javascript\n/**\n * Search and summarize a topic\n * @param topic - The topic to research\n */\nfunction researchAgent(topic: 'quantum computing') {\n  // 1. Implicit async call to atom\n  let searchResults = search({ query: topic, limit: 5 })\n\n  // 2. Standard JS logic with optional chaining\n  if (searchResults?.length == 0) {\n    return { error: 'No results found' }\n  }\n\n  // 3. Atom call for summarization\n  let summary = summarize({\n    text: JSON.stringify(searchResults),\n    length: 'short'\n  })\n\n  // 4. Factory usage (no 'new')\n  let timestamp = Date()\n  let tags = Set(['ai', 'research'])\n  tags.add(topic)\n\n  return { summary, timestamp, tags }\n}\n````\n\n```\n\n---\n\n## Self-Correction Loop\n\nWhen testing with local LLMs, implement error feedback:\n\n1. Run the LLM with this prompt\n2. If output contains `async`, `await`, `new`, `class`, or `this`, feed back:\n   > \"Error: You used '[keyword]'. AsyncJS forbids '[keyword]'. [Alternative].\"\n3. The model typically fixes it on the second attempt\n\nExample corrections:\n- `new Date()` → \"Use `Date()` factory function instead\"\n- `await fetch()` → \"Remove `await`, use `httpFetch({ url })` - all calls are implicitly async\"\n- `class Agent` → \"Use plain functions, AsyncJS is purely functional\"\n\n---\n\n## Compact Version (for context-limited models)\n\n```\n\nYou generate AsyncJS code. Rules:\n\n1. Types by example: `fn(name: 'string', count = 10)` - colon=required, equals=optional\n2. NO: async/await, new, class, this, var, import\n3. Atoms use object args: `search({ query: x })`. Built-ins normal: `Math.max(1,2)`\n4. Factories: `Date()`, `Set([1,2])` - no `new` keyword\n5. Date is immutable, months 1-12. Set has .add/.remove (mutable) and .union/.diff (immutable)\n6. Use `?.` for optional chaining: `obj?.prop?.value`\n7. Use `filter(data, schema)` to strip extra properties from objects\n\n```\n\n```\n",
    "title": "AsyncJS LLM System Prompt",
    "filename": "ASYNCJS_LLM_PROMPT.md",
    "path": "ASYNCJS_LLM_PROMPT.md"
  },
  {
    "text": "# Context: Working with `tosijs-schema`\n\nYou are an expert in `tosijs-schema`, a lightweight, schema-first, LLM-native replacement for Zod. Use this guide to generate correct code, migrate from Zod, and understand the library's design philosophy.\n\n## 1. Core Philosophy & Design\n\n- **Schema-First:** The primary artifact is a standard JSON Schema object. `tosijs-schema` is a fluent API to generate these schemas.\n- **LLM-Native:** The generated schemas are optimized for LLM consumption (cleaner, flatter, fewer tokens than Zod-to-JSON-Schema adapters).\n- **Strict by Default:** Objects automatically set `additionalProperties: false` and mark all keys as `required` to satisfy OpenAI Structured Output requirements out-of-the-box.\n- **Performance:** Uses \"Ghost Constraints\" for expensive checks (like `maxProperties` on large objects) and a \"prime-jump\" strategy for validating large arrays in O(1) time.\n- **Validation Separation:** Separates \"Is this valid?\" (fast, boolean return) from \"Why is it invalid?\" (detailed debugging).\n\n## 2. Basic Setup & Syntax\n\n### Imports\n\n```typescript\nimport { s, type Infer } from 'tosijs-schema'\n```\n\n### Defining Schemas\n\nUse the `s` proxy to define schemas. The syntax is property-based and chainable.\n\n```typescript\nconst UserSchema = s.object({\n  id: s.string.uuid, // Format shorthand\n  username: s.string.min(3).max(20), // Chainable constraints\n  email: s.email, // First-class email type (no .string wrapper needed)\n  age: s.integer.min(0).optional, // Optional integer\n  tags: s.array(s.string).min(1), // Array with constraints\n  role: s.enum(['admin', 'user']), // Enums\n  meta: s.record(s.string), // Record/Dictionary\n})\n```\n\n### Type Inference\n\nInference works similarly to Zod but exports `Infer` directly.\n\n```typescript\ntype User = Infer<typeof UserSchema>\n```\n\n### Accessing the JSON Schema\n\nYou can access the raw JSON schema object via the `.schema` property.\n\n```typescript\nconsole.log(UserSchema.schema)\n// Outputs standard JSON Schema object: { type: \"object\", properties: { ... } }\n```\n\n## 3. Validation API\n\n**Crucial Difference from Zod:**\n\n- `tosijs-schema` validation is optimized for speed and returns a **boolean** by default.\n- It does **not** throw errors or return a parsed object like Zod's `.parse()`.\n\n```typescript\nconst data = { ... };\n\n// Fast validation (returns true/false)\nif (UserSchema.validate(data)) {\n  // logic here\n} else {\n  // Handle invalid data\n}\n```\n\n## 4. Migration Guide (Zod vs. tosijs-schema)\n\n| Feature         | Zod (`z`)                  | tosijs-schema (`s`)                      |\n| --------------- | -------------------------- | ---------------------------------------- |\n| **String**      | `z.string()`               | `s.string`                               |\n| **Email**       | `z.string().email()`       | `s.email` (First-class citizen)          |\n| **UUID**        | `z.string().uuid()`        | `s.string.uuid` or `s.uuid`              |\n| **Optional**    | `schema.optional()`        | `schema.optional` (Property, not method) |\n| **Objects**     | `z.object({...})`          | `s.object({...})`                        |\n| **Strict Mode** | `z.object({...}).strict()` | **Default** (No method needed)           |\n| **Arrays**      | `z.array(schema)`          | `s.array(schema)`                        |\n| **Enums**       | `z.enum(['a', 'b'])`       | `s.enum(['a', 'b'])`                     |\n| **Unions**      | `z.union([a, b])`          | `s.union([a, b])`                        |\n| **Inference**   | `z.infer<typeof T>`        | `Infer<typeof T>`                        |\n| **Metadata**    | `.describe(\"...\")`         | `.describe(\"...\")` / `.title(\"...\")`     |\n\n## 5. Monadic Pipelines (`M`)\n\n`tosijs-schema` includes a \"Railway Oriented Programming\" module for building type-safe tool chains. This is especially useful for **AI Agents**, ensuring that hallucinations or bad data are caught immediately at the source (Input vs Output) rather than cascading.\n\n### 1. Guarded Functions (`M.func`)\n\nCreate functions that enforce schemas on both input and output.\n\n```typescript\nimport { M, s } from 'tosijs-schema'\n\n// M.func(InputSchema, OutputSchema, Implementation)\nconst getSize = M.func(s.string, s.number, (str) => {\n  return str.length\n})\n\n// Usage:\nconst len = getSize('hello') // Returns 5\n// getSize(123) // Throws SchemaError (Input mismatch)\n```\n\n### 2. Execution Contexts (`new M`)\n\nChain multiple functions together. The execution context handles error propagation automatically.\n\n```typescript\nconst pipeline = new M({\n  getSize,\n  isEven: M.func(s.number, s.boolean, (n) => n % 2 === 0),\n})\n\nconst result = pipeline\n  .getSize('hello') // Output: 5\n  .isEven() // Input: 5 -> Output: false\n  .result() // Returns false | Error\n\n// If any step fails schema validation, .result() returns the specific error.\n```\n\n## 6. Advanced Features\n\n### Ghost Constraints\n\nConstraints that are computationally expensive (O(N)) are documented in the schema but skipped by the runtime validator for performance (O(1)).\n\n- **Example:** `.max(n)` on Objects/Records.\n- `minProperties` is strictly validated.\n- `maxProperties` is a \"Ghost\" constraint (documentation only).\n\n### Metadata & LLM Optimization\n\nUse metadata methods to enrich schemas for LLMs or OpenAPI docs without affecting runtime validation.\n\n```typescript\nconst ApiKey = s.string\n  .min(32)\n  .describe(\"The user's secret API key\") // standard JSON schema \"description\"\n  .title('API Key')\n  .default('sk-...')\n```\n\n### Date Handling\n\n`tosijs-schema` treats dates as strings with format validation, aligning with JSON transport.\n\n```typescript\nconst Timestamp = s.string.datetime // Validates ISO string format\n```\n\n## 6. Common Patterns & Gotchas\n\n1. **Chaining Order:** Primitives (like `s.string`) start the chain. Constraints (`.min()`) and metadata (`.describe()`) follow. The `.optional` flag can be placed anywhere in the chain but usually goes last for readability.\n2. **No Transformers:** Unlike Zod, `tosijs` is a pure validation/schema library. It does not \"transform\" data (e.g., string to number coercion) during validation.\n3. **Strict Objects:** Remember that `s.object()` disallows unknown keys by default. If you need a flexible object, use `s.record()` or explicitly allow additional properties if the API supports it (though strict is preferred for LLM outputs).\n4. **Tuples:** Use `s.tuple([s.string, s.number])` for fixed-length arrays.\n\n## 7. Example: LLM Structured Output\n\nWhen defining a response format for an LLM:\n\n```typescript\nconst ResponseSchema = s.object({\n  reasoning: s.string.describe('Step-by-step thinking process'),\n  final_answer: s.string.describe('The concise final answer'),\n  confidence: s.number\n    .min(0)\n    .max(1)\n    .describe('Confidence score between 0 and 1'),\n})\n\n// Pass to LLM\nconst jsonSchema = ResponseSchema.schema\n```\n",
    "title": "Context: Working with tosijs-schema",
    "filename": "CTX_TOSIJS_SCHEMA.md",
    "path": "CTX_TOSIJS_SCHEMA.md"
  },
  {
    "text": "# tosijs-agent Technical Context\n\n**Note:** This document provides a technical deep-dive into tosijs-agent's architecture and security model. For a general overview, installation instructions, and usage examples, please refer to the main [README.md](./README.md).\n\n**tosijs-agent** is a secure, environment-agnostic runtime for executing AI agents and logic chains defined as JSON ASTs.\n\n**Bundle Size:** ~17KB gzipped. Expressions are evaluated via lightweight AST nodes at runtime, eliminating the need for a parser library (the previous JSEP-based approach was ~50KB gzipped).\n\n## 1. Architecture\n\n### The Builder (`TypedBuilder`)\n\nA fluent TypeScript API that generates a portable JSON AST. It uses a `Proxy` to dynamically infer methods from the registered Atoms, providing a strongly-typed developer experience.\n\nIt is important to understand that the builder is only for constructing the AST; it does not contain any of the actual implementation logic for the atoms. All execution is handled by the Runtime.\n\n**Usage Pattern:**\n\n- All logic chains **must** start with `Agent.take()` to define the input schema for the agent.\n- Subsequent atom calls are chained together fluently (e.g., `.varSet(...)`, `.httpFetch(...)`). This creates an implicit `seq` (sequence) of operations.\n- The chain is terminated by calling `.toJSON()` to produce the serializable AST.\n\nYou can access the builder via `Agent` (for core atoms) or `vm.Agent` (the recommended way to access both core and any custom atoms registered with the VM instance).\n\n```typescript\nimport { Agent, s, AgentVM } from 'tosijs-agent'\n\n// Global Builder (Core Atoms)\nconst logic = Agent.take(s.object({ input: s.string }))\n  .varSet({ key: 'sum', value: { $expr: 'binary', op: '+', left: { $expr: 'literal', value: 1 }, right: { $expr: 'literal', value: 1 } } })\n\n// VM Builder (Custom Atoms)\nconst vm = new AgentVM({ myAtom })\nconst customLogic = vm.Agent\n  .myAtom({ ... })\n  .varSet({ ... })\n```\n\n### The Runtime (`AgentVM`)\n\nA stateless Virtual Machine that executes the AST. The runtime contains all the actual implementation logic for the atoms.\n\n- **Sandboxed:** No `eval()`. Math/Logic is evaluated safely via AST expression nodes.\n- **Resource Limited:** Enforces `fuel` (gas) limits and execution timeouts per atom.\n- **Capability-Based:** All IO (Network, DB, AI) must be injected via `capabilities` object.\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\nconst vm = new AgentVM()\nconst { result, fuelUsed } = await vm.run(ast, args, {\n  capabilities,\n  fuel: 1000,\n})\n```\n\n## 2. Expression Syntax (ExprNode)\n\nExpressions use AST expression nodes (`$expr`) for safe, sandboxed evaluation. Conditions in `if` and `while` atoms use expression strings that are parsed at transpile time.\n\nFor security, expressions are sandboxed and cannot directly access the agent's state. Use the `vars` parameter to explicitly pass variables from state into the expression scope.\n\n### ExprNode Types\n\n- **literal:** `{ $expr: 'literal', value: 5 }` - A constant value\n- **ident:** `{ $expr: 'ident', name: 'x' }` - A variable reference\n- **member:** `{ $expr: 'member', object: {...}, property: 'foo' }` - Property access\n- **binary:** `{ $expr: 'binary', op: '+', left: {...}, right: {...} }` - Binary operations\n- **unary:** `{ $expr: 'unary', op: '-', argument: {...} }` - Unary operations\n- **conditional:** `{ $expr: 'conditional', test: {...}, consequent: {...}, alternate: {...} }` - Ternary\n\n### Supported Operators\n\n- **Binary ops:** `+`, `-`, `*`, `/`, `%`, `**`\n- **Logic:** `&&`, `||`\n- **Comparison:** `==`, `!=`, `>`, `<`, `>=`, `<=`\n- **Member Access:** `obj.prop`, `arr[0]`\n\n### Security\n\n- **Forbidden:** Function calls, `new`, `this`, global access\n- **Blocked:** Prototype access (`__proto__`, `constructor`)\n\n### Fuel Consumption\n\nEach expression node evaluation consumes **0.01 fuel**. This prevents deeply nested or recursive expressions from running unchecked. A simple `a + b` costs ~0.03 fuel (two identifiers + one binary op), while complex nested expressions accumulate cost proportionally.\n\n## 3. Security Model\n\n- **Capabilities:** The VM has no default IO. You must provide `fetch`, `store`, etc., allowing you to mock, proxy, or limit access.\n- **Fuel:** Every atom consumes \"fuel\". Execution aborts if fuel reaches 0.\n- **Execution Timeout:** The VM enforces a global timeout based on fuel budget (see below).\n- **Atom Timeouts:** Individual atoms have a default timeout (1s) to prevent hangs.\n- **State Isolation:** Each run creates a fresh context. Scopes (loops/maps) use prototype inheritance to isolate local variables.\n\n### Execution Timeout\n\nThe VM enforces a hard timeout on execution to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n**How it works:**\n\n1. **Automatic Safety Net:** By default, timeout = `fuel × 10ms`. So 1000 fuel = 10 seconds. _For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n2. **Explicit SLA:** Pass `timeoutMs` to enforce a strict time limit regardless of fuel.\n3. **External Cancellation:** Pass an `AbortSignal` to integrate with external controllers (user cancellation, HTTP timeouts, etc.).\n\n```typescript\n// Default: 1000 fuel = 10 second timeout\nawait vm.run(ast, args, { fuel: 1000 })\n\n// Explicit timeout: 5 seconds regardless of fuel\nawait vm.run(ast, args, { fuel: 10000, timeoutMs: 5000 })\n\n// External abort signal\nconst controller = new AbortController()\nsetTimeout(() => controller.abort(), 3000) // Cancel after 3s\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom via `ctx.signal`. Loop atoms (`while`, `map`, `filter`, `reduce`, `find`) check the signal between iterations. `httpFetch` passes the signal to `fetch` for immediate request cancellation.\n\n**Timeout vs Fuel:**\n\n- **Fuel** protects against CPU-bound abuse (tight loops burning compute)\n- **Timeout** protects against IO-bound abuse (slow network calls, hung promises)\n\nBoth work together to ensure the VM cannot be held hostage by untrusted code.\n\n**Trust Boundary:** The sandbox protects against malicious _agents_ (untrusted AST), not malicious _atom implementations_. Atoms are registered by the host and are trusted to:\n\n1. Be non-blocking (no synchronous CPU-heavy work)\n2. Respect `ctx.signal` for cancellation\n3. Clean up resources when aborted\n\nIf you write custom atoms, ensure they check `ctx.signal?.aborted` in loops and pass `ctx.signal` to any async operations like `fetch`.\n\n### Cost Overrides\n\nDefault atom costs are guesses. Override them per-run to match your deployment reality:\n\n```typescript\nawait vm.run(ast, args, {\n  costOverrides: {\n    // Static: fixed cost per invocation\n    httpFetch: 50,\n    llmPredict: 500,\n\n    // Dynamic: cost based on input\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n  },\n})\n```\n\nUse cases:\n\n- **API rate limits:** Make external API calls expensive to stay under quota\n- **Metered billing:** Reflect actual dollar costs in fuel consumption\n- **Resource protection:** Make database writes cost more than reads\n- **Testing:** Set all costs to 0 to focus on logic, not budgeting\n\n### Request Context\n\nThe `context` option passes request-scoped metadata to atoms. Unlike `args` (agent input) or `capabilities` (IO implementations), context carries ambient data like auth, permissions, and request tracing.\n\n```typescript\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    role: 'admin',\n    permissions: ['read:data', 'write:data', 'fetch:external'],\n    requestId: 'req-abc-123',\n  },\n})\n```\n\nAtoms access it via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    // Check permissions\n    if (!ctx.context?.permissions?.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\n**Design rationale:**\n\n- **Immutable:** Context is read-only; agents cannot modify their own permissions\n- **Separate from args:** Auth data doesn't pollute the agent's input schema\n- **Separate from capabilities:** Same capability implementation, different authorization\n- **Composable:** Works with cost overrides for user-tier-based fuel costs\n\n**Production patterns:**\n\n```typescript\n// Firebase/Express integration\napp.post('/run-agent', async (req, res) => {\n  const ast = req.body.ast\n  const args = req.body.args\n\n  // Extract auth from request\n  const user = await verifyToken(req.headers.authorization)\n\n  const result = await vm.run(ast, args, {\n    context: {\n      userId: user.id,\n      role: user.role,\n      permissions: user.permissions,\n      requestId: req.id,\n    },\n    // User-tier-based costs\n    costOverrides: {\n      llmPredict: user.tier === 'premium' ? 10 : 100,\n    },\n  })\n\n  res.json(result)\n})\n```\n\n## 4. Production Considerations\n\n### Recursive Agent Fuel\n\nWhen an agent calls sub-agents via `agentRun`, each sub-agent gets its own fuel budget (passed via the capability). Fuel is **not shared** across the call tree by default.\n\n**Why:** The `agentRun` atom delegates to `ctx.capabilities.agent.run`, which the host implements. This gives operators full control over sub-agent resource allocation.\n\n**Patterns for shared fuel:**\n\n```typescript\n// Option 1: Pass remaining fuel to children\nconst sharedFuel = { current: 1000 }\n\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      if (sharedFuel.current <= 0) throw new Error('Out of shared fuel')\n      const result = await vm.run(agents[agentId], input, {\n        fuel: sharedFuel.current,\n        capabilities: caps,\n      })\n      sharedFuel.current -= result.fuelUsed\n      return result.result\n    },\n  },\n}\n\n// Option 2: Fixed budget per recursion depth\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      // Each child gets 10% of parent's budget\n      return vm.run(agents[agentId], input, {\n        fuel: 100, // Fixed small budget\n        capabilities: caps,\n      })\n    },\n  },\n}\n```\n\n### Streaming and Long-Running Agents\n\nThe VM returns results only after complete execution. For long-running agents:\n\n- Use `timeoutMs` to enforce SLAs\n- Use `AbortSignal` for user-initiated cancellation\n- Use `trace: true` for post-hoc debugging\n\n**For real-time streaming**, implement a custom atom that emits intermediate results:\n\n```typescript\nconst streamingAtom = defineAtom(\n  'streamChunk',\n  s.object({ data: s.any }),\n  s.null,\n  async ({ data }, ctx) => {\n    // ctx.context contains your streaming callback\n    await ctx.context?.onChunk?.(data)\n    return null\n  }\n)\n\n// Usage\nawait vm.run(ast, args, {\n  context: {\n    onChunk: (data) => res.write(JSON.stringify(data) + '\\n'),\n  },\n})\n```\n\n### Condition String Syntax\n\nThe condition parser in `if`/`while` atoms supports a subset of expression syntax:\n\n| Supported     | Example                           |\n| ------------- | --------------------------------- |\n| Comparisons   | `a > b`, `x == 'hello'`, `n != 0` |\n| Logical       | `a && b`, `a \\|\\| b`, `!a`        |\n| Arithmetic    | `a + b * c`, `(a + b) / c`        |\n| Member access | `obj.foo.bar`                     |\n| Literals      | `42`, `\"string\"`, `true`, `null`  |\n\n| **Unsupported**        | Alternative                        |\n| ---------------------- | ---------------------------------- |\n| Ternary `a ? b : c`    | Use nested `if` atoms              |\n| Array index `a[0]`     | Use ExprNode with `computed: true` |\n| Function calls `fn(x)` | Use atoms                          |\n| Chained `a > b > c`    | Use `a > b && b > c`               |\n\nUnsupported syntax now throws a clear error at build time with suggestions.\n\n### State Semantics\n\nAgents are **not transactional**. If an atom fails mid-execution:\n\n- Previous state changes persist\n- No automatic rollback\n- Error is captured in monadic flow (`ctx.error`)\n\nThis is by design—agents are stateful pipelines, not database transactions. If you need atomicity, implement checkpoint/restore in your capabilities:\n\n```typescript\nconst caps = {\n  store: {\n    set: async (key, value) => {\n      await db.runTransaction(async (tx) => {\n        await tx.set(key, value)\n      })\n    },\n  },\n}\n```\n\n### Error Handling Granularity\n\nThe `try/catch` atom catches all errors in the try block. There's no selective catch by error type.\n\n**Pattern for error type handling:**\n\n```typescript\nAgent.take(s.object({})).try({\n  try: (b) => b.httpFetch({ url: '...' }).as('response'),\n  catch: (b) =>\n    b\n      .varSet({ key: 'errorType', value: 'unknown' })\n      // Check error message patterns\n      .if(\n        'msg.includes(\"timeout\")',\n        { msg: 'error.message' },\n        (then) => then.varSet({ key: 'errorType', value: 'timeout' }),\n        (el) =>\n          el.if('msg.includes(\"404\")', { msg: 'error.message' }, (then) =>\n            then.varSet({ key: 'errorType', value: 'not_found' })\n          )\n      ),\n})\n```\n",
    "title": "tosijs-agent Technical Context",
    "filename": "CONTEXT.md",
    "path": "CONTEXT.md"
  }
]