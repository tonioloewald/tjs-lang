[
  {
    "text": "<!--{\"pin\": \"top\", \"hidden\": true}-->\n\n# tosijs-agent\n\n[github](https://github.com/tonioloewald/tosijs-agent#readme) | [npm](https://www.npmjs.com/package/tosijs-agent) | [discord](https://discord.gg/ramJ9rgky5)\n\n<img src=\"/tosijs-agent.svg\" alt=\"tosijs-agent logo\" width=\"300\" height=\"300\">\n\nA **type-safe-by-design, cost-limited virtual machine** that enables the **safe execution of untrusted code** anywhere.\n\nIt's **safe eval** in the cloud.\n\nAnd it's **tiny**, ![bundlejs bundle including dependencies](https://deno.bundlejs.com/badge?q=tosijs-agent).\n\ntosijs-agent allows you to define complex logic chains, agents, and data pipelines—_computer programs_—using a fluent TypeScript builder. These definitions compile to a safe, JSON-serializable AST ([Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)) that can be executed in the browser, on the server, or at the edge.\n\nFor a deeper dive into the architecture and security model, see the [Technical Context](./CONTEXT.md). For detailed language references and patterns, see the [guides](./guides/).\n\n### Why do you care?\n\n- **Service-as-a-Service:** Define a complete backend service—including database fetches, API calls, and logic—entirely as data, and execute it safely on a server.\n- **Agents-as-Data:** Build AI agents entirely as JSON objects. Send them to a server to run instantly—no deployment, no build steps, no spin-up time.\n- **Universal Runtime:** Run your agent logic in the browser for zero-latency UI updates, or move it to the server for heavy lifting. Because the AST is strongly typed JSON, it is easy to build a runtime for any language or hardware stack, or even compile it directly to LLVM.\n\n### The Holy Grail\n\ntosijs-agent solves fundamental problems in distributed computing:\n\n- **Safe \"Useful Mining\":** Allows distributed nodes to execute productive, arbitrary work safely (sandboxed & gas-limited) — e.g. replacing Proof-of-Work with distributed data processing.\n- **Code is Data:** Logic is defined as a portable AST, making execution language-agnostic and portable.\n- **True Network Agents:** Write code that travels to the data, rather than moving petabytes of data to the code.\n- **Type-Safe Composition:** Build robust pipelines where inputs and outputs are strictly validated at every step.\n\n## Comparison: tosijs-agent vs LangChain\n\nConsider building a \"Research Agent\" that searches for a topic, summarizes it, critiques the summary, and refines the search if needed.\n\n### LangChain\n\nRequires defining Tools, PromptTemplates, Chains (or Graph nodes), and wiring them up with complex state management classes. To refine the logic, you must redeploy the application code.\n\n### tosijs-agent\n\nThe entire logic is a single, fluent expression that compiles to JSON. You can refine the agent's behavior by simply sending a new JSON payload to the server—no deployment required.\n\n```typescript\n// Research Agent: Search -> Summarize -> Critique -> Loop\nconst agent = Agent.take(s.object({ topic: s.string })).while(\n  '!good && tries < 3',\n  {},\n  (loop) =>\n    loop\n      .storeSearch({ query: 'topic' })\n      .as('results')\n      .llmPredict({ system: 'Summarize', user: 'results' })\n      .as('summary')\n      .llmPredict({ system: 'Critique', user: 'summary' })\n      .as('feedback')\n      .if(\n        'feedback == \"OK\"',\n        {},\n        (yes) => yes.varSet({ key: 'good', value: true }),\n        (no) => no.llmPredict({ system: 'Refine', user: 'topic' }).as('topic')\n      )\n)\n```\n\n## Interactive Example: Cover Version Finder\n\nThis example shows the complete loop: a UI form captures user input, AJS code processes it (calling an API and using an LLM to analyze results), and displays the output with album artwork.\n\n```css\n.cover-finder {\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  box-sizing: border-box;\n}\n.cover-finder form {\n  display: flex;\n  gap: 8px;\n  margin-bottom: 16px;\n  flex-wrap: wrap;\n  flex-shrink: 0;\n}\n.cover-finder input {\n  padding: 8px 12px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  flex: 1;\n  min-width: 120px;\n}\n.cover-finder button {\n  padding: 8px 20px;\n  background: #6366f1;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n.cover-finder #results {\n  flex: 1;\n  overflow-y: auto;\n  min-height: 0;\n}\n.cover-finder .cover-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));\n  gap: 16px;\n}\n.cover-finder .cover-card {\n  background: #f5f5f5;\n  border-radius: 8px;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n.cover-finder .cover-card img {\n  width: 100%;\n  aspect-ratio: 1;\n  object-fit: cover;\n}\n.cover-finder .cover-card .info {\n  padding: 10px;\n  flex: 1;\n}\n.cover-finder .cover-card .track {\n  font-weight: bold;\n  font-size: 0.9em;\n  margin-bottom: 4px;\n  line-height: 1.2;\n}\n.cover-finder .cover-card .artist {\n  color: #666;\n  font-size: 0.85em;\n  line-height: 1.2;\n}\n```\n\n```html\n<div class=\"cover-finder\">\n  <form id=\"cover-search\">\n    <input type=\"text\" id=\"song\" placeholder=\"Song name\" value=\"Yesterday\" />\n    <input\n      type=\"text\"\n      id=\"artist\"\n      placeholder=\"Original artist\"\n      value=\"Beatles\"\n    />\n    <button type=\"submit\">Find Covers</button>\n  </form>\n  <div id=\"results\"></div>\n</div>\n```\n\n```js\n// Wire up the form to AJS\n// Uses demoRuntime which gets LLM settings from the Settings dialog\nimport { ajs } from 'tosijs-agent'\n\n// The AJS code - searches iTunes and uses LLM to find covers\nconst findCovers = ajs`\n  function findCovers({ song, artist }) {\n    let query = song + ' ' + artist\n    let url = \\`https://itunes.apple.com/search?term=\\${query}&limit=25&media=music\\`\n    let raw = httpFetch({ url, cache: 3600 })\n    let itunesData = JSON.parse(raw)\n    \n    let results = itunesData.results || []\n    \n    // Build track list with indices for the LLM\n    let tracks = []\n    let i = 0\n    for (let x of results) {\n      tracks.push(\\`[\\${i}] \"\\${x.trackName}\" by \\${x.artistName} (\\${x.collectionName})\\`)\n      i = i + 1\n    }\n    let trackList = tracks.join('\\\\n')\n    \n    // Schema.response builds the responseFormat structure from an example\n    let schema = Schema.response('cover_versions', {\n      covers: [{ index: 0, track: '', artist: '', album: '' }]\n    })\n    \n    let prompt = \\`Search results for \"\\${song}\" by \\${artist}:\n\n\\${trackList}\n\nList cover versions (tracks NOT by \\${artist}). Include the index number.\\`\n\n    let llmResponse = llmPredict({ prompt, options: { responseFormat: schema } })\n    let parsed = JSON.parse(llmResponse)\n    \n    // Return covers with itunesData for artwork lookup in JS\n    return { song, artist, covers: parsed.covers, itunesData }\n  }\n`\n\n// Handle form submission\ndocument.getElementById('cover-search').onsubmit = async (e) => {\n  e.preventDefault()\n  const resultsDiv = document.getElementById('results')\n  resultsDiv.textContent = 'Searching...'\n\n  // demoRuntime uses API keys from Settings dialog\n  const { result, error } = await demoRuntime.run(\n    findCovers,\n    {\n      song: document.getElementById('song').value,\n      artist: document.getElementById('artist').value,\n    },\n    { fuel: 5000 }\n  )\n\n  if (error) {\n    resultsDiv.textContent = `Error: ${error.message}`\n  } else if (result.covers.length === 0) {\n    resultsDiv.textContent = 'No cover versions found.'\n  } else {\n    const itunesResults = result.itunesData?.results || []\n    // Match covers to artwork using index from results\n    const covers = result.covers.map((c) => {\n      const source = itunesResults[c.index]\n      return {\n        ...c,\n        artwork: source?.artworkUrl100?.replace('100x100', '200x200'),\n      }\n    })\n    resultsDiv.innerHTML = `<h3>Cover versions of \"${result.song}\":</h3>\n      <div class=\"cover-grid\">${covers\n        .map((c) =>\n          c.artwork\n            ? `\n        <div class=\"cover-card\">\n          <img src=\"${c.artwork}\" alt=\"${c.album || 'Album art'}\">\n          <div class=\"info\">\n            <div class=\"track\">${c.track || 'Unknown track'}</div>\n            <div class=\"artist\">${c.artist || 'Unknown artist'}</div>\n          </div>\n        </div>`\n            : `\n        <div class=\"cover-card\">\n          <div class=\"info\" style=\"padding-top:60px\">\n            <div class=\"track\">${c.track || 'Unknown track'}</div>\n            <div class=\"artist\">${c.artist || 'Unknown artist'}</div>\n          </div>\n        </div>`\n        )\n        .join('')}\n      </div>`\n  }\n}\n```\n\nThis demonstrates:\n\n- **Safe execution**: The AJS code runs in a sandboxed VM with fuel limits\n- **Structured output**: JSON schema guarantees valid response format from the LLM\n- **Capability injection**: LLM access is provided by the host, not the untrusted code\n- **Portable logic**: The `findCovers` AST could be sent to a server for execution instead\n\n## Example Project\n\nTo see a complete, working example of how to build an agent with a simple UI, check out the official playground project:\n\n**[https://github.com/brainsnorkel/agent99-playground](https://github.com/brainsnorkel/agent99-playground)**\n\n## Installation\n\n```bash\nbun add tosijs-agent\n# or\nnpm install tosijs-agent\n```\n\n## Quick Start\n\n### 1. Write Logic (AJS)\n\nWrite agents in AJS—a JavaScript subset that compiles to a safe, serializable AST.\n\n```typescript\nimport { ajs, AgentVM } from 'tosijs-agent'\n\n// Define a calculation agent using familiar JavaScript syntax\nconst calculateTotal = ajs`\n  function calculate({ price, taxRate }) {\n    let total = price * (1 + taxRate)\n    return { total }\n  }\n`\n\n// Run it\nconst vm = new AgentVM()\nconst result = await vm.run(calculateTotal, { price: 100, taxRate: 0.2 })\n\nconsole.log(result.result) // { total: 120 }\nconsole.log(result.fuelUsed) // Fuel consumed\n```\n\nAJS supports most JavaScript expressions, loops, try/catch, and more. See [guides/ajs.md](./guides/ajs.md) for the full language reference.\n\n### 2. Advanced: The Builder API\n\nFor programmatic AST construction (e.g., dynamic agent generation, metaprogramming), use the fluent builder:\n\n```typescript\nimport { Agent, s } from 'tosijs-agent'\n\nconst calculateTotal = Agent.take(\n  s.object({ price: s.number, taxRate: s.number })\n)\n  .varSet({\n    key: 'total',\n    value: {\n      $expr: 'binary',\n      op: '*',\n      left: Agent.args('price'),\n      right: {\n        $expr: 'binary',\n        op: '+',\n        left: { $expr: 'literal', value: 1 },\n        right: Agent.args('taxRate'),\n      },\n    },\n  })\n  .return(s.object({ total: s.number }))\n\nconst ast = calculateTotal.toJSON() // JSON-serializable AST\n```\n\nThe Builder is lower-level but gives you full control over AST construction.\n\n## Tracing and Debugging\n\nFor debugging and testing, you can enable trace mode to get a detailed log of the agent's execution path.\n\n```typescript\nconst { result, trace } = await vm.run(\n  ast,\n  { price: 100, taxRate: 0.2 },\n  { trace: true } // Enable trace mode\n)\n\nconsole.log(trace)\n```\n\nThe `trace` output is an array of `TraceEvent` objects, where each event records the state of the agent before and after an atom's execution, along with the inputs, outputs, and fuel consumption.\n\n```typescript\ninterface TraceEvent {\n  op: string\n  input: any\n  stateBefore: any\n  stateAfter: any\n  result?: any\n  error?: string\n  fuelBefore: number\n  fuelAfter: number\n  timestamp: string\n}\n```\n\n## Core Atoms\n\nThe standard library includes essential primitives:\n\n| Category         | Atoms                                                              | Description                                                                                                           |\n| ---------------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | `seq`, `if`, `while`, `return`, `try`                              | Control flow and loops.                                                                                               |\n| **State**        | `varSet`, `varGet`, `varsLet`, `varsImport`, `varsExport`, `scope` | Variable management, including batch operations for importing variables from arguments and exporting them as results. |\n| **Expressions**  | ExprNode (`$expr`)                                                 | Safe expression evaluation via AST nodes (binary, unary, member, etc.).                                               |\n| **Logic**        | `eq`, `gt`, `and`, `not`, ...                                      | Boolean logic.                                                                                                        |\n| **IO**           | `httpFetch`                                                        | HTTP requests.                                                                                                        |\n| **Store**        | `storeGet`, `storeSet`                                             | Key-Value storage.                                                                                                    |\n| **AI**           | `llmPredict`, `agentRun`                                           | LLM calls and sub-agent recursion.                                                                                    |\n| **Procedures**   | `storeProcedure`, `releaseProcedure`, `clearExpiredProcedures`     | Store ASTs as callable tokens with TTL expiry.                                                                        |\n| **Utils**        | `random`, `uuid`, `hash`                                           | Random generation, UUIDs, and hashing.                                                                                |\n| **Optimization** | `memoize`, `cache`                                                 | In-memory memoization and persistent caching. Keys are optional and will be auto-generated if not provided.           |\n\n## Expression Builtins\n\nAJS expressions have access to safe built-in objects:\n\n| Builtin  | Description                                                                 |\n| -------- | --------------------------------------------------------------------------- |\n| `Math`   | All standard math functions (`abs`, `floor`, `sqrt`, `sin`, `random`, etc.) |\n| `JSON`   | `parse()` and `stringify()`                                                 |\n| `Array`  | `isArray()`, `from()`, `of()`                                               |\n| `Object` | `keys()`, `values()`, `entries()`, `fromEntries()`, `assign()`              |\n| `String` | `fromCharCode()`, `fromCodePoint()`                                         |\n| `Number` | Constants and type checks (`MAX_VALUE`, `isNaN`, `isFinite`, etc.)          |\n| `Set`    | Set-like operations with `add`, `remove`, `union`, `intersection`, `diff`   |\n| `Date`   | Date factory with arithmetic and formatting                                 |\n| `Schema` | Schema builder for structured LLM responses (see below)                     |\n| `filter` | Schema-based data filtering                                                 |\n\n### Schema Builder\n\nThe `Schema` builtin exposes [tosijs-schema](https://github.com/nicholascross/tosijs-schema)'s fluent API for building JSON Schemas. This is especially useful for LLM structured outputs.\n\n```javascript\n// Simple: build responseFormat from an example object\nlet schema = Schema.response('person', { name: '', age: 0 })\n\n// With constraints: use the fluent API\nlet schema = Schema.response(\n  'user',\n  Schema.object({\n    email: Schema.string.email,\n    age: Schema.number.int.min(0).max(150).optional,\n    role: Schema.enum(['admin', 'user', 'guest']),\n  })\n)\n```\n\n**Available methods:**\n\n| Category        | Methods                                                                   |\n| --------------- | ------------------------------------------------------------------------- |\n| **Primitives**  | `string`, `number`, `integer`, `boolean`, `any`                           |\n| **String**      | `.min(n)`, `.max(n)`, `.pattern(regex)`, `.email`, `.url`, `.uuid`        |\n| **Number**      | `.min(n)`, `.max(n)`, `.step(n)`, `.int`                                  |\n| **Combinators** | `array(items)`, `object(props)`, `record(value)`, `tuple(items)`          |\n| **Union/Enum**  | `union([...])`, `enum([...])`, `const(value)`                             |\n| **Metadata**    | `.title(s)`, `.describe(s)`, `.default(v)`, `.optional`                   |\n| **Helpers**     | `response(name, schema)`, `fromExample(example)`, `isValid(data, schema)` |\n\n## Stored Procedures\n\nStore ASTs as callable tokens—function pointers that can be passed around and invoked later. Useful for:\n\n- **Dynamic dispatch:** Pass behavior as data to sub-agents\n- **Deferred execution:** Store logic now, execute later\n- **Callback patterns:** Register handlers that other agents can invoke\n\n```typescript\nimport { ajs, AgentVM } from 'tosijs-agent'\n\nconst vm = new AgentVM()\n\n// Define a worker agent\nconst workerAgent = ajs`\n  function worker({ value }) {\n    return { doubled: value * 2 }\n  }\n`\n\n// Store it and get a token\nconst storeAgent = ajs`\n  function store({ ast }) {\n    let token = storeProcedure({ ast })\n    return { token }\n  }\n`\n\nconst { result: storeResult } = await vm.run(storeAgent, { ast: workerAgent })\nconst token = storeResult.token // e.g., \"proc_abc123...\"\n\n// Call via token directly\nconst { result } = await vm.run(token, { value: 21 })\nconsole.log(result) // { doubled: 42 }\n\n// Or pass token to another agent\nconst orchestrator = ajs`\n  function orchestrate({ workerToken, values }) {\n    let results = []\n    for (let v of values) {\n      let r = agentRun({ agentId: workerToken, input: { value: v } })\n      results.push(r.doubled)\n    }\n    return { results }\n  }\n`\n\nconst { result: orchResult } = await vm.run(orchestrator, {\n  workerToken: token,\n  values: [1, 2, 3, 4, 5],\n})\nconsole.log(orchResult) // { results: [2, 4, 6, 8, 10] }\n```\n\n### Token Lifecycle\n\n| Atom                                      | Description                                                    |\n| ----------------------------------------- | -------------------------------------------------------------- |\n| `storeProcedure({ ast, ttl?, maxSize? })` | Store an AST, returns a `proc_*` token. Default TTL: 1 hour.   |\n| `releaseProcedure({ token })`             | Manually delete a stored procedure. Returns `true` if existed. |\n| `clearExpiredProcedures({})`              | Remove all expired procedures. Returns count cleared.          |\n\n**Options:**\n\n- `ttl`: Time-to-live in milliseconds (default: 3600000 = 1 hour)\n- `maxSize`: Maximum AST size in bytes (default: 102400 = 100KB)\n\n**Errors:**\n\n- `TokenExpired`: Token existed but TTL has passed\n- `TokenNotFound`: Token was never stored or was released\n- `ASTTooLarge`: AST exceeds `maxSize` limit\n\n## Capabilities & Security\n\ntosijs-agent uses a **[Capability-Based Security](https://en.wikipedia.org/wiki/Capability-based_security)** model. The VM cannot access the network, file system, or database unless provided with a Capability.\n\n**Zero Config Defaults:** The runtime provides sensible defaults for local development:\n\n- `httpFetch` uses the global `fetch`.\n- `store` uses an in-memory `Map` (ephemeral).\n- `random`/`uuid` use `crypto` or `Math`.\n\nIn production, you should inject secure, instrumented, or cloud-native implementations (e.g., restricted fetch, Postgres, Redis).\n\n### Execution Timeout\n\nThe VM enforces a hard timeout to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n- **Automatic Safety Net:** Defaults to `fuel × 10ms` (e.g., 1000 fuel ≈ 10s budget). _Note: For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n- **Explicit Control:** Pass `timeoutMs` to enforce a strict Service Level Agreement (SLA).\n- **Cancellation:** Pass an `AbortSignal` to integrate with external cancellation controllers (e.g., user cancellation buttons or HTTP request timeouts).\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom (via `ctx.signal`). Atoms implementing cancellation (like `httpFetch`) will abort their network requests immediately.\n\n```typescript\n// 1. Default Safety Net (good for compute-heavy logic)\nawait vm.run(ast, args, { fuel: 1000 })\n\n// 2. SLA Enforcement: \"This agent must finish in 5s or we drop it\"\nawait vm.run(ast, args, { fuel: 5000, timeoutMs: 5000 })\n\n// 3. User Cancellation: connect UI \"Stop\" button to the Agent\nconst controller = new AbortController()\nstopButton.onClick(() => controller.abort())\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Fuel vs Timeout:** Fuel protects against CPU-bound abuse (tight loops). Timeout protects against IO-bound abuse (slow network calls). Together they ensure the VM cannot be held hostage.\n\n### Cost Overrides\n\nDefault fuel costs are context-agnostic guesses. In production, you'll want to tune costs for your specific deployment—an LLM call to a local model vs OpenAI has very different resource implications.\n\n```typescript\n// Static overrides\nawait vm.run(ast, args, {\n  fuel: 1000,\n  costOverrides: {\n    httpFetch: 50, // We pay per API request\n    llmPredict: 500, // LLM calls are expensive\n    storeGet: 0.5, // Redis is cheap\n  },\n})\n\n// Dynamic overrides based on input\nawait vm.run(ast, args, {\n  costOverrides: {\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n  },\n})\n```\n\nThis lets operators tune fuel costs for their reality rather than relying on universal defaults.\n\n### Request Context\n\nFor production deployments, you often need to pass request-scoped metadata (auth, permissions, request IDs) to atoms. The `context` option provides a clean mechanism for this.\n\n```typescript\n// Pass auth/permissions from your request handler\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    permissions: ['read:data', 'fetch:external'],\n    requestId: crypto.randomUUID(),\n  },\n})\n```\n\nAtoms access context via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    const permissions = ctx.context?.permissions ?? []\n    if (!permissions.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\nUse cases:\n\n- **Authorization:** Check user permissions before executing sensitive operations\n- **Multi-tenancy:** Route storage/database calls to tenant-specific resources\n- **Audit logging:** Include request IDs in all log entries\n- **Dynamic costs:** Combine with `costOverrides` for user-tier-based pricing\n\n**Security Note:** The sandbox protects against malicious _agents_, not malicious _atom implementations_. Atoms are registered by the host and are trusted to be non-blocking and to respect `ctx.signal` for cancellation.\n\n## Batteries Included (Zero-Dependency Local AI)\n\nFor local AI development, Agent99 provides a \"Batteries Included\" setup that runs out-of-the-box with **zero external dependencies or API keys**. It features a built-in vector search and connects to [LM Studio](https://lmstudio.ai/) for local model inference.\n\n### 1. Setup LM Studio\n\nTo use the batteries, you need to have LM Studio running in the background.\n\n1.  **Download and Install:** Get LM Studio from [lmstudio.ai](https://lmstudio.ai/).\n2.  **Download Models:** You'll need at least one LLM and one embedding model. We recommend:\n    - **LLM:** Search for a [GGUF](https://github.com/ggerganov/ggml/blob/master/docs/gguf.md) model like `Meta-Llama-3-8B-Instruct.Q4_K_M.gguf` for a good balance of performance and size.\n    - **Embedding:** Search for `nomic-embed-text-v1.5.Q8_0.gguf`.\n3.  **Start the Server:** Go to the \"Local Server\" tab (icon: `<-->`) and click \"Start Server\".\n\n### 2. How it Works\n\nWhen you first import the `batteries` from `tosijs-agent`, the runtime performs a one-time audit of the models available on your LM Studio server. It automatically detects which models are for embeddings and which are for chat, and caches the results to avoid re-auditing during the same session.\n\nThis allows Agent99 to automatically select the correct models for different tasks without any configuration. The cache uses `localStorage` if available (in a browser environment), or a simple in-memory cache otherwise.\n\n### 3. Usage\n\nThe `batteries` export contains the necessary capabilities. To use them, register the `batteryAtoms` with the `AgentVM` and pass the `batteries` object to the `run` method's capabilities.\n\n> **Note on Breaking Change:** Previously, battery atoms were exported individually. They are now consolidated into a single `batteryAtoms` object. This simplifies registration with the `AgentVM`.\n>\n> **Old Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, storeVectorize, storeSearch } from 'tosijs-agent'\n> const vm = new AgentVM({ storeVectorize, storeSearch, ... })\n> ```\n>\n> **New Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, batteryAtoms } from 'tosijs-agent'\n> const vm = new AgentVM(batteryAtoms)\n> ```\n\n```typescript\nimport { AgentVM, batteries, batteryAtoms, Agent } from 'tosijs-agent'\n\n// Register the battery atoms\nconst vm = new AgentVM(batteryAtoms)\n\n// The batteries are audited on import.\nconst logic = vm.Agent.storeVectorize({ text: 'Hello' }).as('vector')\n\nconst { result } = await vm.run(logic.toJSON(), {}, { capabilities: batteries })\n\nconsole.log(result)\n```\n\n### 4. Vector Search Performance\n\nThe built-in vector search is implemented with a highly optimized **[cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity) function** that operates directly on arrays. It is designed for serverless and edge environments where low-latency is critical. Benchmarks run on a 2023 M3 Max using `bun test` show the following performance characteristics:\n\n| Vector Count | Dimensions | Search Time |\n| :----------- | :--------- | :---------- |\n| 10,000       | 500        | ~15 ms      |\n| 10,000       | 1000       | ~22 ms      |\n| 100,000      | 500        | ~101 ms     |\n\nThese results demonstrate that the in-memory vector store is suitable for a wide range of real-time applications without requiring a dedicated vector database.\n\n> **cosine similarity** is the most popular algorithm for vector search, but there are many others (along with strategies for dealing with extremely large data-sets). For more information you can start with this Wikipedia article [Vector database](https://en.wikipedia.org/wiki/Vector_database).\n\n### 5. Structured Outputs\n\nYou can request structured JSON responses (e.g., JSON Schema) from compatible models using `responseFormat`:\n\n```typescript\nconst logic = vm.Agent.llmPredictBattery({\n  system: 'Extract data.',\n  user: 'John Doe, 30',\n  responseFormat: {\n    type: 'json_schema',\n    json_schema: {\n      name: 'person',\n      schema: {\n        type: 'object',\n        properties: {\n          name: { type: 'string' },\n          age: { type: 'number' },\n        },\n        required: ['name', 'age'],\n      },\n    },\n  },\n})\n```\n\n### 5. Troubleshooting\n\n- **Connection Error:** If you see an error like `Failed to connect to LM Studio`, make sure the LM Studio server is running on the default port (`1234`).\n- **No Models Found:** Ensure you have downloaded compatible GGUF models and they are loaded in LM Studio. The audit process will warn you if it cannot find suitable LLM or embedding models.\n\n## Self-Documentation for Agents\n\nThe VM can describe itself to an LLM, generating an [OpenAI-compatible Tool Schema](https://platform.openai.com/docs/guides/function-calling) for its registered atoms.\n\n```typescript\n// Get all tools\nconst tools = vm.getTools()\n\n// Get only flow control tools\nconst flowTools = vm.getTools('flow')\n\n// Get specific tools\nconst myTools = vm.getTools(['httpFetch', 'template'])\n```\n\n## Implementing Real-World Atoms\n\nTo enable custom capabilities like Database Access or Web Scraping, you inject them into the `VM.run` call.\n\n#### Example: Providing a Database\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\n\nconst vm = new AgentVM()\n\nconst capabilities = {\n  store: {\n    get: async (key) => {\n      // Connect to Redis/Postgres here\n      return await db.find(key)\n    },\n    set: async (key, value) => {\n      await db.insert(key, value)\n    },\n  },\n}\n\nawait vm.run(ast, args, { capabilities })\n```\n\n#### Example: Web Scraping Agent\n\nYou can expose a custom capability or use the standard `httpFetch` if trusted.\n\n```typescript\nconst capabilities = {\n  fetch: async (url, options) => {\n    // Implement secure fetch, possibly with proxy rotation or rate limiting\n    return fetch(url, options)\n  },\n}\n```\n\n## Custom Atoms\n\nYou can extend the runtime with your own atomic operations.\n\n```typescript\nimport { defineAtom, AgentVM, s, Agent } from 'tosijs-agent'\n\n// 1. Define the Atom\nconst myScraper = defineAtom(\n  'scrape', // OpCode\n  s.object({ url: s.string }), // Input Schema\n  s.string, // Output Schema\n  async ({ url }, ctx) => {\n    // Implementation logic\n    const res = await ctx.capabilities.fetch(url)\n    return await res.text()\n  },\n  { cost: 5 } // Gas cost\n)\n\n// 2. Register with Custom VM\nconst myVM = new AgentVM({ scrape: myScraper })\n\n// 3. Use in Builder (Types are inferred!)\n// The `vm.Agent` property is the recommended way to get a builder\n// that includes any custom atoms you have registered.\nconst builder = myVM.Agent\n\nconst logic = builder\n  .scrape({ url: 'https://example.com' })\n  .as('html')\n  .return(s.object({ html: s.string }))\n```\n\n## Control Flow\n\nAtoms like `if` and `while` evaluate expression strings. For security and predictability, these expressions are not granted access to the full agent state. Instead, you must use the `vars` parameter to explicitly pass in any state variables that the expression needs.\n\nThis mapping allows you to alias variables, making your expressions cleaner and more readable.\n\n### If / Else\n\n```typescript\nchain.if(\n  'p > 100 && itemsLeft > 0',\n  { p: 'product.price', itemsLeft: 'inventory.stockCount' }, // Map state to expression variables\n  (then) => then.varSet({ key: 'discount', value: true }),\n  (elseBranch) => elseBranch.varSet({ key: 'discount', value: false })\n)\n```\n\n### While Loop\n\n```typescript\n// The `vars` map works identically here, creating a scope for the condition.\n// Use ExprNode for arithmetic operations\nchain.while('n > 0', { n: 'counter' }, (loop) =>\n  loop.varSet({\n    key: 'counter',\n    value: {\n      $expr: 'binary',\n      op: '-',\n      left: { $expr: 'ident', name: 'counter' },\n      right: { $expr: 'literal', value: 1 },\n    },\n  })\n)\n```\n\n### Try / Catch\n\n```typescript\nchain.try({\n  try: (b) => b.httpFetch({ url: '...' }),\n  catch: (b) => b.varSet({ key: 'error', value: 'failed' }),\n})\n```\n\n## Editor Support\n\ntosijs-agent includes syntax highlighting for AJS (the JavaScript subset used by `ajs` template literals).\n\n### Quick Install\n\n```bash\n# VS Code\nnpx ajs-install-vscode\n\n# Cursor\nnpx ajs-install-cursor\n```\n\nFeatures:\n\n- Syntax highlighting for `.ajs` files\n- Embedded highlighting inside `ajs`...`` template literals\n- Error highlighting for forbidden syntax (`new`, `class`, `async`, etc.)\n\n### Web Editors\n\n**Monaco:**\n\n```typescript\nimport { registerAjsLanguage } from 'tosijs-agent/editors/monaco'\nregisterAjsLanguage(monaco)\n```\n\n**CodeMirror 6:**\n\n```typescript\nimport { ajs } from 'tosijs-agent/editors/codemirror'\n// Use ajs() in your extensions\n```\n\n### Tree-sitter Editors (Zed, Nova, Helix)\n\nAssociate `.ajs` files with JavaScript syntax in your editor config. See [editors/README.md](./editors/README.md) for details.\n\n> **Note:** If you modify AsyncJS syntax (e.g., adding/removing forbidden keywords), update the grammar files in `editors/` to match. See [editors/README.md](./editors/README.md) for grammar locations.\n\n## Development\n\n### Testing\n\nThe test suite includes performance benchmarks for the in-memory vector search. These benchmarks can be sensitive to the performance of the host machine and may fail in slower CI/CD environments. To avoid this, you can skip the benchmark tests by setting the `AGENT99_TESTS_SKIP_BENCHMARKS` environment variable.\n\n```bash\n# Run tests\nbun test\n\n# Skip benchmark tests\nAGENT99_TESTS_SKIP_BENCHMARKS=1 bun test\n\n# Type check\nbun run typecheck\n\n# Build blueprint\nbun run make\n```\n",
    "title": "tosijs-agent",
    "filename": "README.md",
    "path": "README.md",
    "pin": "top",
    "hidden": true
  },
  {
    "text": "# AJS (.ajs) - A Better JavaScript for AI Agents\n\nAJS is a JavaScript subset designed for writing AI agent logic. It compiles to Agent99's secure JSON AST format, providing familiar syntax with cleaner semantics.\n\n> **For LLM Integration:** See [ajs-llm-prompt.md](./ajs-llm-prompt.md) for a system prompt optimized for code generation.\n\n## File Extension\n\nAJS files use the `.ajs` extension to distinguish them from standard JavaScript:\n\n```\nmy-agent.ajs\nsearch-tool.ajs\n```\n\n## Why AJS?\n\n| Problem with JavaScript       | AJS Solution                                    |\n| ----------------------------- | ----------------------------------------------- |\n| `async/await` boilerplate     | All calls are implicitly async                  |\n| Complex error handling        | Monadic error flow - errors propagate as values |\n| No built-in type safety       | Types through example values                    |\n| Security concerns with `eval` | Compiles to sandboxed VM                        |\n\n## Quick Example\n\n```javascript\n// search-agent.ajs\n\n/**\n * Search and summarize information about a topic\n * @param topic - The topic to research\n * @param maxResults - Maximum number of results\n */\nfunction searchAgent(topic: 'climate change', maxResults = 5) {\n  let results = search({ query: topic, limit: maxResults })\n\n  if (results.length == 0) {\n    return { summary: 'No results found', sources: [] }\n  }\n\n  let summary = llmPredict({\n    system: 'Summarize these search results concisely',\n    user: results,\n  })\n\n  return { summary, sources: results }\n}\n```\n\n## Core Differences from JavaScript\n\n### 1. Implicit Async\n\nAll function calls that invoke atoms are automatically awaited. No `async/await` keywords needed.\n\n```javascript\n// AJS - clean and simple\nfunction agent(topic: 'machine learning') {\n  let results = search({ query: topic })\n  let summary = summarize({ text: results })\n  return { summary }\n}\n\n// Equivalent JavaScript would require:\n// async function agent(topic) {\n//   let results = await search({ query: topic })\n//   let summary = await summarize({ text: results })\n//   return { summary }\n// }\n```\n\n### 2. Types Through Example Values\n\nTypes are inferred from example values. The example shows both the type AND a realistic value:\n\n```javascript\nfunction greet(\n  name: 'Anne Example', // required string\n  age: 21, // required number\n  greeting = 'Hello' // optional string, defaults to 'Hello'\n) {\n  // ...\n}\n```\n\n- **Colon (`:`)** = required parameter, example shows the type\n- **Equals (`=`)** = optional parameter with default value\n\nThe example value IS the type. `age: 21` means \"required number\". `name: 'Anne'` means \"required string\".\n\n### 3. Monadic Error Flow\n\nErrors propagate automatically as values. When an atom fails, subsequent steps are skipped and the error flows through to the result.\n\n```javascript\nfunction pipeline(topic: 'quantum computing') {\n  let results = search({ query: topic }) // might fail\n  let summary = summarize({ text: results }) // skipped if search fails\n  let formatted = format({ content: summary }) // skipped if any above fails\n  return { formatted }\n}\n// If search() fails, the error flows through without executing subsequent steps\n// The result will have an `error` property containing the AgentError\n```\n\nThe VM returns a `RunResult` with both `result` and `error` fields:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  console.log('Failed:', error.message)\n  console.log('Failed at atom:', error.op)\n} else {\n  console.log('Success:', result)\n}\n```\n\nUse `try/catch` to recover from errors:\n\n```javascript\nfunction resilientPipeline(topic: 'neural networks') {\n  let data = null\n  try {\n    data = fetchData({ topic })\n  } catch (e) {\n    data = fallbackData({ topic })\n  }\n  return { data }\n}\n```\n\n### 4. Function Introspection\n\nEvery function has a `.signature` property for self-documentation:\n\n```javascript\n/**\n * Search the knowledge base\n * @param query - The search query\n * @param limit - Max results to return\n */\nfunction search(\n  query: 'example query',\n  limit = 10\n) -> [{ title: 'Example Title', url: 'https://example.com' }] {\n  // implementation\n}\n\n// Automatically gets:\nsearch.signature = {\n  name: 'search',\n  description: 'Search the knowledge base',\n  parameters: {\n    query: { type: 'string', required: true, description: 'The search query' },\n    limit: { type: 'number', required: false, default: 10, description: 'Max results to return' }\n  },\n  returns: { type: 'array', items: { type: 'object', shape: { title: 'string', url: 'string' } } }\n}\n```\n\n## Type System Reference\n\n### Parameter Types\n\n| Syntax                  | Meaning          | Example                          |\n| ----------------------- | ---------------- | -------------------------------- |\n| `name: 'Anne'`          | Required string  | The example value shows the type |\n| `age: 21`               | Required number  |                                  |\n| `active: true`          | Required boolean |                                  |\n| `tags: ['a', 'b']`      | Required array   |                                  |\n| `user: { name: 'Bob' }` | Required object  |                                  |\n| `limit = 10`            | Optional number  | Defaults to 10                   |\n| `query = 'default'`     | Optional string  | Defaults to 'default'            |\n\n### Destructured Parameter Defaults\n\nAJS supports default values in destructured object parameters. Unlike JavaScript/TypeScript where destructuring defaults can be tricky, AJS makes them work reliably:\n\n```javascript\nfunction calculate({ a = 10, b = 5 }) {\n  return { sum: a + b, product: a * b }\n}\n\n// Called with no arguments - uses defaults\ncalculate({}) // { sum: 15, product: 50 }\n\n// Called with partial arguments - missing ones use defaults\ncalculate({ a: 20 }) // { sum: 25, product: 100 }\n\n// Called with all arguments - no defaults used\ncalculate({ a: 3, b: 7 }) // { sum: 10, product: 21 }\n```\n\nThis works seamlessly with type annotations too:\n\n```javascript\nfunction greet({ name: 'World', greeting = 'Hello' }) {\n  return { message: `${greeting}, ${name}!` }\n}\n\ngreet({})  // { message: \"Hello, World!\" }\ngreet({ name: 'Alice' })  // { message: \"Hello, Alice!\" }\ngreet({ greeting: 'Hi' })  // { message: \"Hi, World!\" }\n```\n\n### Return Types\n\nReturn types can be specified with arrow syntax:\n\n```javascript\nfunction search(query: 'search term') -> { results: [], count: 0 } {\n  // Must return object with results array and count number\n}\n```\n\nOr inferred from the return statement:\n\n```javascript\nfunction search(query: 'search term') {\n  return { results: [], count: 0 } // Return type inferred\n}\n```\n\n## Supported Constructs\n\n### Variables\n\n```javascript\nlet x = 5 // Variable declaration\nx = 10 // Assignment\nlet { a, b } = obj // Destructuring (limited)\n```\n\n### Control Flow\n\n```javascript\n// Conditionals\nif (condition) {\n  // ...\n} else {\n  // ...\n}\n\n// Loops\nwhile (condition) {\n  // ...\n}\n\nfor (const item of items) {\n  // Becomes a map operation\n}\n\n// Error handling\ntry {\n  // ...\n} catch (e) {\n  // ...\n}\n```\n\n### Expressions\n\n```javascript\n// Arithmetic\na + b, a - b, a * b, a / b, a % b\n\n// Comparison\na == b, a != b, a < b, a > b, a <= b, a >= b\n\n// Logical\na && b, a || b, !a\n\n// Member access\nobj.property\nobj.nested.property\narr[0]\n\n// Optional chaining (safe access)\nobj?.property\nobj?.nested?.value\narr?.[0]\n\n// Template literals\n`Hello ${name}!`\n\n// Function calls\natomName({ param1: value1, param2: value2 })\n```\n\n### Built-in Objects\n\nAJS provides safe implementations of common JavaScript built-in objects:\n\n#### Math\n\nAll standard Math methods and constants are available:\n\n```javascript\nlet floor = Math.floor(3.7) // 3\nlet ceil = Math.ceil(3.2) // 4\nlet abs = Math.abs(-5) // 5\nlet max = Math.max(1, 5, 3) // 5\nlet sqrt = Math.sqrt(16) // 4\nlet pi = Math.PI // 3.14159...\nlet random = Math.random() // Cryptographically secure when available\n```\n\n**Note:** `Math.random()` uses `crypto.getRandomValues()` when available for cryptographically secure random numbers.\n\n#### JSON\n\n```javascript\nlet obj = { name: 'test', value: 42 }\nlet str = JSON.stringify(obj) // '{\"name\":\"test\",\"value\":42}'\nlet parsed = JSON.parse(str) // { name: 'test', value: 42 }\n```\n\n#### Array Static Methods\n\n```javascript\nlet isArr = Array.isArray([1, 2, 3]) // true\nlet arr = Array.from([1, 2, 3]) // Creates new array\nlet created = Array.of(1, 2, 3) // [1, 2, 3]\n```\n\n#### Object Static Methods\n\n```javascript\nlet obj = { a: 1, b: 2, c: 3 }\nlet keys = Object.keys(obj) // ['a', 'b', 'c']\nlet values = Object.values(obj) // [1, 2, 3]\nlet entries = Object.entries(obj) // [['a',1], ['b',2], ['c',3]]\n```\n\n#### Number Static Methods\n\n```javascript\nlet isInt = Number.isInteger(5) // true\nlet isNan = Number.isNaN(NaN) // true\nlet max = Number.MAX_SAFE_INTEGER // 9007199254740991\n```\n\n#### Global Functions\n\n```javascript\nlet n = parseInt('42') // 42\nlet f = parseFloat('3.14') // 3.14\nlet encoded = encodeURIComponent('hello world') // 'hello%20world'\n```\n\n#### String Instance Methods\n\n```javascript\nlet str = 'hello world'\nlet upper = str.toUpperCase() // 'HELLO WORLD'\nlet parts = str.split(' ') // ['hello', 'world']\nlet trimmed = '  padded  '.trim() // 'padded'\nlet replaced = str.replace('world', 'there') // 'hello there'\n```\n\n#### Array Instance Methods\n\n```javascript\nlet arr = [3, 1, 4, 1, 5]\nlet joined = arr.join('-') // '3-1-4-1-5'\nlet has = arr.includes(4) // true\nlet idx = arr.indexOf(1) // 1\nlet sliced = arr.slice(1, 3) // [1, 4]\n```\n\n### Set and Date Builtins\n\nAJS provides `Set()` and `Date()` as factory functions - no `new` keyword needed.\n\n#### Set\n\nCreate sets with `Set([items])`. Sets have both mutable operations (modify in place) and immutable set algebra (return new sets):\n\n```javascript\n// Create a Set\nlet tags = Set(['javascript', 'typescript', 'rust'])\nlet empty = Set()\n\n// Mutable operations (modify the set, return this for chaining)\ntags.add('go') // Add item\ntags.remove('rust') // Remove item\ntags.clear() // Remove all items\n\n// Query operations\nlet has = tags.has('typescript') // true/false\nlet count = tags.size // Number of items\nlet arr = tags.toArray() // Convert to array\n\n// Immutable set algebra (return NEW sets)\nlet a = Set([1, 2, 3])\nlet b = Set([2, 3, 4])\n\nlet union = a.union(b) // Set([1, 2, 3, 4])\nlet inter = a.intersection(b) // Set([2, 3])\nlet diff = a.diff(b) // Set([1]) - items in a but not b\n```\n\n#### Date\n\nCreate dates with `Date()` or `Date(initializer)`. Date objects are **immutable** - methods like `add()` return new Date objects:\n\n```javascript\n// Create a Date\nlet now = Date() // Current date/time\nlet specific = Date('2024-06-15') // From ISO string\nlet fromTs = Date(1718409600000) // From timestamp\n\n// Static methods\nlet timestamp = Date.now() // Current timestamp (number)\nlet parsed = Date.parse('2024-06-15T10:30:00Z') // Parse to Date object\n\n// Component accessors (read-only)\nlet d = Date('2024-06-15T10:30:45Z')\nd.year // 2024\nd.month // 6 (1-12, not 0-11 like JS!)\nd.day // 15\nd.hours // 10\nd.minutes // 30\nd.seconds // 45\nd.timestamp // Unix timestamp in ms\nd.value // ISO string\n\n// Immutable arithmetic (returns NEW Date)\nlet later = d.add({ days: 5, hours: 3 })\nlet earlier = d.add({ months: -1 })\n// Supported: years, months, days, hours, minutes, seconds\n\n// Comparison\nlet before = d.isBefore(later) // true\nlet after = later.isAfter(d) // true\nlet diffDays = d.diff(later, 'days') // -5\n\n// Formatting\nlet formatted = d.format('date') // '2024-06-15'\nlet iso = d.format('iso') // '2024-06-15T10:30:45.000Z'\nlet time = d.format('time') // '10:30:45'\n```\n\n**Note:** Unlike JavaScript's `Date`, months are 1-12 (not 0-11), and all methods are immutable.\n\n#### Serialization\n\nSets and Dates serialize cleanly to JSON:\n\n```javascript\nlet result = {\n  tags: Set(['a', 'b', 'c']),\n  created: Date('2024-06-15'),\n}\n// JSON.stringify(result) produces:\n// { \"tags\": [\"a\", \"b\", \"c\"], \"created\": \"2024-06-15T00:00:00.000Z\" }\n```\n\n- **Sets** serialize to arrays\n- **Dates** serialize to ISO 8601 strings\n\n### Schema Filtering\n\nThe `filter()` builtin validates and strips extra properties from objects based on a schema:\n\n```javascript\n// Strip extra properties from an object\nlet raw = { name: 'Alice', age: 30, secret: 'password', extra: 123 }\nlet clean = filter(raw, { name: 'string', age: 0 })\n// clean = { name: 'Alice', age: 30 }\n\n// Works with nested objects\nlet data = {\n  user: { name: 'Bob', age: 25, ssn: '123-45-6789' },\n  tags: ['a', 'b'],\n  internal: 'hidden',\n}\nlet filtered = filter(data, {\n  user: { name: 'string', age: 0 },\n  tags: ['string'],\n})\n// filtered = { user: { name: 'Bob', age: 25 }, tags: ['a', 'b'] }\n\n// Throws on validation failure (missing required fields)\nlet bad = filter({ name: 'Alice' }, { name: 'string', age: 0 })\n// Error: Missing age\n```\n\n**Use cases:**\n\n- Sanitize LLM outputs - strip unexpected properties from JSON responses\n- API input validation - accept only the fields you expect\n- Data projection - reduce objects to a known shape\n\n**Note:** Return values are automatically filtered when a return type is declared. This makes return types act as projections:\n\n```javascript\nfunction getUser(id: 'user-123') -> { name: 'string', email: 'string' } {\n  let user = fetchUser({ id })  // might return { name, email, password, ... }\n  return { user }               // password automatically stripped\n}\n```\n\n### Array Methods with Lambdas\n\n```javascript\n// Map - transform each element\nitems.map((x) => x * 2)\nitems.map((x) => {\n  let doubled = x * 2\n  return doubled\n})\n\n// Filter - keep elements matching condition\nitems.filter((x) => x > 5)\nitems.filter((x) => x % 2 == 0)\n\n// Find - get first matching element\nitems.find((x) => x.id == targetId)\nusers.find((u) => u.age >= 18)\n\n// Reduce - accumulate to single value\nitems.reduce((acc, x) => acc + x, 0)\nitems.reduce((sum, item) => sum + item.price, 0)\n\n// Other array operations\nitems.push(newItem) // Add to array\nstr.split(',') // Split string to array\nparts.join('-') // Join array to string\n```\n\nLambdas support closures - they can access variables from the outer scope:\n\n```javascript\nfunction processItems({ items, threshold }) {\n  let above = items.filter((x) => x >= threshold) // threshold from outer scope\n  let scaled = above.map((x) => x * threshold) // still accessible\n  return { scaled }\n}\n```\n\n## Unsupported Constructs\n\nThese JavaScript features are intentionally not supported:\n\n| Feature            | Reason                       | Alternative         |\n| ------------------ | ---------------------------- | ------------------- |\n| `class`            | Use functional composition   | Plain functions     |\n| `this`             | Implicit state is confusing  | Explicit parameters |\n| `new`              | Classes not supported        | Factory functions   |\n| `import/require`   | Atoms must be registered     | Register with VM    |\n| `async/await`      | Implicit async               | Just call functions |\n| `yield/generators` | Complex control flow         | Use `map`/`while`   |\n| `eval`             | Security (though VM is safe) | Use transpiler      |\n| `with`             | Deprecated                   | Explicit references |\n| `var`              | Scoping issues               | Use `let`           |\n\n## API Usage\n\n### transpile()\n\nFull transpilation with signature and metadata:\n\n```typescript\nimport { transpile } from 'tosijs-agent'\n\nconst { ast, signature, warnings } = transpile(`\n  function greet(name: 'World') {\n    let msg = template({ tmpl: 'Hello {{name}}!', vars: { name } })\n    return { msg }\n  }\n`)\n\nconsole.log(signature.parameters.name.type) // 'string'\nconsole.log(signature.parameters.name.required) // true\n```\n\n### ajs()\n\nConvenience function returning just the AST (works as both a function and tagged template literal):\n\n```typescript\nimport { ajs } from 'tosijs-agent'\n\nconst ast = ajs(`\n  function add(a: 5, b: 3) {\n    let sum = a + b\n    return { sum }\n  }\n`)\n\n// Execute with VM\nconst vm = new AgentVM()\nconst result = await vm.run(ast, { a: 5, b: 3 })\nconsole.log(result.result.sum) // 8\n```\n\n### agent\\`\\`\n\nTagged template for inline definitions:\n\n```typescript\nimport { agent } from 'tosijs-agent'\n\nconst searchAST = agent`\n  function search(query: 'example search', limit = 10) {\n    let results = storeSearch({ query, limit })\n    return { results }\n  }\n`\n```\n\n### getToolDefinitions()\n\nGenerate OpenAI-compatible tool schemas for LLM integration:\n\n```typescript\nimport { getToolDefinitions, transpile } from 'tosijs-agent'\n\nconst { signature } = transpile(source)\nconst tools = getToolDefinitions([signature])\n\n// Returns format compatible with OpenAI/Anthropic tool calling:\n// [{\n//   type: 'function',\n//   function: {\n//     name: 'search',\n//     description: 'Search the knowledge base',\n//     parameters: { type: 'object', properties: {...}, required: [...] }\n//   }\n// }]\n```\n\n## Error Handling\n\n### Monadic Error Flow\n\nAgent99 uses monadic error flow - when an atom fails, the error becomes a value that propagates through the pipeline:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  // error is an AgentError with:\n  // - message: string - the error message\n  // - op: string - the atom that failed\n  // - cause?: Error - the original exception\n  console.log(`Error in ${error.op}: ${error.message}`)\n} else {\n  // Success - use result\n  console.log(result)\n}\n```\n\n### Checking for Errors\n\n```typescript\nimport { isAgentError } from 'tosijs-agent'\n\nconst { result, error } = await vm.run(ast, args)\n\nif (isAgentError(result)) {\n  // result itself is the error (when error occurs before return)\n}\n```\n\n### Recovery with try/catch\n\nUse `try/catch` in your AJS code to handle errors gracefully:\n\n```javascript\nfunction resilientAgent({ query }) {\n  let result = null\n\n  try {\n    result = riskyOperation({ query })\n  } catch (e) {\n    // e contains the error message\n    result = safeDefault({ error: e })\n  }\n\n  return { result }\n}\n```\n\n### Triggering Errors with Error()\n\nUse the `Error()` built-in to trigger monadic error flow from your AJS code:\n\n```javascript\nfunction validateInput({ value }) {\n  if (value < 0) {\n    Error('Value must be non-negative')\n    // Execution stops here - subsequent code is skipped\n  }\n\n  return { validated: value }\n}\n```\n\nWhen `Error()` is called:\n\n- The error message is stored in the context\n- Subsequent operations are skipped (monadic error flow)\n- The error can be caught with `try/catch` or returned to the caller\n\n```javascript\nfunction safeDivide({ a, b }) {\n  if (b === 0) {\n    Error('Division by zero')\n  }\n  return { result: a / b }\n}\n\nfunction calculate({ x, y }) {\n  let result = null\n\n  try {\n    result = safeDivide({ a: x, b: y })\n  } catch (e) {\n    result = { result: 0, error: e }\n  }\n\n  return result\n}\n```\n\n### Why No `throw` Statement?\n\nAJS intentionally does not support the `throw` statement. Instead, use `Error()`:\n\n```javascript\n// DON'T DO THIS - throw is not supported:\nif (invalid) {\n  throw new Error('Something went wrong') // Transpiler error!\n}\n\n// DO THIS INSTEAD:\nif (invalid) {\n  Error('Something went wrong') // Triggers monadic error flow\n}\n```\n\nThe `throw` keyword will show as an error in your editor (red underline) and the transpiler will provide a helpful error message pointing you to use `Error()` instead.\n\n## Gotchas and Common Pitfalls\n\n### Unavailable JavaScript Features\n\nThese common JavaScript APIs are **not available** in AJS. The transpiler will catch these and provide helpful error messages:\n\n| Feature          | Error Message              | Alternative                            |\n| ---------------- | -------------------------- | -------------------------------------- |\n| `setTimeout`     | Use the `delay` atom       | `delay({ ms: 1000 })`                  |\n| `setInterval`    | Use while loops with delay | `while (cond) { delay({ ms: 1000 }) }` |\n| `fetch`          | Use the `httpFetch` atom   | `httpFetch({ url })`                   |\n| `RegExp`         | Use string methods         | `str.match()`, `str.replace()`         |\n| `Promise`        | Implicit async             | All calls are automatically awaited    |\n| `Map`            | Use plain objects          | `{ key: value }`                       |\n| `require/import` | Register atoms with VM     | `new AgentVM({ customAtom })`          |\n\n### The `new` Keyword\n\nThe `new` keyword is not supported. AJS provides factory functions instead:\n\n```javascript\n// DON'T DO THIS - the transpiler catches these with helpful errors:\nlet date = new Date() // Error: Use Date() or Date('2024-01-15') instead\nlet set = new Set([1, 2]) // Error: Use Set([items]) instead\nlet arr = new Array(5) // Error: Use array literals like [1, 2, 3] instead\n\n// DO THIS INSTEAD - no 'new' needed:\nlet date = Date() // Current date/time\nlet date2 = Date('2024-06-15') // Specific date\nlet set = Set([1, 2, 3]) // Create a Set\nlet arr = [1, 2, 3, 4, 5] // Array literal\n```\n\nSee [Set and Date Builtins](#set-and-date-builtins) for full documentation.\n\n### No `this` or Classes\n\nAJS is purely functional. There's no `this`, no classes, no prototypes:\n\n```javascript\n// DON'T DO THIS\nclass Agent {\n  constructor(name) {\n    this.name = name\n  }\n}\n\n// DO THIS INSTEAD\nfunction createAgent(name: 'Agent Smith') {\n  return { name }\n}\n```\n\n### Equality Semantics\n\nAJS uses JavaScript's standard equality (`==` and `===`). There is no special deep equality:\n\n```javascript\nlet a = { x: 1 }\nlet b = { x: 1 }\nlet same = a == b // false (reference comparison)\n\n// For deep comparison, use JSON.stringify or write a comparison function\nlet equal = JSON.stringify(a) == JSON.stringify(b) // true\n```\n\n### Optional Chaining (`?.`)\n\nOptional chaining is fully supported for safe property access:\n\n```javascript\nlet x = obj?.nested?.value // Returns null if any step is null/undefined\nlet result = user?.profile?.name\n\n// Works with method calls too\nlet len = items?.length\nlet upper = str?.toUpperCase()\n```\n\n**Note:** Nullish coalescing (`??`) is not yet supported. Use explicit checks:\n\n```javascript\nlet x = obj?.nested?.value\nif (x == null) {\n  x = 'default'\n}\n```\n\n### Atom Calls vs Built-in Methods\n\nAtoms use object parameter syntax, while built-ins use normal function syntax:\n\n```javascript\n// Atom call - object parameter\nlet result = search({ query: 'hello', limit: 10 })\n\n// Built-in method - normal parameters\nlet floor = Math.floor(3.7)\nlet upper = str.toUpperCase()\n```\n\n### Async Is Implicit\n\nAll atom calls are automatically awaited. Don't use `async/await`:\n\n```javascript\n// DON'T DO THIS\nasync function search(query) {\n  let result = await fetch(query) // Error: async/await not supported\n}\n\n// DO THIS INSTEAD\nfunction search(query: 'https://api.example.com') {\n  let result = httpFetch({ url: query }) // Automatically awaited\n  return { result }\n}\n```\n\n### Error Propagation\n\nErrors propagate monadically - if one step fails, subsequent steps are skipped:\n\n```javascript\nfunction pipeline(input: 'raw data') {\n  let a = stepOne({ input }) // If this fails...\n  let b = stepTwo({ data: a }) // ...this is skipped\n  let c = stepThree({ data: b }) // ...and this too\n  return { c } // Result contains the error\n}\n```\n\nUse `try/catch` to recover from expected errors:\n\n```javascript\nfunction resilient(input: 'user input') {\n  let result = null\n  try {\n    result = riskyStep({ input })\n  } catch (e) {\n    result = fallback({ error: e })\n  }\n  return { result }\n}\n```\n\n### Fuel Limits\n\nAll operations consume fuel. Complex operations may hit limits:\n\n```javascript\n// This might run out of fuel for large arrays\nfunction processLarge({ items }) {\n  let mapped = items.map((x) => complexOperation({ x }))\n  return { mapped }\n}\n\n// Run with higher fuel limit\nconst result = await vm.run(ast, args, { fuel: 10000 })\n```\n\n## Security Model\n\nAJS compiles to Agent99's JSON AST, which executes in a completely sandboxed VM:\n\n- **No file system access** - unless explicitly provided via atoms\n- **No network access** - unless explicitly provided via atoms\n- **No global state** - each execution is isolated\n- **Fuel-limited execution** - prevents infinite loops and runaway expressions\n- **Type-checked at runtime** - invalid operations fail safely\n- **Prototype access blocked** - `__proto__`, `constructor`, `prototype` are forbidden\n\nThe transpiler is permissive because security is enforced at the VM level, not the language level. Even if malicious code somehow made it through, the VM cannot execute dangerous operations unless atoms for those operations are registered.\n\n### Fuel System\n\nEvery operation consumes fuel. When fuel runs out, execution stops with an `Out of Fuel` error:\n\n```typescript\nconst result = await vm.run(ast, args, { fuel: 100 })\n// Limits total computation to prevent infinite loops\n```\n\nExpression evaluation also consumes fuel (0.01 per node), preventing deeply nested or recursive expressions from running unchecked.\n\n## Migration from TypedBuilder\n\nIf you have existing TypedBuilder code, here's how to convert:\n\n```typescript\n// Before: TypedBuilder\nconst ast = Agent.take()\n  .varsImport(['topic'])\n  .step({ op: 'search', query: 'topic', result: 'results' })\n  .if('results.length > 0', { results: 'results' }, (b) =>\n    b.step({ op: 'summarize', text: 'results', result: 'summary' })\n  )\n  .return({ properties: { results: {}, summary: {} } })\n  .toJSON()\n\n// After: AJS\nconst ast = ajs(`\n  function searchAgent(topic: 'climate change') {\n    let results = search({ query: topic })\n    if (results.length > 0) {\n      let summary = summarize({ text: results })\n    }\n    return { results, summary }\n  }\n`)\n```\n\n## Best Practices\n\n1. **Use descriptive JSDoc comments** - They become part of the function signature for LLM agents\n2. **Prefer explicit types** - Even though inference works, explicit types document intent\n3. **Keep functions small** - Each function should do one thing\n4. **Use meaningful variable names** - The VM state is inspectable during debugging\n5. **Return structured objects** - Makes output types clear and composable\n6. **Handle errors appropriately** - Use try/catch for expected failures, let others propagate\n7. **Set appropriate fuel limits** - Balance between allowing complex operations and preventing abuse\n",
    "title": "AJS (.ajs) - A Better JavaScript for AI Agents",
    "filename": "ajs.md",
    "path": "guides/ajs.md"
  },
  {
    "text": "# AJS LLM System Prompt\n\n> **Maintenance Note:** This prompt must be updated when [ajs.md](./ajs.md) changes.\n> Key areas to sync: type syntax, built-ins (Set/Date), control flow, and forbidden constructs.\n\nUse this system prompt when asking an LLM to generate AJS code.\n\n---\n\n## System Prompt\n\n````\nYou are an expert code generator for **AJS**, a specialized subset of JavaScript for AI Agents.\nAJS looks like JavaScript but has strict differences. You must adhere to these rules:\n\n### 1. SYNTAX & TYPES\n- **Types by Example:** Do NOT use TypeScript types (`x: string`). Use \"Example Types\" where the value implies the type.\n  - WRONG: `function search(query: string, limit?: number)`\n  - RIGHT: `function search(query: 'search term', limit = 10)`\n  - `name: 'value'` means REQUIRED string. `count: 5` means REQUIRED number. `name = 'value'` means OPTIONAL.\n  - For numbers, use a number literal: `function factorial(n: 5)` or `function add(a: 0, b: 0)`\n- **No Classes:** Do NOT use `class`, `new`, `this`, or `prototype`.\n- **No Async/Await:** Do NOT use `async` or `await`. All functions are implicitly asynchronous.\n  - WRONG: `let x = await fetch(...)`\n  - RIGHT: `let x = httpFetch({ url: '...' })`\n\n### 2. BUILT-INS & FACTORIES\n- **No `new` Keyword:** Never use `new`. Use factory functions.\n  - WRONG: `new Date()`, `new Set()`, `new Array()`\n  - RIGHT: `Date()`, `Set([1,2])`, `['a','b']`\n- **Date Objects:** `Date()` returns an **immutable** object.\n  - Months are 1-indexed (1=Jan, not 0=Jan).\n  - Methods like `.add({ days: 5 })` return a NEW Date object.\n  - Access components: `.year`, `.month`, `.day`, `.hours`, `.minutes`, `.seconds`\n  - Format: `.format('date')`, `.format('iso')`, `.format('YYYY-MM-DD')`\n- **Set Objects:** `Set([items])` returns an object with:\n  - Mutable: `.add(x)`, `.remove(x)`, `.clear()`\n  - Immutable algebra: `.union(other)`, `.intersection(other)`, `.diff(other)` - return NEW Sets\n  - Query: `.has(x)`, `.size`, `.toArray()`\n- **Optional Chaining:** Use `?.` for safe property access: `obj?.nested?.value`\n- **Schema Filtering:** `filter(data, schema)` strips extra properties:\n  - `filter({ a: 1, b: 2, extra: 3 }, { a: 0, b: 0 })` returns `{ a: 1, b: 2 }`\n  - Useful for sanitizing LLM outputs or API responses\n\n### 3. ATOMS VS. BUILT-INS\n- **Atoms (External Tools):** ALWAYS accept a single object argument.\n  - Pattern: `atomName({ param: value })`\n  - Examples: `search({ query: topic })`, `llmPredict({ system: '...', user: '...' })`\n  - **template atom:** `template({ tmpl: 'Hello, {{name}}!', vars: { name } })` - for string interpolation\n- **Built-ins (Math, JSON, String, Array):** Use standard JS syntax.\n  - `Math.max(1, 2)`, `JSON.parse(str)`, `str.split(',')`, `arr.map(x => x * 2)`\n\n### 4. ERROR HANDLING\n- Errors propagate automatically (Monadic flow). If one step fails, subsequent steps are skipped.\n- Only use `try/catch` if you need to recover from a failure and continue.\n\n### 5. FORBIDDEN CONSTRUCTS\nThese will cause transpile errors:\n- `async`, `await` - not needed, all calls are implicitly async\n- `new` - use factory functions instead\n- `class`, `this` - use plain functions and objects\n- `var` - use `let` instead\n- `import`, `require` - atoms must be registered with the VM\n- `console.log` - use trace capabilities if needed\n\n### EXAMPLES\n\n**Example 1: Search Agent**\n```javascript\nfunction researchAgent(topic: 'quantum computing') {\n  let searchResults = search({ query: topic, limit: 5 })\n  if (searchResults?.length == 0) {\n    return { error: 'No results found' }\n  }\n  let summary = summarize({ text: JSON.stringify(searchResults), length: 'short' })\n  return { summary }\n}\n```\n\n**Example 2: Factorial with while loop (number parameter)**\n```javascript\nfunction factorial(n: 5) {\n  let result = 1\n  let i = n\n  while (i > 1) {\n    result = result * i\n    i = i - 1\n  }\n  return { result }\n}\n```\n\n**Example 3: Greeting with template atom**\n```javascript\nfunction greet(name: 'World', greeting = 'Hello') {\n  let message = template({ tmpl: '{{greeting}}, {{name}}!', vars: { greeting, name } })\n  return { message }\n}\n```\n````\n\n```\n\n---\n\n## Self-Correction Loop\n\nWhen testing with local LLMs, implement error feedback:\n\n1. Run the LLM with this prompt\n2. If output contains `async`, `await`, `new`, `class`, or `this`, feed back:\n   > \"Error: You used '[keyword]'. AJS forbids '[keyword]'. [Alternative].\"\n3. The model typically fixes it on the second attempt\n\nExample corrections:\n- `new Date()` → \"Use `Date()` factory function instead\"\n- `await fetch()` → \"Remove `await`, use `httpFetch({ url })` - all calls are implicitly async\"\n- `class Agent` → \"Use plain functions, AJS is purely functional\"\n\n---\n\n## Compact Version (for context-limited models)\n\n```\n\nYou generate AJS code. Rules:\n\n1. Types by example: `fn(name: 'string', count = 10)` - colon=required, equals=optional\n2. NO: async/await, new, class, this, var, import\n3. Atoms use object args: `search({ query: x })`. Built-ins normal: `Math.max(1,2)`\n4. Factories: `Date()`, `Set([1,2])` - no `new` keyword\n5. Date is immutable, months 1-12. Set has .add/.remove (mutable) and .union/.diff (immutable)\n6. Use `?.` for optional chaining: `obj?.prop?.value`\n7. Use `filter(data, schema)` to strip extra properties from objects\n\n```\n\n```\n",
    "title": "AJS LLM System Prompt",
    "filename": "ajs-llm-prompt.md",
    "path": "guides/ajs-llm-prompt.md"
  },
  {
    "text": "# AJS Patterns\n\nThis document covers common patterns and workarounds for features not directly supported in AJS.\n\n## Table of Contents\n\n- [Parallel Execution](#parallel-execution)\n- [Retry with Backoff](#retry-with-backoff)\n- [Rate Limiting](#rate-limiting)\n- [Break/Continue](#breakcontinue)\n- [Switch Statements](#switch-statements)\n- [Error Handling Patterns](#error-handling-patterns)\n- [Expression Limitations](#expression-limitations)\n\n---\n\n## Parallel Execution\n\n**Status:** Not supported\n\nAJS executes sequentially by design. This is intentional for:\n\n- Predictable fuel consumption\n- Deterministic execution order\n- Simpler debugging and tracing\n\n**Workaround:** If you need parallel execution, orchestrate at the capability level:\n\n```javascript\n// Capability that handles parallelism\nconst parallelFetch = {\n  fetchAll: async (urls) => {\n    return Promise.all(urls.map((url) => fetch(url).then((r) => r.json())))\n  },\n}\n\n// AJS code calls the capability\nconst results = parallelFetch.fetchAll(urls)\n```\n\n**Future:** Parallel execution may be added as an explicit atom (e.g., `parallel([...steps])`) where fuel is consumed for the most expensive branch.\n\n---\n\n## Retry with Backoff\n\n**Status:** Manual pattern required\n\nAJS doesn't have built-in retry. Implement with a while loop:\n\n```javascript\nlet attempts = 0\nlet result = null\nlet success = false\n\nwhile (attempts < 3 && !success) {\n  attempts = attempts + 1\n\n  try {\n    result = fetch(url)\n    success = true\n  } catch (err) {\n    // Exponential backoff: 100ms, 200ms, 400ms\n    // Note: sleep is a capability, not built-in\n    if (attempts < 3) {\n      sleep(100 * Math.pow(2, attempts - 1))\n    }\n  }\n}\n\nif (!success) {\n  console.error('Failed after 3 attempts')\n}\nreturn result\n```\n\n**Note:** The `sleep` capability must be injected. AJS doesn't include timing primitives to keep the VM deterministic.\n\n---\n\n## Fetch Security\n\n**Status:** Capability responsibility\n\n### The Problem: Recursive Agent Attacks\n\nA malicious or buggy agent could use `fetch` to call other agent endpoints, creating:\n\n- **Amplification attacks** - One request triggers many downstream requests\n- **Ping-pong loops** - Two endpoints repeatedly calling each other\n- **Resource exhaustion** - Consuming compute/tokens across multiple services\n\nFuel budgets only protect the _current_ VM, not downstream services. SSRF protection blocks private IPs but not public agent endpoints.\n\n### The Solution: Capability-Level Enforcement\n\nSince agents are untrusted code, security must be enforced at the **capability layer**:\n\n1. **Depth tracking** - The fetch capability (not the agent) adds/increments an `X-Agent-Depth` header\n2. **Domain allowlist** - Fetch only works for explicitly allowed domains\n3. **Receiving endpoints** - Check depth headers and reject requests that are too deep\n\n```typescript\n// Host provides a secure fetch capability\ncapabilities: {\n  fetch: createSecureFetch({\n    allowedDomains: ['api.weather.com', 'api.github.com'],\n    maxDepth: 5,\n    currentDepth: requestDepth, // From incoming request header\n  })\n}\n```\n\nThe agent cannot bypass this because:\n\n- It only has access to the capability, not raw `fetch`\n- The capability is trusted code provided by the host\n- Headers are added automatically - the agent can't see or modify them\n\n### Why This Can't Be Solved in Agent Code\n\n- **Agent honors depth?** - A malicious agent would just not increment it\n- **Agent checks allowlist?** - A malicious agent would skip the check\n- **Request budget in agent?** - Agent could ignore or reset it\n\nThe **capability is the trust boundary**. Agent code is untrusted; capabilities are trusted code injected by the host.\n\n### Built-in Fetch Behavior\n\nThe default fetch atom:\n\n- Requires a domain allowlist OR restricts to localhost only\n- Automatically adds `X-Agent-Depth` header based on `ctx.context.requestDepth`\n- Rejects requests exceeding `MAX_AGENT_DEPTH` (default: 10)\n\nFor production, always provide a custom fetch capability with appropriate restrictions.\n\n---\n\n## Rate Limiting\n\n**Status:** Capability responsibility\n\nRate limiting should be implemented in the capability layer, not in AJS:\n\n```typescript\n// Inject a rate-limited fetch capability\nconst rateLimitedFetch = createRateLimitedFetch({\n  requestsPerSecond: 10,\n  burstSize: 5,\n})\n\nconst result = await runAgent(ast, {\n  capabilities: {\n    fetch: rateLimitedFetch,\n  },\n})\n```\n\n**Rationale:** Rate limits are deployment-specific. A sandboxed agent shouldn't control its own rate limits since that would allow circumvention.\n\n---\n\n## Break/Continue\n\n**Status:** Not supported\n\nUse conditional logic instead:\n\n```javascript\n// Instead of break:\nlet found = null\nlet i = 0\nwhile (i < items.length && found === null) {\n  if (items[i].matches) {\n    found = items[i]\n  }\n  i = i + 1\n}\n\n// Instead of continue (skip items):\nfor (const item of items) {\n  if (!item.shouldProcess) {\n    // Just don't do anything - effectively a continue\n  } else {\n    processItem(item)\n  }\n}\n\n// Or use filter to pre-process:\nconst toProcess = items.filter((item) => item.shouldProcess)\nfor (const item of toProcess) {\n  processItem(item)\n}\n```\n\n---\n\n## Switch Statements\n\n**Status:** Not supported\n\nUse chained if/else:\n\n```javascript\n// Instead of switch(action):\nlet result\nif (action === 'create') {\n  result = handleCreate(data)\n} else if (action === 'update') {\n  result = handleUpdate(data)\n} else if (action === 'delete') {\n  result = handleDelete(data)\n} else {\n  result = { error: 'Unknown action' }\n}\n\n// For many cases, consider a lookup object:\nconst handlers = {\n  create: () => handleCreate(data),\n  update: () => handleUpdate(data),\n  delete: () => handleDelete(data),\n}\nconst handler = handlers[action]\nif (handler) {\n  result = handler()\n} else {\n  result = { error: 'Unknown action' }\n}\n```\n\n---\n\n## Error Handling Patterns\n\n### Monadic Error Flow\n\nAJS uses monadic error handling. When an error occurs, subsequent atoms are skipped until a `try/catch` block handles it:\n\n```javascript\ntry {\n  const data = fetch(url) // If this fails...\n  const parsed = JSON.parse(data) // ...this is skipped\n  storeSet('data', parsed) // ...this is skipped too\n} catch (err) {\n  console.warn('Fetch failed, using cached data')\n  const cached = storeGet('data')\n  return cached ?? { fallback: true }\n}\n```\n\n### Graceful Degradation\n\nUse `try/catch` with fallbacks:\n\n```javascript\nlet result\n\ntry {\n  result = llmPredict(prompt, { model: 'gpt-4' })\n} catch (err) {\n  // Fall back to simpler model\n  try {\n    result = llmPredict(prompt, { model: 'gpt-3.5-turbo' })\n  } catch (err2) {\n    // Fall back to static response\n    result = \"I'm unable to process your request right now.\"\n  }\n}\n\nreturn result\n```\n\n### Error Aggregation\n\nCollect errors without stopping execution:\n\n```javascript\nconst errors = []\nconst results = []\n\nfor (const item of items) {\n  try {\n    const result = processItem(item)\n    results.push(result)\n  } catch (err) {\n    errors.push({ item: item.id, error: err.message })\n    // Continue processing - no re-throw\n  }\n}\n\nreturn {\n  results: results,\n  errors: errors,\n  success: errors.length === 0,\n}\n```\n\n---\n\n## Unsupported JavaScript Features\n\nThese JavaScript features are intentionally not supported:\n\n| Feature         | Reason                         | Alternative           |\n| --------------- | ------------------------------ | --------------------- |\n| `async/await`   | All atoms are already async    | Direct calls work     |\n| `class`         | OOP not needed for agent logic | Use plain objects     |\n| `this`          | No object context              | Pass data explicitly  |\n| `new`           | No constructors                | Use factory functions |\n| `import/export` | Single-file execution          | Use capabilities      |\n| `eval`          | Security                       | N/A                   |\n| `throw`         | Use monadic errors             | `console.error()`     |\n| `typeof`        | Limited runtime type info      | Use Schema validation |\n| `instanceof`    | No classes                     | Use duck typing       |\n\n---\n\n## Performance Patterns\n\n### Memoization\n\nUse the built-in `memoize` atom for expensive operations:\n\n```javascript\n// Builder API\nAgent.take().memoize(\n  (b) => b.llmPredict({ prompt: expensivePrompt }).as('result'),\n  'expensive-key'\n)\n\n// Results are cached by key within the execution\n```\n\n### Caching\n\nUse `cache` atom with TTL for persistence across executions:\n\n```javascript\n// Cache for 1 hour\nconst result = cache('weather-' + city, 3600000, () => {\n  return fetch('https://api.weather.com/' + city)\n})\n```\n\n### Fuel Budgeting\n\nMonitor and limit computation:\n\n```javascript\n// Check remaining fuel before expensive operation\nif (fuel.current < 100) {\n  console.warn('Low fuel, using cached result')\n  return storeGet('cached-result')\n}\n\n// Proceed with expensive operation\nconst result = complexComputation()\n```\n\n---\n\n## Testing Patterns\n\n### Mock Capabilities\n\n```typescript\nimport {\n  createMockStore,\n  createMockLLM,\n  createCapabilities,\n} from 'tosijs-agent/test-utils'\n\nconst caps = createCapabilities({\n  store: createMockStore({ key: 'value' }),\n  llm: createMockLLM('mocked response'),\n})\n\nconst result = await runAgent(ast, { capabilities: caps })\n```\n\n### Snapshot Testing\n\n```typescript\nconst ast = ajs`\n  const x = 1 + 2\n  return x\n`\n\n// Snapshot the AST for regression testing\nexpect(ast).toMatchSnapshot()\n```\n\n### Trace Inspection\n\n```typescript\nconst result = await runAgent(ast, {\n  trace: true,\n  capabilities: caps,\n})\n\n// Inspect execution trace\nexpect(result.trace).toContainEqual(expect.objectContaining({ op: 'storeGet' }))\n```\n\n---\n\n## Expression Limitations\n\nSome JavaScript expressions have limitations in AJS due to the compilation model.\n\n### Template Literals in Nested Expressions\n\nTemplate literals work at statement level but not inside other expressions:\n\n```javascript\n// Works - statement level\nconst greeting = `Hello, ${name}!`\n\n// Does NOT work - nested in object\nconst obj = { msg: `Hello, ${name}!` } // Error\n\n// Workaround - assign first\nconst msg = `Hello, ${name}!`\nconst obj = { msg: msg } // Works\n```\n\n### Computed Member Access\n\nDynamic property access with variables is not supported:\n\n```javascript\n// Works - literal index\nconst first = items[0]\nconst name = user.name\n\n// Does NOT work - variable index\nconst key = 'name'\nconst value = obj[key] // Error\n\n// Workaround - use Object.entries or restructure\nconst entries = Object.entries(obj)\nconst found = entries.find((e) => e[0] === key)\nconst value = found ? found[1] : null\n```\n\n### Atom Calls in Expressions\n\nAtom/function calls that produce side effects cannot be embedded in expressions:\n\n```javascript\n// Does NOT work - call inside expression\nconst result = items.map((x) => fetch(url + x)) // Error\n\n// Workaround - use explicit loop\nconst results = []\nfor (const x of items) {\n  const res = fetch(url + x)\n  results.push(res)\n}\n```\n\nThese limitations exist because AJS compiles to a JSON AST that executes step-by-step. Complex nested expressions would require runtime evaluation that could bypass fuel tracking and capability checks.\n",
    "title": "AJS Patterns",
    "filename": "patterns.md",
    "path": "guides/patterns.md"
  },
  {
    "text": "# AJS: The Guest Language\n\n**Safe eval for the cloud. Code that travels to data.**\n\nAJS (AsyncJS) is a JavaScript subset that compiles to portable JSON AST. It's the **payload** that runs inside [TJS hosts](./ABOUT-TJS.md)—sandboxed, metered, and safe to execute from any source.\n\n---\n\n## The Architecture: Browser Model for the Cloud\n\nWe separate **Host** (infrastructure you deploy once) from **Guest** (logic that ships continuously).\n\n| | **TJS (Host)** | **AJS (Guest)** |\n|---|---|---|\n| **Role** | Defines the physics—capabilities, resources, safety | The portable logic payload |\n| **You write** | Your service layer, frontend, capabilities | Agents, workflows, LLM-generated code |\n| **Deploys** | Once, then evolves | Continuously, as data |\n| **Trust level** | Trusted code you control | Untrusted code from anywhere |\n\n**Together:** Deploy TJS once to create a secure, high-performance Universal Endpoint. Ship AJS continuously to execute logic where the data lives.\n\n**See also:** [TJS Documentation](./ABOUT-TJS.md) for the Host language.\n\n---\n\n## Why AJS is the Perfect Payload\n\n### 1. A Practical Solution to the Halting Problem\n\nYou can't know if arbitrary code will terminate. But you can **bound** it:\n\n```typescript\nconst result = await vm.run(agent, args, { \n  fuel: 1000,      // CPU budget\n  timeoutMs: 5000  // Wall-clock limit\n})\n\nif (result.fuelExhausted) {\n  // Agent tried to run forever—stopped safely\n}\n```\n\n- **Fuel metering:** Every operation costs fuel. Loops can't run forever.\n- **Proportional charging:** Large allocations cost more. Memory bombs exhaust fuel first.\n- **Timeout enforcement:** Slow I/O can't hang the host.\n\n**The CTO pitch:** \"This won't hang your server.\"\n\n### 2. Small Enough for LLMs\n\nAJS syntax is simple enough for **4B parameter models** to generate correctly:\n\n```javascript\nfunction searchAndSummarize({ query }) {\n  let results = httpFetch({ url: `https://api.example.com/search?q=${query}` })\n  let summary = llmPredict({ \n    prompt: `Summarize these results: ${JSON.stringify(results)}` \n  })\n  return { query, summary }\n}\n```\n\n- **No closures, classes, or prototypes:** Less to hallucinate\n- **Familiar syntax:** JavaScript developers read it instantly\n- **JSON AST:** LLMs can generate the AST directly if needed\n\n**The AI pitch:** \"It fits in the context window and the model doesn't hallucinate syntax.\"\n\n### 3. Capability-Based Security\n\nThe VM starts with **zero capabilities**. The host grants exactly what each agent needs:\n\n```typescript\n// Host decides what this agent can do\nconst capabilities = {\n  fetch: createFetchCapability({ \n    allowedHosts: ['api.example.com']  // No SSRF\n  }),\n  store: createReadOnlyStore(),         // Can read, can't write\n  // No LLM capability—this agent can't call AI\n}\n\nawait vm.run(agent, args, { capabilities })\n```\n\n- **Zero trust by default:** No network, no storage, no filesystem\n- **Explicit grants:** Audit trail of what each agent can access\n- **Scoped access:** Read-only store, allowlisted URLs, rate limits\n\n### 4. JSON is the Program\n\nAJS compiles to JSON AST. The code **is** data:\n\n```json\n{\n  \"$seq\": [\n    { \"$op\": \"httpFetch\", \"url\": { \"$expr\": \"template\", \"tmpl\": \"...\" } },\n    { \"$op\": \"varSet\", \"name\": \"results\", \"value\": { \"$expr\": \"ident\", \"name\": \"fetched\" } },\n    { \"$op\": \"return\", \"value\": { \"$expr\": \"ident\", \"name\": \"results\" } }\n  ]\n}\n```\n\n- **Portable:** Send it anywhere, execute it anywhere\n- **Inspectable:** Audit what code does before running it\n- **Versionable:** Store agents in databases, diff them, roll back\n- **Transformable:** Programmatically modify agents\n\n---\n\n## The Universal Endpoint\n\nOne endpoint. Any agent. Zero deployment.\n\n```typescript\n// TJS host: deployed once\napp.post('/execute', async (req, res) => {\n  const { agent, args, apiKey } = req.body\n  \n  // Validate and parse the agent\n  const ast = ajs(agent)\n  \n  // Get capabilities for this API key\n  const capabilities = getCapabilitiesForKey(apiKey)\n  \n  // Execute with limits\n  const result = await vm.run(ast, args, {\n    fuel: 1000,\n    timeoutMs: 5000,\n    capabilities\n  })\n  \n  res.json(result)\n})\n```\n\n**What this replaces:**\n- Deploying a new service for each workflow\n- Building bespoke APIs for each integration\n- Managing containers for each agent\n- Cold start latency for serverless functions\n\n**What you get:**\n- One hot endpoint that runs any valid agent\n- Per-request resource limits\n- Per-key capability scoping\n- Full execution tracing\n\n---\n\n## For Different Audiences\n\n### For the CEO\n\n**Turn infrastructure into a platform.**\n\n- **Zero-deploy agents:** Ship new logic without touching infrastructure\n- **Vendor flexibility:** Agents are JSON—run them anywhere\n- **Cost control:** Fuel budgets cap compute per request\n- **AI-native:** LLMs generate agents at runtime\n\n### For the CTO\n\n**Safe execution of untrusted code at scale.**\n\n- **Bounded execution:** Fuel + timeout = predictable resource usage\n- **Capability-based security:** Explicit grants, not ambient authority\n- **Horizontal scaling:** Stateless VM, inject capabilities\n- **Minimal supply chain:** 2 deps, zero transitive\n\n### For the Security Consultant\n\n**Defense in depth.**\n\n- **Resource controls:** Fuel metering, proportional charging, timeouts\n- **Sandboxing:** Zero capabilities by default, prototype blocking, no eval\n- **SSRF protection:** URL allowlists, blocked private IPs\n- **Tested threats:** 650+ tests, 98% coverage on runtime\n\n### For the Data Scientist\n\n**AI agent orchestration.**\n\n- **RAG pipelines as JSON:** Portable, inspectable, versionable\n- **Structured outputs:** Schema validation for LLM responses\n- **Vector search:** Built-in cosine similarity, 10K vectors in ~15ms\n- **Agent composition:** Agents calling agents, depth-bounded\n\n---\n\n## Security Model\n\n### What AJS Prevents\n\n| Threat | Defense |\n|--------|---------|\n| Infinite loops | Fuel exhaustion |\n| Memory bombs | Proportional fuel charging |\n| SSRF | URL allowlists |\n| Prototype pollution | Blocked property access |\n| Code injection | AST nodes, not eval |\n| ReDoS | Suspicious regex rejection |\n\n### What the Host Controls\n\n| Resource | Mechanism |\n|----------|-----------|\n| CPU | Fuel budget |\n| Memory | Proportional charging |\n| Time | Timeout enforcement |\n| Network | Capability allowlists |\n| Storage | Capability scoping |\n| Recursion | Depth protocol |\n\n### Attack Surface\n\n- Custom atoms are **trusted code**—host responsibility\n- Capabilities determine exposure—misconfigured fetch is still dangerous\n- The VM prevents malicious **agents**, not malicious **atom implementations**\n\n---\n\n## Performance\n\n- **100 agents in ~6ms** (torture test)\n- **~0.01 fuel per expression**\n- **Proportional memory charging** prevents runaway allocations\n\nAJS is interpreted (JSON AST), so it's slower than native JS. But:\n- Execution is predictable and bounded\n- I/O dominates most agent workloads\n- Tracing is free (built into the VM)\n\nFor compute-heavy operations, use TJS with `wasm {}` blocks in capabilities.\n\n---\n\n## The Pitch\n\n> **Ship code to data instead of shipping data to code.**\n\nAJS is the \"practical solution to the halting problem\" that makes Universal Endpoints possible:\n\n1. **Parse** user-submitted / LLM-generated code safely\n2. **Sandbox** it with capability-based security\n3. **Meter** it with fuel and timeouts\n4. **Execute** it where the data lives\n\n**The result:** One endpoint replaces infinite bespoke APIs. Deploy infrastructure once, ship agents forever.\n\n---\n\n## Quick Links\n\n- [TJS: The Host Language](./ABOUT-TJS.md)\n- [Technical Documentation](./CONTEXT.md)\n- [Playground](./demo/)\n- [GitHub](https://github.com/tonioloewald/tosijs-agent)\n",
    "title": "AJS: The Guest Language",
    "filename": "ABOUT-AJS.md",
    "path": "ABOUT-AJS.md"
  },
  {
    "text": "# CLAUDE.md\n\nThis file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.\n\n## Project Overview\n\n**tosijs-agent** is a type-safe virtual machine (~33KB) for safe execution of untrusted code in any JavaScript environment. It compiles logic chains and AI agents to JSON-serializable ASTs that run sandboxed with fuel (gas) limits.\n\nKey concept: Code travels to data (rather than shipping data to code). Agents are defined as data, not deployed code.\n\n## Common Commands\n\n```bash\n# Development\nnpm run format              # ESLint fix + Prettier\nnpm run test:fast           # Core tests (skips LLM & benchmarks)\nnpm run make                # Full build (clean, format, grammars, tsc, esbuild)\nnpm run dev                 # Development server with file watcher\n\n# Testing\nbun test                    # Full test suite\nbun test src/path/to/file.test.ts  # Single test file\nbun test --test-name-pattern \"pattern\"  # Run tests matching pattern\nSKIP_LLM_TESTS=1 bun test   # Skip LLM integration tests\nbun test --coverage         # With coverage report\n\n# CLI tools\nbun src/cli/tjs.ts check <file>   # Parse and type check TJS file\nbun src/cli/tjs.ts run <file>     # Transpile and execute\nbun src/cli/tjs.ts types <file>   # Output type metadata as JSON\nbun src/cli/tjs.ts emit <file>    # Output transpiled JavaScript\n\n# Other\nnpm run test:llm            # LM Studio integration tests\nnpm run bench               # Vector search benchmarks\nnpm run show-size           # Show gzipped bundle size\n```\n\n## Architecture\n\n### Two-Layer Design\n\n1. **Builder Layer** (`src/builder.ts`): Fluent API that constructs AST nodes. Contains no execution logic.\n2. **Runtime Layer** (`src/vm/runtime.ts`): Executes AST nodes. Contains all atom implementations (~2700 lines, security-critical).\n\n### Key Source Files\n\n- `src/index.ts` - Main entry, re-exports everything\n- `src/vm/runtime.ts` - All atom implementations, expression evaluation, fuel charging (~2900 lines, security-critical)\n- `src/vm/vm.ts` - AgentVM class (~226 lines)\n- `src/vm/atoms/batteries.ts` - Battery atoms (vector search, LLM, store operations)\n- `src/builder.ts` - TypedBuilder fluent API (~19KB)\n- `src/lang/parser.ts` - TJS parser with colon shorthand, unsafe markers, return type extraction\n- `src/lang/emitters/ast.ts` - Emits Agent99 AST from parsed source\n- `src/lang/emitters/js.ts` - Emits JavaScript with `__tjs` metadata\n- `src/lang/inference.ts` - Type inference from example values\n- `src/batteries/` - LM Studio integration (lazy init, model audit, vector search)\n- `src/use-cases/` - Integration tests and real-world examples (27 test files)\n- `src/cli/tjs.ts` - CLI tool for check/run/types/emit commands\n\n### Core APIs\n\n```typescript\n// Language\najs`...`                    // Parse AJS to AST\ntjs`...`                    // Parse TypeScript variant with type metadata\ntranspile(source, options)  // Full transpilation with signature extraction\ncreateAgent(source, vm)     // Creates callable agent\n\n// VM\nconst vm = new AgentVM(customAtoms)\nawait vm.run(ast, args, { fuel, capabilities, timeoutMs, trace })\n\n// Builder\nAgent.take(schema).varSet(...).httpFetch(...).return(schema)\nvm.Agent  // Builder with custom atoms included\n```\n\n### Security Model\n\n- **Capability-based**: VM has zero IO by default; inject `fetch`, `store`, `llm` via capabilities\n- **Fuel metering**: Every atom has a cost; execution stops when fuel exhausted\n- **Timeout enforcement**: Default `fuel × 10ms`; explicit `timeoutMs` overrides\n- **Monadic errors**: Errors wrapped in `AgentError`, not thrown (prevents exception exploits)\n- **Expression sandboxing**: ExprNode AST evaluation, blocked prototype access\n\n### Expression Evaluation\n\nExpressions use AST nodes (`$expr`), not strings:\n\n```typescript\n{ $expr: 'binary', op: '+', left: {...}, right: {...} }\n{ $expr: 'ident', name: 'varName' }\n{ $expr: 'member', object: {...}, property: 'foo' }\n```\n\nEach node costs 0.01 fuel. Forbidden: function calls, `new`, `this`, `__proto__`, `constructor`.\n\n## Testing Strategy\n\n- Unit tests alongside source files (`*.test.ts`)\n- Integration tests in `src/use-cases/` (RAG, orchestration, malicious actors)\n- Security tests in `src/use-cases/malicious-actor.test.ts`\n- Language tests in `src/lang/lang.test.ts` (~46KB comprehensive)\n\nCoverage targets: 98% lines on `src/vm/runtime.ts` (security-critical), 80%+ overall.\n\n## Key Patterns\n\n### Adding a New Atom\n\n1. Define with `defineAtom(opCode, inputSchema, outputSchema, implementation, { cost, timeoutMs, docs })`\n2. Add to `src/vm/atoms/` and export from `src/vm/atoms/index.ts`\n3. Add tests\n4. Run `npm run test:fast`\n\n**Atom implementation notes:**\n\n- `cost` can be static number or dynamic: `(input, ctx) => number`\n- `timeoutMs` defaults to 1000ms; use `0` for no timeout (e.g., `seq`)\n- Atoms are always async; fuel deduction is automatic in the `exec` wrapper\n\n### Debugging Agents\n\nEnable tracing: `vm.run(ast, args, { trace: true })` returns `TraceEvent[]` with execution path, fuel consumption, and state changes.\n\n### Custom Atoms Must\n\n- Be non-blocking (no synchronous CPU-heavy work)\n- Respect `ctx.signal` for cancellation\n- Access IO only via `ctx.capabilities`\n\n### Value Resolution\n\nThe `resolveValue()` function handles multiple input patterns:\n\n- `{ $kind: 'arg', path: 'varName' }` → lookup in `ctx.args`\n- `{ $expr: ... }` → evaluate ExprNode via `evaluateExpr()`\n- String with dots `'obj.foo.bar'` → traverse state with forbidden property checks\n- Bare strings → lookup in state, else return literal\n\n### Monadic Error Flow\n\nWhen `ctx.error` is set, subsequent atoms in a `seq` skip execution. Errors are wrapped in `AgentError`, not thrown. This prevents exception-based exploits.\n\n### TJS Parser Syntax Extensions\n\nTJS extends JavaScript with type annotations that survive to runtime.\n\n#### Function Parameters\n\n```typescript\n// Required param with example value (colon shorthand)\nfunction greet(name: 'Alice') { }        // name is required, type inferred as string\n\n// Optional param with default\nfunction greet(name = 'Alice') { }       // name is optional, defaults to 'Alice'\n\n// Object parameter with shape\nfunction createUser(user: { name: '', age: 0 }) { }\n\n// Nullable type\nfunction find(id: 0 || null) { }         // number or null\n\n// Optional TS-style\nfunction greet(name?: '') { }            // same as name = ''\n```\n\n#### Return Types\n\n```typescript\n// Return type annotation (arrow syntax)\nfunction add(a: 0, b: 0) -> 0 { return a + b }\n\n// Object return type\nfunction getUser(id: 0) -> { name: '', age: 0 } { ... }\n```\n\n#### Safety Markers\n\n```typescript\n// Unsafe function (skips runtime validation)\nfunction fastAdd(! a: 0, b: 0) { return a + b }\n\n// Safe function (explicit validation)\nfunction safeAdd(? a: 0, b: 0) { return a + b }\n\n// Unsafe block\nunsafe {\n  // All calls in here skip validation\n  fastPath(data)\n}\n```\n\n#### Type Declarations\n\n```typescript\n// Simple type from example\nType Name 'Alice'\n\n// Type with description and example\nType User {\n  description: 'a user object'\n  example: { name: '', age: 0 }\n}\n\n// Type with predicate (auto-generates type guard from example)\nType EvenNumber {\n  description: 'an even number'\n  example: 2\n  predicate(x) { return x % 2 === 0 }\n}\n```\n\n#### Generic Declarations\n\n```typescript\n// Simple generic\nGeneric Box<T> {\n  description: 'a boxed value'\n  predicate(x, T) { \n    return typeof x === 'object' && x !== null && 'value' in x && T(x.value) \n  }\n}\n\n// Generic with default type parameter\nGeneric Container<T, U = ''> {\n  description: 'container with label'\n  predicate(obj, T, U) { \n    return T(obj.item) && U(obj.label) \n  }\n}\n```\n\n#### Bare Assignments\n\n```typescript\n// Uppercase identifiers auto-get const\nFoo = Type('test', 'example')    // becomes: const Foo = Type(...)\nMyConfig = { debug: true }       // becomes: const MyConfig = { ... }\n```\n\n#### Module Safety Directive\n\n```typescript\n// At top of file - sets default validation level\nsafety none     // No validation (metadata only)\nsafety inputs   // Validate function inputs (default)\nsafety all      // Validate everything (debug mode)\n```\n\n## Dependencies\n\nRuntime (shipped): `acorn` (JS parser, ~30KB), `tosijs-schema` (validation, ~5KB). Both have zero transitive dependencies.\n\n## Forbidden Properties (Security)\n\nThe following property names are blocked in expression evaluation to prevent prototype pollution:\n\n- `__proto__`, `constructor`, `prototype`\n\nThese are hardcoded in `runtime.ts` and checked during member access in `evaluateExpr()`.\n\n## Batteries System\n\nThe batteries (`src/batteries/`) provide zero-config local AI development:\n\n- **Lazy initialization**: First import audits LM Studio models (cached 24 hours)\n- **HTTPS detection**: Blocks local LLM calls from HTTPS contexts (security)\n- **Capabilities interface**: `fetch`, `store` (KV + vector), `llmBattery` (predict/embed)\n\nRegister battery atoms: `new AgentVM(batteryAtoms)` then pass `{ capabilities: batteries }` to `run()`.\n",
    "title": "CLAUDE.md",
    "filename": "CLAUDE.md",
    "path": "CLAUDE.md"
  },
  {
    "text": "# Context: Working with `tosijs-schema`\n\nYou are an expert in `tosijs-schema`, a lightweight, schema-first, LLM-native replacement for Zod. Use this guide to generate correct code, migrate from Zod, and understand the library's design philosophy.\n\n## 1. Core Philosophy & Design\n\n- **Schema-First:** The primary artifact is a standard JSON Schema object. `tosijs-schema` is a fluent API to generate these schemas.\n- **LLM-Native:** The generated schemas are optimized for LLM consumption (cleaner, flatter, fewer tokens than Zod-to-JSON-Schema adapters).\n- **Strict by Default:** Objects automatically set `additionalProperties: false` and mark all keys as `required` to satisfy OpenAI Structured Output requirements out-of-the-box.\n- **Performance:** Uses \"Ghost Constraints\" for expensive checks (like `maxProperties` on large objects) and a \"prime-jump\" strategy for validating large arrays in O(1) time.\n- **Validation Separation:** Separates \"Is this valid?\" (fast, boolean return) from \"Why is it invalid?\" (detailed debugging).\n\n## 2. Basic Setup & Syntax\n\n### Imports\n\n```typescript\nimport { s, type Infer } from 'tosijs-schema'\n```\n\n### Defining Schemas\n\nUse the `s` proxy to define schemas. The syntax is property-based and chainable.\n\n```typescript\nconst UserSchema = s.object({\n  id: s.string.uuid, // Format shorthand\n  username: s.string.min(3).max(20), // Chainable constraints\n  email: s.email, // First-class email type (no .string wrapper needed)\n  age: s.integer.min(0).optional, // Optional integer\n  tags: s.array(s.string).min(1), // Array with constraints\n  role: s.enum(['admin', 'user']), // Enums\n  meta: s.record(s.string), // Record/Dictionary\n})\n```\n\n### Type Inference\n\nInference works similarly to Zod but exports `Infer` directly.\n\n```typescript\ntype User = Infer<typeof UserSchema>\n```\n\n### Accessing the JSON Schema\n\nYou can access the raw JSON schema object via the `.schema` property.\n\n```typescript\nconsole.log(UserSchema.schema)\n// Outputs standard JSON Schema object: { type: \"object\", properties: { ... } }\n```\n\n## 3. Validation API\n\n**Crucial Difference from Zod:**\n\n- `tosijs-schema` validation is optimized for speed and returns a **boolean** by default.\n- It does **not** throw errors or return a parsed object like Zod's `.parse()`.\n\n```typescript\nconst data = { ... };\n\n// Fast validation (returns true/false)\nif (UserSchema.validate(data)) {\n  // logic here\n} else {\n  // Handle invalid data\n}\n```\n\n## 4. Migration Guide (Zod vs. tosijs-schema)\n\n| Feature         | Zod (`z`)                  | tosijs-schema (`s`)                      |\n| --------------- | -------------------------- | ---------------------------------------- |\n| **String**      | `z.string()`               | `s.string`                               |\n| **Email**       | `z.string().email()`       | `s.email` (First-class citizen)          |\n| **UUID**        | `z.string().uuid()`        | `s.string.uuid` or `s.uuid`              |\n| **Optional**    | `schema.optional()`        | `schema.optional` (Property, not method) |\n| **Objects**     | `z.object({...})`          | `s.object({...})`                        |\n| **Strict Mode** | `z.object({...}).strict()` | **Default** (No method needed)           |\n| **Arrays**      | `z.array(schema)`          | `s.array(schema)`                        |\n| **Enums**       | `z.enum(['a', 'b'])`       | `s.enum(['a', 'b'])`                     |\n| **Unions**      | `z.union([a, b])`          | `s.union([a, b])`                        |\n| **Inference**   | `z.infer<typeof T>`        | `Infer<typeof T>`                        |\n| **Metadata**    | `.describe(\"...\")`         | `.describe(\"...\")` / `.title(\"...\")`     |\n\n## 5. Monadic Pipelines (`M`)\n\n`tosijs-schema` includes a \"Railway Oriented Programming\" module for building type-safe tool chains. This is especially useful for **AI Agents**, ensuring that hallucinations or bad data are caught immediately at the source (Input vs Output) rather than cascading.\n\n### 1. Guarded Functions (`M.func`)\n\nCreate functions that enforce schemas on both input and output.\n\n```typescript\nimport { M, s } from 'tosijs-schema'\n\n// M.func(InputSchema, OutputSchema, Implementation)\nconst getSize = M.func(s.string, s.number, (str) => {\n  return str.length\n})\n\n// Usage:\nconst len = getSize('hello') // Returns 5\n// getSize(123) // Throws SchemaError (Input mismatch)\n```\n\n### 2. Execution Contexts (`new M`)\n\nChain multiple functions together. The execution context handles error propagation automatically.\n\n```typescript\nconst pipeline = new M({\n  getSize,\n  isEven: M.func(s.number, s.boolean, (n) => n % 2 === 0),\n})\n\nconst result = pipeline\n  .getSize('hello') // Output: 5\n  .isEven() // Input: 5 -> Output: false\n  .result() // Returns false | Error\n\n// If any step fails schema validation, .result() returns the specific error.\n```\n\n## 6. Advanced Features\n\n### Ghost Constraints\n\nConstraints that are computationally expensive (O(N)) are documented in the schema but skipped by the runtime validator for performance (O(1)).\n\n- **Example:** `.max(n)` on Objects/Records.\n- `minProperties` is strictly validated.\n- `maxProperties` is a \"Ghost\" constraint (documentation only).\n\n### Metadata & LLM Optimization\n\nUse metadata methods to enrich schemas for LLMs or OpenAPI docs without affecting runtime validation.\n\n```typescript\nconst ApiKey = s.string\n  .min(32)\n  .describe(\"The user's secret API key\") // standard JSON schema \"description\"\n  .title('API Key')\n  .default('sk-...')\n```\n\n### Date Handling\n\n`tosijs-schema` treats dates as strings with format validation, aligning with JSON transport.\n\n```typescript\nconst Timestamp = s.string.datetime // Validates ISO string format\n```\n\n## 6. Common Patterns & Gotchas\n\n1. **Chaining Order:** Primitives (like `s.string`) start the chain. Constraints (`.min()`) and metadata (`.describe()`) follow. The `.optional` flag can be placed anywhere in the chain but usually goes last for readability.\n2. **No Transformers:** Unlike Zod, `tosijs` is a pure validation/schema library. It does not \"transform\" data (e.g., string to number coercion) during validation.\n3. **Strict Objects:** Remember that `s.object()` disallows unknown keys by default. If you need a flexible object, use `s.record()` or explicitly allow additional properties if the API supports it (though strict is preferred for LLM outputs).\n4. **Tuples:** Use `s.tuple([s.string, s.number])` for fixed-length arrays.\n\n## 7. Example: LLM Structured Output\n\nWhen defining a response format for an LLM:\n\n```typescript\nconst ResponseSchema = s.object({\n  reasoning: s.string.describe('Step-by-step thinking process'),\n  final_answer: s.string.describe('The concise final answer'),\n  confidence: s.number\n    .min(0)\n    .max(1)\n    .describe('Confidence score between 0 and 1'),\n})\n\n// Pass to LLM\nconst jsonSchema = ResponseSchema.schema\n```\n",
    "title": "Context: Working with tosijs-schema",
    "filename": "tosijs-schema.md",
    "path": "guides/tosijs-schema.md"
  },
  {
    "text": "## seq (Sequence)\n\nThe root atom for all agent programs. Executes steps in order.\n\n- Stops on `return` (when `ctx.output` is set)\n- Stops on error (monadic error flow)\n- Cost: 0.1\n\n```javascript\n// AsyncJS compiles to seq at the top level\nconst x = 1\nconst y = 2\nreturn { sum: x + y }\n```\n\n---\n\n## if (Conditional)\n\nConditional branching based on expression evaluation.\n\n```javascript\nif (count > 0) {\n  console.log(\"Has items\")\n} else {\n  console.log(\"Empty\")\n}\n```\n\n---\n\n## while (Loop)\n\nRepeats body while condition is truthy. Consumes fuel each iteration.\n\n```javascript\nlet i = 0\nwhile (i < 10) {\n  console.log(i)\n  i = i + 1\n}\n```\n\n**Note:** No `break`/`continue`. Use condition variables instead.\n\n---\n\n## return\n\nEnds execution and returns values from state. The schema defines which\nstate variables to include in the output.\n\n```javascript\nconst result = compute()\nreturn { result }  // Returns { result: <computed value> }\n```\n\n---\n\n## try/catch\n\nError handling with monadic error flow. When an error occurs, subsequent\nsteps are skipped until caught.\n\n```javascript\ntry {\n  const data = fetch(url)\n  processData(data)\n} catch (err) {\n  console.warn(\"Failed: \" + err)\n  return { error: err }\n}\n```\n\nThe catch block receives:\n- `err` (or custom name): error message\n- `errorOp`: the atom that failed\n\n---\n\n## for...of / map\n\nTransforms each item in an array. The `result` variable in each iteration\nbecomes the new item value.\n\n```javascript\nconst doubled = items.map(x => x * 2)\n\n// Or with for...of:\nconst results = []\nfor (const item of items) {\n  results.push(process(item))\n}\n```\n\n---\n\n## filter\n\nKeeps items that match a condition.\n\n```javascript\nconst adults = users.filter(u => u.age >= 18)\n```\n\n---\n\n## reduce\n\nAccumulates a single value from an array.\n\n```javascript\nconst sum = numbers.reduce((acc, n) => acc + n, 0)\n```\n\n---\n\n## find\n\nReturns first item matching condition, or null.\n\n```javascript\nconst admin = users.find(u => u.role === \"admin\")\n```\n\n---\n\n## fetch\n\nHTTP requests. Requires `fetch` capability or uses global fetch with SSRF protection.\n\n```javascript\nconst data = fetch(\"https://api.example.com/data\")\nconst posted = fetch(\"https://api.example.com/items\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: { name: \"New Item\" }\n})\n```\n\nResponse types: `\"json\"` (default for JSON content-type), `\"text\"`, `\"dataUrl\"` (for images)\n\nSecurity:\n- Requires `ctx.context.allowedFetchDomains` allowlist OR restricts to localhost\n- Automatically adds `X-Agent-Depth` header to prevent recursive agent loops\n- Custom fetch capability can override all restrictions\n\n---\n\n## storeGet / storeSet\n\nPersistent key-value storage. Requires `store` capability.\n\n```javascript\n// Save data\nstoreSet(\"user:123\", { name: \"Alice\", prefs: {} })\n\n// Retrieve later\nconst user = storeGet(\"user:123\")\n```\n\n**Warning:** Default in-memory store is not suitable for production.\n\n---\n\n## llmPredict\n\nCall language model. Requires `llm` capability with `predict` method.\n\n```javascript\nconst response = llmPredict(\"Summarize this: \" + text)\n\n// With options\nconst structured = llmPredict(prompt, {\n  model: \"gpt-4\",\n  temperature: 0.7,\n  responseFormat: { type: \"json_object\" }\n})\n```\n\n---\n\n## transpileCode (Code to AST)\n\nTranspiles AsyncJS code to an AST without executing it.\nUseful for generating agents to send to other services via fetch.\n\n```javascript\n// Generate an agent and send it to a worker\nlet code = llmPredict({ prompt: 'Write an AsyncJS data processor' })\nlet ast = transpileCode({ code })\nlet result = httpFetch({ \n  url: 'https://worker.example.com/run',\n  method: 'POST',\n  body: JSON.stringify({ ast, args: { data: myData } })\n})\n```\n\nSecurity: Only available when the `code.transpile` capability is provided.\n\n---\n\n## runCode (Dynamic Code Execution)\n\nTranspiles and executes AsyncJS code at runtime. The generated code\nruns in the same context, sharing fuel budget, capabilities, and trace.\n\nThis enables agents to write and execute code to solve problems.\n\n```javascript\n// Agent writes code to solve a problem\nlet code = llmPredict({ prompt: 'Write AsyncJS to calculate fibonacci(10)' })\nlet result = runCode({ code, args: {} })\nreturn { answer: result }\n```\n\nThe code must be a valid AsyncJS function. The function's return value\nbecomes the result of runCode.\n\nSecurity: Only available when the `code.transpile` capability is provided.\nThe transpiled code runs with the same permissions as the parent.\nRecursion depth is limited to prevent stack overflow.\n\n---\n\n## memoize\n\nIn-memory caching within a single execution. Same key returns cached result.\n\n```javascript\n// Expensive computation cached by key\nconst result = memoize(\"expensive-\" + id, () => {\n  return heavyComputation(data)\n})\n```\n\n---\n\n## cache\n\nPersistent caching across executions using store capability.\n\n```javascript\n// Cache API result for 1 hour (3600000 ms)\nconst weather = cache(\"weather-\" + city, 3600000, () => {\n  return fetch(\"https://api.weather.com/\" + city)\n})\n```\n\n---\n\n## console.log / console.warn / console.error\n\nLogging utilities that integrate with trace and error flow.\n\n```javascript\nconsole.log(\"Debug info: \" + value)   // Adds to trace\nconsole.warn(\"Potential issue\")        // Adds to trace + warnings summary\nconsole.error(\"Fatal: \" + msg)         // Triggers monadic error flow\n```\n\n- `log`: trace only (no side effects)\n- `warn`: trace + appears in `result.warnings`\n- `error`: stops execution, sets `result.error`",
    "title": "runtime (inline docs)",
    "filename": "runtime.ts",
    "path": "src/vm/runtime.ts"
  },
  {
    "text": "# TJS Benchmarks\n\nGenerated: 2026-01-19\nRuntime: Bun 1.3.6\nPlatform: darwin arm64\nIterations: 100,000 per test\n\n## Summary\n\n| Benchmark | Baseline | Safe (default) | Unsafe (!) |\n|-----------|----------|----------------|------------|\n| CLI: Bun + TypeScript | 14.1ms | - | - |\n| CLI: tjsx (execute TJS) | 143.0ms | - | - |\n| CLI: tjs emit | 143.2ms | - | - |\n| CLI: tjs check | 143.1ms | - | - |\n| Simple arithmetic (100K iterations) | 0.5ms | 0.8ms (1.5x) | 0.5ms (1.1x) |\n| Object manipulation (100K iterations) | 1.2ms | 1.3ms (1.1x) | 1.1ms (~1.0x) |\n| 3-function chain (100K iterations) | 0.6ms | 1.4ms (2.2x) | 0.6ms (~1.0x) |\n\n## Key Findings\n\n### CLI Cold Start\n\n- **Bun + TypeScript**: ~14ms (native, baseline)\n- **tjsx**: ~143ms (includes TJS transpiler load)\n- **Overhead**: 129ms for transpiler initialization\n\nThe ~129ms overhead is from loading the acorn parser and TJS transpiler.\nA compiled binary (via `bun build --compile`) reduces this to ~20ms.\n\n### Safe vs Unsafe Functions\n\nTJS functions are **safe by default** with runtime type validation.\nUse `(!)` to mark functions as unsafe for performance-critical code:\n\n```javascript\n// Safe (default) - validates types at runtime\nfunction add(a: 0, b: 0) -> 0 { return a + b }\n\n// Unsafe - no validation, maximum performance\nfunction fastAdd(! a: 0, b: 0) -> 0 { return a + b }\n```\n\nPerformance comparison:\n- Simple arithmetic: Safe 1.5x vs Unsafe 1.1x\n- Object manipulation: Safe 1.1x vs Unsafe ~1.0x\n- 3-function chain: Safe 2.2x vs Unsafe ~1.0x\n\n## Recommendations\n\n1. **Use safe functions at API boundaries** - The default is correct for most code\n2. **Use `(!)` for internal hot paths** - When inputs are already validated\n3. **Consider compiled binary for CLI** - `bun build --compile` for ~20ms startup\n\n## Running Benchmarks\n\n```bash\nbun run bench\n```\n\nOr run the test suite with timing output:\n\n```bash\nbun test src/lang/perf.test.ts\n```\n",
    "title": "TJS Benchmarks",
    "filename": "benchmarks.md",
    "path": "benchmarks.md"
  },
  {
    "text": "# TJS Benchmarks\n\nGenerated: 2026-01-19\nRuntime: Bun 1.3.6\nPlatform: darwin arm64\nIterations: 100,000 per test\n\n## Summary\n\n| Benchmark                           | Baseline | Safe (wrapped) | Unsafe (!)  |\n| ----------------------------------- | -------- | -------------- | ----------- |\n| Simple arithmetic (100K calls)      | 0.5ms    | 13ms (26x)     | 0.7ms (1.3x) |\n| 3-function chain (100K calls)       | 0.7ms    | 19ms (28x)     | 0.8ms (1.2x) |\n| Loop with helper (100 elem × 10K)   | 1.7ms    | 20ms (12x)     | 1.5ms (0.9x) |\n\n## Key Findings\n\n### Runtime Validation Overhead\n\nSafe TJS functions use `wrap()` for monadic type validation:\n- **~17-28x overhead** for simple operations\n- **~0.02µs per validation** (absolute time is small)\n- Overhead becomes negligible when actual work dominates\n\n### Safe vs Unsafe Functions\n\n```javascript\n// Safe (default) - validates types at runtime\nfunction add(a: 0, b: 0) -> 0 { return a + b }\n\n// Unsafe - no validation, plain JS performance\nfunction fastAdd(! a: 0, b: 0) -> 0 { return a + b }\n```\n\n| Mode        | Overhead | Use Case                        |\n| ----------- | -------- | ------------------------------- |\n| Safe        | ~17-28x  | API boundaries, untrusted input |\n| Unsafe (!)  | ~1.2x    | Hot paths, internal functions   |\n\n### ⚠️ Safe Helpers in Loops\n\n**Critical insight**: Wrapping the outer function in `unsafe {}` does NOT help if the inner helper is safe:\n\n```javascript\nfunction process(arr: [0]) -> 0 {\n  unsafe {\n    let sum = 0\n    for (const x of arr) {\n      sum += double(x)  // If double() is safe, still pays 12x per call!\n    }\n    return sum\n  }\n}\n```\n\n**Fix**: Mark the helper as unsafe:\n\n```javascript\nfunction double(! x: 0) -> 0 { return x * 2 }  // No validation overhead\n```\n\n### `unsafe {}` Block\n\nThe `unsafe {}` block wraps code in try-catch for error handling:\n- Converts exceptions to monadic errors\n- Does NOT affect validation of called functions\n- Minimal overhead (~1.3x)\n\n## Recommendations\n\n1. **Safe by default** - Use for API boundaries and untrusted input\n2. **Unsafe (!) for helpers** - Mark hot inner functions that are called in loops\n3. **Validate once at the edge** - Check types at entry, use unsafe internally\n4. **Don't micro-optimize** - 0.02µs matters only in tight loops\n\n## Future: Type Flow Optimization\n\nPlanned compile-time optimization will automatically skip redundant checks:\n- Output type matches next input → skip validation\n- Array element type known → skip per-iteration checks\n- Target: ~1.2x overhead automatically (no manual `!` needed)\n\n## Running Benchmarks\n\n```bash\nbun test src/lang/perf.test.ts\n```\n",
    "title": "TJS Benchmarks",
    "filename": "benchmarks.md",
    "path": "guides/benchmarks.md"
  },
  {
    "text": "# TJS Roadmap\n\n## Philosophy\n\nTJS is a practical language that targets multiple runtimes. The type system is _descriptive_ rather than _prescriptive_ - types explain what they are, validate at runtime, and degrade gracefully. No TypeScript gymnastics.\n\nThe runtime is JavaScript today, but it's _our_ JavaScript - the sandboxed expression evaluator, the fuel-metered VM. When we target LLVM or SwiftUI, we compile our AST, not arbitrary JS.\n\n---\n\n## Executive Summary\n\nTJS delivers **runtime type safety with near-zero overhead**. The key insight: single structured arguments enable inline validation that's 20x faster than schema interpretation.\n\n### The Performance Story\n\n| Mode | Overhead | Use Case |\n|------|----------|----------|\n| `safety none` | **1.0x** | Production - metadata only, no wrappers |\n| `safety inputs` | **~1.5x** | Production with validation (single-arg objects) |\n| `safety inputs` | ~11x | Multi-arg functions (schema-based) |\n| `safety all` | ~14x | Debug - validates inputs and outputs |\n| `(!) unsafe` | **1.0x** | Hot paths - explicit opt-out |\n| WASM blocks | **<1.0x** | Heavy computation - faster than JS |\n\n**The happy path**: Single structured argument + inline validation = **1.5x overhead** with full runtime type checking.\n\n### Why Single-Arg Objects Win\n\n```typescript\n// TJS: pleasant syntax, fast validation (1.5x)\nfunction createUser(input: { name: 'Alice', email: 'a@b.com', age: 30 }) {\n  return save(input)\n}\n\n// TypeScript: painful syntax, no runtime safety (1.0x but unsafe)\nfunction createUser({ name, email, age }: { name: string, email: string, age: number }) {\n  return save({ name, email, age })\n}\n```\n\nTJS generates inline type checks at transpile time:\n```javascript\nif (typeof input !== 'object' || input === null ||\n    typeof input.name !== 'string' ||\n    typeof input.email !== 'string' ||\n    typeof input.age !== 'number') {\n  return { $error: true, message: 'Invalid input', path: 'createUser.input' }\n}\n```\n\nNo schema interpretation. JIT-friendly. **20x faster** than Zod/io-ts style validation.\n\n### What You Get\n\n- **Runtime safety in production** - 1.5x overhead is acceptable\n- **Autocomplete always works** - `__tjs` metadata attached regardless of safety\n- **Monadic errors** - type failures return error objects, not exceptions\n- **Escape hatches** - `(!)` for hot functions, `unsafe {}` for hot blocks\n- **WASM acceleration** - `wasm {}` blocks for compute-heavy code\n\n### The Design Alignment\n\nThe idiomatic way to write TJS (single structured argument) is also the fastest way. Language design and performance goals are aligned - you don't have to choose between clean code and fast code.\n\n### Future: Compile to LLVM\n\nThe AST is the source of truth. Today we emit JavaScript. Tomorrow:\n- LLVM IR for native binaries\n- Compete with Go and Rust on performance\n- Same type safety, same developer experience\n\n---\n\n## Technical Aspects\n\n### Performance\n\n**Runtime Validation Overhead:**\n```\nPlain function call:     0.5ms / 100K calls (baseline)\nsafety: 'none':          0.5ms / 100K calls (~1.0x) - no wrapper\nsafety: 'inputs':        0.8ms / 100K calls (~1.5x) - inline validation*\nsafety: 'all':           7.0ms / 100K calls (~14x) - validates args + return\n\n* For single-arg object types (the happy path)\n  Multi-arg functions use schema-based validation (~11x)\n```\n\n**Why single-arg objects are fast:**\n```typescript\n// The happy path - single structured argument\nfunction process(input: { x: 0, y: 0, name: 'default' }) {\n  return input.x + input.y\n}\n\n// Generates inline type checks (20x faster than schema interpretation):\nif (typeof input !== 'object' || input === null ||\n    typeof input.x !== 'number' ||\n    typeof input.y !== 'number' ||\n    typeof input.name !== 'string') {\n  return { $error: true, message: 'Invalid input', path: 'process.input' }\n}\n```\n\nThis makes `safety: 'inputs'` viable for **production** with single-arg patterns.\n\n**Why `safety: 'none'` is free:**\n- `wrap()` attaches `__tjs` metadata but returns original function\n- No wrapper function, no `fn.apply()`, no argument spreading\n- Introspection/autocomplete still works - metadata is always there\n\n**The `(!) unsafe` marker:**\n```typescript\nfunction hot(! x: number) -> number { return x * 2 }\n```\n- Returns original function even with `safety: inputs`\n- Use for hot paths where validation cost matters\n- Autocomplete still works (metadata attached)\n\n**WASM blocks:**\n```typescript\nfunction compute(x: 0, y: 0) {\n  const scale = 2\n  return wasm {\n    return x * y * scale  // Compiles to WebAssembly\n  }\n}\n// Variables (x, y, scale) captured automatically from scope\n// Same code runs as JS fallback if WASM unavailable\n```\n\nWith explicit fallback (when WASM and JS need different code):\n```typescript\nfunction transform(arr: []) {\n  wasm {\n    for (let i = 0; i < arr.length; i++) { arr[i] *= 2 }\n  } fallback {\n    return arr.map(x => x * 2)  // Different JS implementation\n  }\n}\n```\n\nWASM compilation is implemented as a proof-of-concept:\n- Parser extracts `wasm { }` blocks with automatic variable capture\n- Compiler generates valid WebAssembly binary from the body\n- Runtime dispatches to WASM when available, body runs as JS fallback\n- Benchmark: ~1.3x faster than equivalent JS (varies by workload)\n\nThe POC supports: arithmetic (+, -, *, /), captured variables, parentheses.\nFull implementation would add: loops, conditionals, typed arrays, memory access.\n\n### Debugging\n\n**Source locations in errors:**\n```typescript\n{\n  $error: true,\n  message: 'Expected string but got number',\n  path: 'greet.name',           // which parameter\n  loc: { start: 15, end: 29 },  // source position\n  stack: ['main', 'processUser', 'greet.name']  // call chain (debug mode)\n}\n```\n\n**Debug mode:**\n```typescript\nconfigure({ debug: true })\n// Errors now include full call stacks\n```\n\n**The `--debug` flag (planned):**\n- Functions know where they're defined\n- Errors include source file and line\n- No source maps needed - metadata is inline\n\n### For Human Coding\n\n**Intuitive syntax:**\n```typescript\n// Types ARE examples - self-documenting\nfunction greet(name: 'World', times: 3) -> string {\n  return (name + '!').repeat(times)\n}\n\n// Autocomplete shows: greet(name: string, times: number) -> string\n// With examples: greet('World', 3)\n```\n\n**Module-level safety:**\n```typescript\nsafety none  // This module skips validation\n\nfunction hot(x: number) -> number {\n  return x * 2  // No wrapper, but autocomplete still works\n}\n```\n\n**Escape hatches:**\n```typescript\n// Per-function: skip validation for this function\nfunction critical(! data: object) { ... }\n\n// Per-block: skip validation for calls inside\nunsafe {\n  for (let i = 0; i < 1000000; i++) {\n    hot(i)  // No validation overhead\n  }\n}\n```\n\n### For Agent Coding\n\n**Introspectable functions:**\n```typescript\ngreet.__tjs = {\n  params: { name: { type: 'string', required: true, example: 'World' } },\n  returns: { type: 'string' }\n}\n\n// Agents can read this to understand function signatures\n// LLMs can generate function call schemas automatically\n```\n\n**Monadic errors:**\n```typescript\nconst result = riskyOperation()\nif (result.$error) {\n  // Error is a value, not an exception\n  // Agent can inspect and handle gracefully\n}\n```\n\n**Fuel metering:**\n```typescript\n// Agents run with fuel limits - can't run forever\nvm.run(agentCode, { fuel: 10000 })\n```\n\n---\n\n## 1. Type() Builtin\n\nA new builtin for defining types with descriptions and runtime validation.\n\n### Forms\n\n```typescript\n// Full form: description + predicate\nconst ZipCode = Type('5-digit US zip code', (s) => /^\\d{5}$/.test(s))\nconst PositiveInt = Type(\n  'positive integer',\n  (n) => Number.isInteger(n) && n > 0\n)\nconst MatchingPasswords = Type(\n  'passwords must match',\n  (o) => o.password === o.confirmPassword\n)\n\n// Schema shorthand (common case)\nconst Email = Type('valid email', s.string.email)\nconst Age = Type(s.number.min(0).max(150))\n\n// Description optional when schema is self-explanatory\nconst UserId = Type(s.string.uuid)\n```\n\n### Why\n\n- **Self-documenting**: description IS the type for humans and LLMs\n- **Runtime-checkable**: predicate runs when needed\n- **Composable**: union/intersection combine predicates\n- **Replaces regex-as-type**: more expressive, leaves regexes for actual patterns\n- **Escapes TypeScript corner cases**: no `Pick<Omit<Partial<Required<...>>>>`\n\n### Predicates\n\nPredicates are sync JS functions that run in our runtime:\n\n- Pure expression evaluation (same `$expr` nodes we have)\n- No async, no IO - type checks are in the hot path\n- Sandboxed: no prototype access, no globals\n- Portable: can be translated to any target\n\n### Simple Syntax Sugar Remains\n\n```typescript\n// These still work - Type() is the escape hatch, not the default\nfunction greet(name: string, times: number = 1) { ... }\nfunction delay(ms = 1000) { ... }\nfunction fetch(url: string, timeout = +5000) { ... }\n```\n\n## 2. Conditional Compilation with target()\n\nExplicit target blocks for platform-specific code.\n\n```typescript\ntarget(browser) {\n  document.body.appendChild(el)\n}\n\ntarget(node) {\n  process.stdout.write(str)\n}\n\ntarget(browser & debug) {\n  console.log('Debug mode in browser')\n}\n\ntarget(browser | node) {\n  // Runs in either\n}\n```\n\n### Targets\n\n**Current:**\n\n- `browser`\n- `node`\n- `bun`\n- `debug`\n- `production`\n\n**Future:**\n\n- `swiftui`\n- `android`\n- `ios`\n- `win64`\n- `llvm`\n\n### Composition\n\n- `&` - both must match\n- `|` - either matches\n- `target(production)` strips `test {}` blocks and debug code\n\n## 3. Monadic Errors and Debug Mode\n\n### try {} Without catch\n\nBare `try` blocks convert to monadic error returns:\n\n```typescript\ntry {\n  let data = riskyOperation()\n  process(data)\n}\n// No catch - transforms to:\n// if error, return { $error: true, message, op, cause }\n```\n\nErrors become values, not exceptions. Subsequent code is skipped (monadic flow).\n\n### AgentError Introspection\n\nErrors carry full context:\n\n```typescript\n{\n  $error: true,\n  message: 'Connection refused',\n  op: 'httpFetch',              // which atom failed\n  cause: <original exception>,  // for debugging\n  // With --debug:\n  source: 'orders.tjs:47:3',    // exact location\n  callStack: [                  // how we got here\n    'ship() at orders.tjs:47:3',\n    'processOrder() at checkout.tjs:123:5',\n    'handleSubmit() at form.tjs:89:12'\n  ]\n}\n```\n\n### --debug Flag\n\nWhen transpiled with `--debug`:\n\n- Functions know what they were called and where they came from\n- Errors include source locations and call stacks\n- Runtime can reconstruct the full path to failure\n\n```typescript\n// With --debug, errors show:\n// Error: Invalid ZipCode at ship() (orders.tjs:47:3)\n//   called from processOrder() (checkout.tjs:123:5)\n//   called from handleSubmit() (form.tjs:89:12)\n```\n\n### Current State\n\n- ✅ Monadic errors (AgentError class)\n- ✅ try {} without catch transforms\n- ⏳ Error introspection (op and message, not full stack)\n- ❌ --debug source mapping\n- ❌ Call stack in errors\n\n## 4. test('description') {} Blocks\n\nInline tests that hoist to bottom of file for execution.\n\n```typescript\nconst ZipCode = Type('5-digit US zip code', (s) => /^\\d{5}$/.test(s))\n\ntest('ZipCode validates correctly') {\n  assert(ZipCode.check('12345'))\n  assert(!ZipCode.check('1234'))\n  assert(!ZipCode.check('123456'))\n  assert(!ZipCode.check('abcde'), 'letters should fail')\n}\n\nfunction ship(to: ZipCode, quantity: PositiveInt) {\n  // ...\n}\n\ntest('ship requires valid zip and quantity') {\n  ship('12345', 1)  // ok\n  assertThrows(() => ship('bad', 1))\n}\n```\n\n### Failure Output\n\n```\nFAIL: ZipCode validates correctly\n  assert(!ZipCode.check('1234'))  ← auto-generated from source\n\nFAIL: ship requires valid zip and quantity\n  letters should fail  ← custom message when provided\n  assert(!ZipCode.check('abcde'), 'letters should fail')\n```\n\n### Rules\n\n- `test('description')` - description required, explains what's being tested\n- `assert(expr)` - auto-describes from source code on failure\n- `assert(expr, 'reason')` - custom message overrides auto-description\n- Tests live next to the code they test\n- Hoisted to bottom for execution order\n- Stripped in `target(production)`\n- Like Rust's `#[test]` but inline\n\n## 5. Pragmatic Native Types\n\nTrust constructor names for platform types:\n\n```typescript\n// Instead of shipping 50KB of DOM type definitions:\n// - el instanceof HTMLElement checks constructor.name\n// - If someone lies about their constructor, that's on them\n```\n\nThis applies to:\n\n- DOM types (HTMLElement, Event, etc.)\n- Node types (Buffer, Stream, etc.)\n- Platform types (SwiftUI views, Android widgets)\n\n## 6. Future: Multi-Target Emission\n\nThe same TJS source compiles to:\n\n- JavaScript (current)\n- LLVM IR (native binaries)\n- Swift (iOS/macOS)\n- Kotlin (Android)\n\nPlatform builtins vary by target:\n\n- `browser`: `document`, `window`, `fetch`\n- `swiftui`: `VStack`, `HStack`, `Text`, `Button`\n- `android`: `View`, `TextView`, `LinearLayout`\n\nThe AST is the source of truth. Targets are just emission strategies.\n\n---\n\n## Implementation Status\n\n| #   | Feature                | Status | Notes                                          |\n| --- | ---------------------- | ------ | ---------------------------------------------- |\n| 1   | Type()                 | ⏳     | Integrated with runtime validation             |\n| 2   | target()               | ❌     | Conditional compilation                        |\n| 3   | Monadic Errors         | ✅     | AgentError with path, loc, debug call stacks   |\n| 4   | test() blocks          | ⏳     | Basic extraction exists                        |\n| 5   | Pragmatic natives      | ⏳     | Some constructor checks exist                  |\n| 6   | Multi-target           | ❌     | Future - JS only for now                       |\n| 7   | Safety levels          | ✅     | none/inputs/all + (!)/(?) + unsafe {}          |\n| 8   | Module-level safety    | ✅     | `safety none` directive parsed and passed      |\n| 9   | Single-pass            | ⏳     | CLI exists, not unified                        |\n| 10  | Module system          | ❌     | Versioned imports                              |\n| 11  | Autocomplete           | ✅     | CodeMirror integration, globals, introspection |\n| 12  | Eval()                 | ⏳     | Expression eval exists, not exposed            |\n| 13  | Function introspection | ✅     | __tjs metadata with params, returns, examples  |\n| 14  | Generic()              | ❌     | Runtime-checkable generics                     |\n| 15  | Asymmetric get/set     | ❌     | Broader input, narrower output                 |\n| 16  | `==` that works        | ❌     | Structural equality + .Equals hook             |\n| 17  | WASM blocks            | ✅     | POC: parser + compiler for simple expressions  |\n\n## Implementation Priority\n\n| Priority | Feature                   | Why                        |\n| -------- | ------------------------- | -------------------------- |\n| 1        | **Type()**                | Foundation for type system |\n| 2        | **Autocomplete**          | Do or die - dev experience |\n| 3        | **test() blocks**         | TDD, in-file productivity  |\n| 4        | **--debug / call stacks** | Error experience           |\n| 5        | **Eval()**                | Expose existing work       |\n| 6        | **target()**              | Conditional compilation    |\n| 7        | **Safety flags**          | Polish                     |\n| 8        | **Single-pass**           | Polish                     |\n| 9        | **Modules**               | Can wait                   |\n\n## 7. Safety Levels and Flags\n\n### Defaults: Safe and Correct\n\nBy default, TJS is strict:\n\n- All type contracts enforced\n- Lint errors block compilation\n- Unknown types are errors\n\n### Escape Hatches\n\n```bash\ntjs build app.tjs                    # strict, safe defaults\ntjs build app.tjs --allow-unsafe     # let nasty TS libs pass through\ntjs build app.tjs --yolo             # bypass all safeguards (--just-fucking-doit)\n```\n\n- `--allow-unsafe`: Complex/unknown types become best-effort runtime checks, warnings not errors\n- `--yolo`: Skip all validation, emit anyway (for when you know what you're doing)\n\n### Lint Integration\n\nLint errors block safe builds. Not warnings - errors. If you want to ship broken code, use `--yolo`.\n\n## 8. Single-Pass Pipeline\n\nOne command does everything:\n\n```bash\ntjs build app.tjs\n```\n\nIn a single pass:\n\n1. **Lint** - catch errors early\n2. **Transpile** - emit target code\n3. **Test** - run inline tests (unless `--no-test`)\n4. **Docs** - extract documentation from types and descriptions\n\nNo separate `tjs lint && tjs build && tjs test && tjs docs`. One pass, all the information is right there.\n\n## 9. Module System\n\n### Versioned Imports (Native Approach)\n\n```typescript\nimport { Thing } from 'https://pkg.example.com/thing@1.2.3/mod.tjs'\nimport { Other } from './local.tjs'\n```\n\n- URLs with versions are the native import mechanism\n- No node_modules, no package.json resolution dance\n- Imports are cached by URL+version\n- Works like Deno, but we got here independently\n\n### Bundler Compatibility\n\nTJS also works inside conventional bundlers:\n\n- Emits standard ES modules\n- Can be a webpack/vite/esbuild plugin\n- Or replace bundling entirely with versioned imports\n\nYour choice. We don't force either approach.\n\n## 10. Autocomplete by Introspection\n\nIDE support via runtime introspection, not static `.d.ts` files.\n\n### Heuristic Levels (Progressive Fallback)\n\n**Level 0: Local symbols** (instant, always)\n\n- Scan current file for identifiers\n- Function names, variable names, parameter names\n- Known atoms\n- Like BBEdit - fast, useful, no dependencies\n\n**Level 1: Type-aware** (fast, from syntax)\n\n- Parameter `name: 'Sarah'` → string, offer string methods\n- Variable `x: 17` → number\n- No runtime needed, just syntax analysis\n\n**Level 2: Runtime introspection** (when idle)\n\n- Actually run code with mocks up to cursor\n- Get real shapes from execution\n- Nice to have, not blocking\n\n### Strategy\n\n- Start fast (Level 0+1), upgrade async in background\n- Typing rapidly? Stay at Level 0\n- Paused 200ms? Try Level 1\n- Paused 500ms? Try Level 2\n- Cache aggressively - same signature = same completions\n\n### CSS: Use the Browser\n\nCSS autocomplete is pathological to implement manually - hundreds of properties, thousands of values, vendor prefixes. The browser already knows all of this.\n\n```typescript\n// Let the browser do the work\nconst style = document.createElement('div').style\nObject.keys(style) // Every CSS property\nCSS.supports('display', 'grid') // Validate values\n```\n\nDon't ship CSS type definitions. Query the browser at runtime for:\n\n- Property names\n- Valid values for each property\n- Vendor prefix variants\n\n### Versioned Imports Make This Insane\n\n```typescript\nimport { ship } from 'https://pkg.example.com/shipping@2.0.0/mod.tjs'\n```\n\n- Module already transpiled (cached by URL+version)\n- Already introspected (we know its exports)\n- Immutable (version pinned, never changes)\n- Autocomplete for `ship.` is instant forever\n\nNo node_modules crawling. No LSP server eating 4GB RAM. One file, one unit, instant knowledge.\n\n### Non-Goals\n\n- External LSP dependencies\n- TypeScript language server\n- Crawling dependency graphs\n\n## 11. Eval() - Safe Expression Evaluation\n\nA builtin for evaluating expressions with fuel limits:\n\n```typescript\n// Low default fuel - won't run away\nEval('2 + 2') // ~100 fuel default\n\n// Explicitly allow more for complex work\nEval('fibonacci(20)', { fuel: 1000 })\n\n// Restrict for untrusted input\nEval(userInput, { fuel: 10 })\n```\n\n### Why\n\n- Same sandboxed evaluator we already have, exposed as builtin\n- Safe by default - low fuel limit prevents runaway computation\n- No `eval()` - this is AST evaluation, not string execution\n- Fuel exhaustion returns error, doesn't throw\n\n### Options\n\n```typescript\nEval(expression, {\n  fuel: 100, // max fuel (default: 100)\n  context: {}, // variables available to expression\n  timeout: 1000, // ms timeout (default: fuel * 10)\n})\n```\n\n## Ideas Parking Lot\n\n### Type Flow Optimization (Compile-Time)\n\nSkip redundant type checks when types are already proven. The transpiler tracks type information through the call graph:\n\n**Scenario 1: Chained Functions**\n\n```typescript\nfunction validate(x: number) -> number { return x * 2 }\nfunction process(x: number) -> number { return x + 1 }\n\n// Source\nconst result = process(validate(input))\n\n// Naive: validate checks input, process checks validate's output\n// Optimized: validate's return type matches process's input - skip second check\n\n// Transpiled (optimized)\nconst _v = validate(input)  // validates input once\nconst result = process.__unchecked(_v)  // skips redundant check\n```\n\n**Scenario 2: Loop Bodies**\n\n```typescript\nfunction double(x: number) -> number { return x * 2 }\nconst nums: number[] = [1, 2, 3]\n\n// Source\nnums.map(double)\n\n// Naive: double validates x on every iteration (3 checks)\n// Optimized: nums is number[], so each element is number - skip all checks\n\n// Transpiled (optimized)  \nnums.map(double.__unchecked)  // zero validation overhead in loop\n```\n\n**Scenario 3: Subtype Relationships**\n\n```typescript\nconst PositiveInt = Type('positive integer', n => Number.isInteger(n) && n > 0)\nfunction increment(x: number) -> number { return x + 1 }\n\nconst val: PositiveInt = 5\nincrement(val)  // PositiveInt is subtype of number - skip check\n```\n\n**Implementation:**\n\n1. Track return types through call graph\n2. Generate `fn.__unchecked` variants that skip input validation\n3. Emit unchecked calls when input type is proven\n4. Array/iterable element types flow into loop bodies\n5. Subtype relationships allow broader → narrower without checks\n\n**Performance Target:**\n\n- Current `wrap()`: ~17x overhead\n- With type flow: ~1.2x overhead (matching safe TJS functions)\n- Hot loops: 0x overhead (unchecked path)\n\n### JIT-Compiled Type Predicates\n\nWe own the language, so we can optimize hot type checks:\n\n1. **Interpreted mode** (default): Predicate runs as-is\n2. **Compiled mode** (hot path): If a Type validates thousands of times, JIT-compile it\n\n```typescript\nconst ZipCode = Type('5-digit zip', (s) => /^\\d{5}$/.test(s))\n\n// First N calls: interpreted, collecting stats\n// Call N+1: \"this is hot, compile it\"\n// Now it's TypeBox-fast without ahead-of-time compilation\n```\n\nFor `target(production)`, we could inline validators entirely:\n\n```typescript\n// Source\nfunction ship(to: ZipCode) { ... }\n\n// Transpiled (production)\nfunction ship(to) {\n  if (typeof to !== 'string' || !/^\\d{5}$/.test(to))\n    throw new TypeError('expected 5-digit zip')\n  ...\n}\n```\n\nNo runtime Type object, no .check() call - just inlined validation.\n\nUnlike TypeBox (which precompiles via eval and can't handle dynamic types), we can do both interpreted and compiled because we control the compiler.\n\n---\n\n## 12. Function Introspection\n\nFunctions are self-describing. A single signature provides types, examples, and tests:\n\n```typescript\nfunction checkAge(name: 'Anne', age = 17) -> { canDrink: false } {\n  return { canDrink: age >= 21 }\n}\n```\n\nFrom this you get:\n\n| Extracted         | Value                                                          |\n| ----------------- | -------------------------------------------------------------- |\n| **Types**         | `name: string`, `age: number`, returns `{ canDrink: boolean }` |\n| **Examples**      | `name = 'Anne'`, `age = 17`, output `{ canDrink: false }`      |\n| **Implicit test** | `checkAge('Anne', 17)` should return `{ canDrink: false }`     |\n| **Docs**          | The signature IS the documentation                             |\n\n### Runtime Metadata\n\nEvery function carries introspectable metadata:\n\n```typescript\ncheckAge.meta\n// {\n//   name: 'checkAge',\n//   params: [\n//     { name: 'name', type: 'string', example: 'Anne' },\n//     { name: 'age', type: 'number', example: 17, default: 17 }\n//   ],\n//   returns: { type: { canDrink: 'boolean' }, example: { canDrink: false } },\n//   source: 'users.tjs:42:1'  // in debug builds\n// }\n```\n\n### Debug Builds\n\nWith `--debug`, functions know where they are and where they were called from:\n\n```typescript\n// Error output includes full trace:\n// Error: Invalid ZipCode at ship() (orders.tjs:47:3)\n//   called from processOrder() (checkout.tjs:123:5)\n//   called from handleSubmit() (form.tjs:89:12)\n```\n\n### No Source Maps\n\nSource maps are a hack - external files that get out of sync, break in large builds, and require tooling support. TJS replaces them entirely:\n\n- The function _knows_ where it's from (`fn.meta.source`)\n- Can't get out of sync (it's part of the function)\n- No external files, no tooling required\n- Works in production without `.map` files\n\n### Why This Matters\n\n- **Auto-generated tests**: Run with examples, expect example output\n- **API documentation**: Always accurate, extracted from source\n- **LLM tool schemas**: Generate OpenAI function calling format automatically\n- **Debug traces**: Full path to failure with source locations\n- **Zero extra effort**: You write the function, you get all of this\n\n## 13. Generic() Builtin\n\nTuring completeness by design, not by accident. TypeScript's generics grew into an unreadable type-level programming language. TJS assumes Turing completeness from the start - the predicate is just code:\n\nFollowing the `Type()` pattern, generics are runtime-inspectable and predicate-validated:\n\n```typescript\nconst List = Generic(\n  'homogeneous list of items',\n  [T],\n  (x, [T]) => Array.isArray(x) && x.every(item => T.check(item))\n)\n\nconst Map = Generic(\n  'key-value mapping',\n  [K, V = any],\n  (x, [K, V]) => x instanceof Map && [...x.keys()].every(k => K.check(k))\n)\n\n// Usage\nconst strings: List(string) = ['a', 'b', 'c']\nconst lookup: Map(string, number) = new Map([['age', 42]])\n```\n\n### Why\n\n- **Runtime-checkable**: Not erased like TypeScript generics\n- **Self-documenting**: Description for humans and LLMs\n- **Composable**: Predicates can do real validation\n- **Practical**: Makes complex generics achievable without gymnastics\n\nConverting convoluted TypeScript generics (`Pick<Omit<Partial<...>>>`) is nice-to-have, not a priority.\n\n## 14. Asymmetric Get/Set\n\nProperties that accept a broader type on write but return a narrower type on read:\n\n```typescript\n// Setter accepts multiple types, getter returns normalized type\nobj.timestamp = '2024-01-15' // SET accepts: string | number | Date\nobj.timestamp // GET returns: Date (always normalized)\n\n// DOM example\nel.style.color = 'red' // SET accepts: string | null\nel.style.color // GET returns: string\n```\n\nThis is common in real APIs but TypeScript makes it painful. TJS supports it natively.\n\n## 15. `==` That Works\n\nJavaScript's `==` is broken (type coercion chaos). TJS fixes it:\n\n| Operator | Behavior                                                                                  |\n| -------- | ----------------------------------------------------------------------------------------- |\n| `==`     | **Value equality** - structural comparison for arrays/objects, calls `.Equals` if defined |\n| `===`    | **Identity** - same object reference (rarely needed)                                      |\n\n```typescript\n;([1, 2] == [1, 2][(1, 2)]) === // true (structural)\n  [1, 2] // false (different objects)\n\nconst p1 = {\n  x: 1,\n  Equals(o) {\n    return this.x == o.x\n  },\n}\nconst p2 = { x: 1 }\np1 == p2 // true (via .Equals hook)\np1 === p2 // false (different objects)\n```\n\n### Rules\n\n1. If left has `.Equals`, call `left.Equals(right)`\n2. If right has `.Equals`, call `right.Equals(left)`\n3. Arrays/objects: recursive structural comparison\n4. Primitives: strict equality (no coercion)\n\n## 16. Death to Semicolons\n\nNewlines are meaningful. This:\n\n```typescript\nfoo()\n```\n\nIs **two statements** (`foo` and `()`), not a function call `foo()`.\n\nThis eliminates:\n\n- Defensive semicolons\n- ASI gotchas\n- The entire \"semicolon debate\"\n\nThe only code this breaks is pathological formatting that nobody writes intentionally.\n\n## 17. Polyglot Blocks (WASM, Shaders, etc.)\n\nTarget-specific code blocks with automatic variable capture and fallback:\n\n```typescript\n// WASM for performance-critical path - variables captured automatically\nfunction matmul(vertices: Float32Array, matrix: Float32Array) {\n  wasm {\n    for (let i = 0; i < vertices.length; i += 3) {\n      // matrix multiply using vertices and matrix from scope\n    }\n  }\n  // Body runs as JS if WASM unavailable\n}\n\n// With explicit fallback when implementations differ:\nfunction transform(data: Float32Array) {\n  wasm {\n    // WASM-optimized in-place mutation\n    for (let i = 0; i < data.length; i++) { data[i] *= 2 }\n  } fallback {\n    // JS uses different approach\n    return data.map(x => x * 2)\n  }\n}\n\n// GPU shader (future)\nglShader {\n  gl_Position = projection * view * vec4(position, 1.0)\n  fragColor = color\n} fallback {\n  // CPU fallback\n}\n\n// Debug-only code (stripped in production)\ndebug {\n  console.log('state:', state)\n  validateInvariants()\n}\n// No fallback needed - just doesn't run in production\n```\n\n### Pattern\n\n```\ntarget(args?) {\n  // target-specific code (compiled/translated)\n} fallback? {\n  // universal TJS fallback (optional for some targets)\n}\n```\n\n### Targets\n\n| Target     | Compiles to            | Fallback | Use case                  |\n| ---------- | ---------------------- | -------- | ------------------------- |\n| `wasm`     | WebAssembly            | Required | CPU-intensive computation |\n| `glShader` | GLSL                   | Required | GPU graphics              |\n| `metal`    | Metal Shading Language | Required | Apple GPU                 |\n| `debug`    | TJS (stripped in prod) | None     | Debugging, invariants     |\n\n### Why\n\n- **Performance**: WASM/GPU where it matters, TJS everywhere else\n- **Graceful degradation**: Fallback ensures code always runs\n- **Single source**: Don't maintain separate WASM/shader files\n- **Type-safe boundary**: Args translated automatically at the boundary\n\n## Non-Goals\n\n- TypeScript compatibility (we're inspired by, not constrained by)\n- Full JS semantics (we're a subset that's portable)\n- Converting convoluted TS generics (nice-to-have, not priority)\n",
    "title": "TJS Roadmap",
    "filename": "PLAN.md",
    "path": "PLAN.md"
  },
  {
    "text": "# TJS: The Host Language\n\n**Build Universal Endpoints. Delete the build server.**\n\nMost languages compile to binaries. TJS compiles to **Universal Endpoints**—services that accept and execute arbitrary logic safely, with zero deployment per agent.\n\n---\n\n## The Architecture: Browser Model for the Cloud\n\nWe separate **Host** (infrastructure you deploy once) from **Guest** (logic that ships continuously).\n\n| | **TJS (Host)** | **AJS (Guest)** |\n|---|---|---|\n| **Role** | Defines the physics—capabilities, resources, safety | The portable logic payload |\n| **You write** | Your service layer, frontend, capabilities | Agents, workflows, LLM-generated code |\n| **Deploys** | Once, then evolves | Continuously, as data |\n| **Trust level** | Trusted code you control | Untrusted code from anywhere |\n\n**Together:** Deploy TJS once to create a secure, high-performance Universal Endpoint. Ship AJS continuously to execute logic where the data lives.\n\n**See also:** [AJS Documentation](./ABOUT-AJS.md) for the Guest language.\n\n---\n\n## Why TJS is the Ultimate Host Language\n\nTJS isn't just \"TypeScript with runtime types.\" It's specifically designed to **survive the Guest**.\n\n### 1. Monadic Errors: The Host Never Crashes\n\nA Universal Endpoint can't crash when a guest misbehaves. TJS enforces robustness:\n\n```typescript\n// Type failure returns error object, not exception\nconst result = createUser({ name: 123 })\n// { $error: true, message: 'Invalid input', path: 'createUser.input' }\n\nif (result.$error) {\n  // Handle gracefully—log, retry, or return to caller\n  return { status: 'invalid', details: result }\n}\n```\n\nNo `try/catch` gambling. No unhandled exceptions. The host survives anything the guest throws at it.\n\n### 2. Introspection: Autocomplete from Reality\n\nTJS provides **runtime introspection**, not static type files:\n\n```typescript\n// The runtime knows what this function accepts\nconsole.log(createUser.__tjs)\n// {\n//   params: { input: { type: { kind: 'object', shape: { name: 'string', age: 'number' } } } },\n//   returns: { kind: 'object', shape: { id: 'number' } }\n// }\n```\n\n- **Autocomplete by introspection:** Editor queries live objects, not stale `.d.ts` files\n- **No API drift:** Backend adds a field, frontend sees it immediately\n- **Self-documenting capabilities:** Agents can inspect what the host offers\n\n### 3. Inline WASM: Raw Power Without Breaking Abstraction\n\nWhen agents need compute, you don't leave TJS. You drop into `wasm {}`:\n\n```typescript\nfunction vectorDot(a: [0], b: [0]) -> 0 {\n  let sum = 0\n  wasm {\n    for (let i = 0; i < a.length; i++) {\n      sum = sum + a[i] * b[i]\n    }\n  }\n  return sum\n}\n```\n\n- Variables captured automatically\n- Falls back to JS if WASM unavailable\n- The Universal Endpoint stays fast without breaking the abstraction\n\n### 4. Literate Programming: Documentation That Can't Rot\n\nIf the endpoint lives forever while agents change constantly, docs must live in the code:\n\n```typescript\n/**\n * Create a new user in the system.\n * \n * @capability Requires `store` capability with write access.\n * @rateLimit 100 requests per minute per API key.\n * \n * @example\n * createUser({ name: 'Alice', email: 'alice@example.com', age: 30 })\n * // => { id: 12345, created: '2025-01-19T...' }\n * \n * @test\n * const result = createUser({ name: 'Test', email: 'test@test.com', age: 25 })\n * expect(result.id).toBeNumber()\n */\nfunction createUser(input: { name: 'Alice', email: 'a@b.com', age: 30 }) -> { id: 0 } {\n  return store.insert('users', input)\n}\n```\n\nTests and docs are extracted automatically. The API *is* its own manual.\n\n---\n\n## The Zero-Build Frontend\n\nTJS transpiles **in the browser**. No webpack. No Vite. No `npm install`.\n\n### The Unbroken Chain\n\n1. **Write:** TJS in your editor (or browser)\n2. **Transpile:** In the browser, no build server\n3. **Run:** Immediately, with full type safety\n4. **Autocomplete:** From live introspection, not static files\n\n### Unbundled Imports\n\n```typescript\n// Fetched, transpiled, and linked on demand\nimport { Button } from 'https://cdn.example.com/ui-kit.tjs'\nimport { validate } from './utils/validation.tjs'\n```\n\n- **Zero-install dev:** New developer opens file, browser fetches imports, running in seconds\n- **True separate compilation:** Update one file, client downloads only that file\n- **Cache-friendly:** Each module cached independently\n\n### The Stack You Delete\n\n| Before | After |\n|--------|-------|\n| TypeScript | TJS |\n| Webpack/Vite | Browser |\n| Babel | Browser |\n| `node_modules` | Import URLs |\n| Source maps | Direct execution |\n| Build server | Nothing |\n\n---\n\n## For Different Audiences\n\n### For the CEO\n\n**Ship faster. Break nothing.**\n\n- **Zero deployment friction:** Change logic without redeploying infrastructure\n- **Runtime safety:** Type errors caught in production, not just development\n- **AI-ready:** LLMs can generate, inspect, and fix code programmatically\n\n### For the CTO\n\n**The security model that survives AI agents.**\n\n- **Monadic errors:** No unhandled exceptions, ever\n- **Capability-based:** Host controls exactly what guests can access\n- **Introspectable:** Full audit trail of what code does what\n- **Performance:** 1.5x overhead for validation, 0x for compute (WASM)\n\n### For the Engineer\n\n**The Smalltalk/Lisp experience, with syntax you know.**\n\n- **Live coding:** Edit, save, see—no rebuild cycle\n- **Real autocomplete:** From runtime objects, not type guesses\n- **Inline everything:** Tests, docs, WASM, all in one file\n- **Errors as data:** Handle failures, don't catch exceptions\n\n### For the Frontend Dev\n\n**Delete your build tools.**\n\n- **No webpack config:** Browser is the compiler\n- **No `node_modules`:** Imports are URLs\n- **No source maps:** You're running TJS directly\n- **No \"works on my machine\":** Browser is the single source of truth\n\n---\n\n## Performance\n\n| Mode | Overhead | Use Case |\n|------|----------|----------|\n| `safety none` | **1.0x** | Metadata only, no validation |\n| `safety inputs` | **~1.5x** | Production with validation (single-arg objects) |\n| `safety inputs` | ~11x | Multi-arg functions (schema fallback) |\n| `safety all` | ~14x | Debug mode |\n| `(!) unsafe` | **1.0x** | Hot paths |\n| `wasm {}` | **<1.0x** | Compute-heavy code |\n\n### Why 1.5x, Not 25x\n\nMost validators interpret schemas at runtime (~25x). TJS generates inline checks at transpile time:\n\n```typescript\n// Generated (JIT-friendly)\nif (typeof input !== 'object' || input === null ||\n    typeof input.name !== 'string' ||\n    typeof input.age !== 'number') {\n  return { $error: true, message: 'Invalid input', path: 'createUser.input' }\n}\n```\n\nNo schema interpretation. No object iteration. The JIT inlines these completely.\n\n---\n\n## The Pitch\n\n> **You aren't just building a better language. You're building a better browser development model.**\n\nTJS merges Editor, Compiler, and Runtime into one fluid loop. It's the Smalltalk dream realized with syntax people actually know.\n\n- **Write TJS** → Browser compiles it\n- **Type `user.`** → Autocomplete from live data\n- **Throw an error** → Caught as a value, not a crash\n- **Deploy once** → Ship agents forever\n\n**The result:** A frontend dev gets Type Safety + Autocomplete + No Build Step. They never go back to `npm install webpack` again.\n\n---\n\n## Quick Links\n\n- [AJS: The Guest Language](./ABOUT-AJS.md)\n- [Technical Documentation](./CONTEXT.md)\n- [Playground](./demo/)\n- [GitHub](https://github.com/tonioloewald/tosijs-agent)\n",
    "title": "TJS: The Host Language",
    "filename": "ABOUT-TJS.md",
    "path": "ABOUT-TJS.md"
  },
  {
    "text": "# TJS: Typed JavaScript\n\nTJS is a typed superset of JavaScript where **types are examples**.\n\n```javascript\nfunction greet(name: 'World', times: 3) -> '' {\n  let result = ''\n  let i = 0\n  while (i < times) {\n    result = result + `Hello, ${name}! `\n    i = i + 1\n  }\n  return result.trim()\n}\n```\n\n## Philosophy\n\nTJS takes a different approach to typing than TypeScript:\n\n| Aspect         | TypeScript                              | TJS                           |\n| -------------- | --------------------------------------- | ----------------------------- |\n| Types          | Abstract declarations                   | Concrete examples             |\n| Runtime        | Erased completely                       | Preserved as metadata         |\n| Validation     | Compile-time only                       | Runtime optional              |\n| Learning curve | Learn type syntax                       | Use values you know           |\n| Error messages | \"Type 'string' is not assignable to...\" | \"Expected string, got number\" |\n\n### Why Examples?\n\nConsider how you'd explain a function to another developer:\n\n> \"This function takes a name like 'World' and a count like 3, and returns a greeting string\"\n\nThat's exactly how TJS works. The example _is_ the type:\n\n```javascript\n// TypeScript\nfunction greet(name: string, times: number): string\n\n// TJS - the example IS the documentation\nfunction greet(name: 'World', times: 3) -> ''\n```\n\n## Core Concepts\n\n### 1. Types by Example\n\nInstead of abstract type names, use example values:\n\n```javascript\n// Strings\nname: ''           // any string\nname: 'default'    // string with default value\n\n// Numbers\ncount: 0           // any number\nport: 8080         // number with default\n\n// Booleans\nenabled: true      // boolean (default true)\ndisabled: false    // boolean (default false)\n\n// Arrays\nitems: ['']        // array of strings\nnumbers: [0]       // array of numbers\nmixed: [0, '']     // tuple: number, string\n\n// Objects\nuser: { name: '', age: 0 }  // object with shape\n\n// Null/Undefined\nnullable: null\noptional: undefined\n```\n\n### 2. Required vs Optional (`:` vs `=`)\n\nThe colon `:` means required, equals `=` means optional:\n\n```javascript\nfunction createUser(\n  name: 'Anonymous',     // required string\n  email: 'user@example.com',  // required string\n  age = 0,               // optional number (defaults to 0)\n  role = 'user'          // optional string (defaults to 'user')\n) -> { id: '', name: '', email: '', age: 0, role: '' } {\n  return {\n    id: crypto.randomUUID(),\n    name,\n    email,\n    age,\n    role\n  }\n}\n\n// Valid calls:\ncreateUser('Alice', 'alice@example.com')\ncreateUser('Bob', 'bob@example.com', 30)\ncreateUser('Carol', 'carol@example.com', 25, 'admin')\n\n// Invalid - missing required params:\ncreateUser('Dave')  // Error: missing required parameter 'email'\n```\n\n### 3. Return Type Annotation\n\nUse `->` to declare the return type:\n\n```javascript\nfunction add(a: 0, b: 0) -> 0 {\n  return a + b\n}\n\nfunction getUser(id: '') -> { name: '', email: '' } | null {\n  // Returns user object or null\n}\n```\n\n### 4. Union Types\n\nUse `||` for unions (not `|` like TypeScript):\n\n```javascript\nfunction parseInput(value: '' || 0 || null) -> '' {\n  if (value === null) return 'null'\n  if (typeof value === 'number') return `number: ${value}`\n  return `string: ${value}`\n}\n```\n\n### 5. The `any` Type\n\nWhen you genuinely don't know the type:\n\n```javascript\nfunction identity(x: any) -> any {\n  return x\n}\n```\n\nGenerics from TypeScript become `any` but preserve metadata:\n\n```javascript\n// TypeScript: function identity<T>(x: T): T\n// TJS: any, but __tjs.typeParams captures the generic info\nfunction identity(x: any) -> any {\n  return x\n}\n// identity.__tjs.typeParams = { T: {} }\n```\n\n### 6. Type Declarations\n\nDefine reusable types with the `Type` keyword:\n\n```javascript\n// Simple type from example value\nType Name 'Alice'\n\n// Type with description and example\nType User {\n  description: 'a user object'\n  example: { name: '', age: 0 }\n}\n\n// Type with predicate (auto-generates type guard from example)\nType EvenNumber {\n  description: 'an even number'\n  example: 2\n  predicate(x) { return x % 2 === 0 }\n}\n```\n\nWhen both `example` and `predicate` are provided, the type guard is auto-generated from the example, and your predicate becomes a refinement check.\n\n### 7. Generic Declarations\n\nDefine parameterized types with the `Generic` keyword:\n\n```javascript\n// Simple generic\nGeneric Box<T> {\n  description: 'a boxed value'\n  predicate(x, T) { \n    return typeof x === 'object' && x !== null && 'value' in x && T(x.value) \n  }\n}\n\n// Generic with default type parameter\nGeneric Container<T, U = ''> {\n  description: 'container with label'\n  predicate(obj, T, U) { \n    return T(obj.item) && U(obj.label) \n  }\n}\n```\n\nIn the predicate, `T` and `U` are type-checking functions that validate values against the provided type parameters.\n\n### 8. Bare Assignments\n\nUppercase identifiers automatically get `const`:\n\n```javascript\n// These are equivalent:\nFoo = Type('test', 'example')\nconst Foo = Type('test', 'example')\n\n// Works for any uppercase identifier\nMyConfig = { debug: true }\nconst MyConfig = { debug: true }\n```\n\n## Runtime Features\n\n### Monadic Error Handling\n\nTJS functions propagate errors automatically:\n\n```javascript\n// If any input is an error, it passes through\nconst result = processData(maybeError)\n// If maybeError is an error, result is that error (processData not called)\n\n// Check for errors\nif (isError(result)) {\n  console.log(result.message)\n}\n```\n\n### Safe by Default\n\nTJS functions are wrapped with runtime type validation by default:\n\n```javascript\nfunction add(a: 0, b: 0) -> 0 {\n  return a + b\n}\n\nadd(1, 2)      // 3\nadd('1', 2)    // Error: expected number, got string\nadd(null, 2)   // Error: expected number, got null\n```\n\nThis provides excellent error messages and catches type mismatches at runtime.\n\n### Safety Markers: `(?)` and `(!)`\n\nControl input validation with markers after the opening paren:\n\n```javascript\n// (?) - Safe function: force input validation\nfunction safeAdd(? a: 0, b: 0) -> 0 {\n  return a + b\n}\n\n// (!) - Unsafe function: skip input validation\nfunction fastAdd(! a: 0, b: 0) -> 0 {\n  return a + b\n}\n\nfastAdd(1, 2)      // 3 (fast path, no validation)\nfastAdd('1', 2)    // NaN (no validation, garbage in = garbage out)\n```\n\nThe `!` is borrowed from TypeScript's non-null assertion operator - it means \"I know what I'm doing, trust me.\"\n\n### Return Type Safety: `->`, `-?`, `-!`\n\nControl output validation with different arrow styles:\n\n```javascript\n// -> normal return type (validation depends on module settings)\nfunction add(a: 0, b: 0) -> 0 { return a + b }\n\n// -? force output validation (safe return)\nfunction critical(a: 0, b: 0) -? 0 { return a + b }\n\n// -! skip output validation (unsafe return)\nfunction fast(a: 0, b: 0) -! 0 { return a + b }\n```\n\nCombine input and output markers for full control:\n\n```javascript\n// Fully safe: validate inputs AND outputs\nfunction critical(? x: 0) -? 0 { return x * 2 }\n\n// Fully unsafe: skip all validation\nfunction blazingFast(! x: 0) -! 0 { return x * 2 }\n```\n\n### The `unsafe` Block\n\nFor unsafe sections within a safe function, use `unsafe {}`:\n\n```javascript\nfunction sum(numbers: [0]) -> 0 {\n  // Parameters are validated, but the inner loop is unsafe\n  unsafe {\n    let total = 0\n    for (let i = 0; i < numbers.length; i++) {\n      total += numbers[i]\n    }\n    return total\n  }\n}\n```\n\n### Performance Characteristics\n\n| Mode              | Overhead | Use Case                                 |\n| ----------------- | -------- | ---------------------------------------- |\n| Default (safe)    | ~50x     | API boundaries, user input               |\n| `unsafe {}` block | ~1.2x    | Hot loops within validated functions     |\n| `(!)` function    | 0x       | Internal utilities, performance critical |\n\nUse `(!)` for internal functions that are called frequently with known-good data. Keep public APIs safe.\n\n## Testing\n\n### Inline Tests\n\nTests live alongside your code:\n\n```javascript\nfunction add(a: 0, b: 0) -> 0 {\n  return a + b\n}\n\ntest('add works with positive numbers') {\n  expect(add(1, 2)).toBe(3)\n  expect(add(0, 0)).toBe(0)\n}\n\ntest('add works with negative numbers') {\n  expect(add(-1, 1)).toBe(0)\n  expect(add(-5, -3)).toBe(-8)\n}\n```\n\n### Inline Mocks\n\nSetup code that runs before each test:\n\n```javascript\nmock {\n  const testUser = { name: 'Test', age: 25 }\n  const mockDB = new Map()\n}\n\ntest('user can be stored') {\n  mockDB.set('user1', testUser)\n  expect(mockDB.get('user1')).toEqual(testUser)\n}\n```\n\n### Async Tests\n\nAll test blocks are async contexts:\n\n```javascript\ntest('async operations work') {\n  const data = await fetchData()\n  expect(data).toBeDefined()\n}\n```\n\n## Differences from JavaScript\n\n### Removed/Discouraged\n\n| Feature        | Reason                      |\n| -------------- | --------------------------- |\n| `var`          | Use `let` or `const`        |\n| `class`        | Use functions and objects   |\n| `this`         | Explicit context passing    |\n| `new` (mostly) | Factory functions preferred |\n| `throw`        | Return errors as values     |\n| `for...in`     | Use `Object.keys()`         |\n\n### Added\n\n| Feature         | Purpose                                    |\n| --------------- | ------------------------------------------ |\n| `: example`     | Required parameter with type               |\n| `= example`     | Optional parameter with default            |\n| `-> Type`       | Return type annotation                     |\n| `-? Type`       | Return type with forced output validation  |\n| `-! Type`       | Return type with skipped output validation |\n| `(?)`           | Mark function as safe (force validation)   |\n| `(!)`           | Mark function as unsafe (skip validation)  |\n| `test() {}`     | Inline test block                          |\n| `mock {}`       | Test setup block                           |\n| `unsafe {}`     | Skip validation for a block                |\n| `\\|\\|` in types | Union types                                |\n| `Type Name ...` | Define a runtime type from example         |\n| `Generic<T>`    | Define a parameterized runtime type        |\n| `Foo = ...`     | Bare assignment (auto-adds `const`)        |\n\n## Differences from TypeScript\n\n### Types are Values\n\n```typescript\n// TypeScript - abstract type\ninterface User {\n  name: string\n  age: number\n  email?: string\n}\n\n// TJS - concrete example\nconst User = { name: '', age: 0, email = '' }\n```\n\n### Runtime Preservation\n\nTypeScript erases types at compile time. TJS preserves them:\n\n```javascript\nfunction greet(name: 'World') -> '' {\n  return `Hello, ${name}!`\n}\n\n// At runtime:\ngreet.__tjs = {\n  params: { name: { type: 'string', required: true } },\n  returns: { type: 'string' }\n}\n```\n\nThis enables:\n\n- Runtime validation\n- Auto-generated documentation\n- API schema generation\n- Better error messages\n\n### Generics\n\nTypeScript generics become `any` in TJS, but constraints are preserved:\n\n```typescript\n// TypeScript\nfunction process<T extends { id: number }>(item: T): T\n\n// TJS - constraint becomes validatable schema\nfunction process(item: any) -> any\n// process.__tjs.typeParams = { T: { constraint: '{ id: 0 }' } }\n```\n\nThe constraint `{ id: number }` becomes the example `{ id: 0 }` - and can be validated at runtime!\n\n### No Type Gymnastics\n\nTJS doesn't support:\n\n- Conditional types\n- Mapped types\n- Template literal types\n- `infer` keyword\n\nIf you need these, you probably need to rethink your approach. TJS favors simple, explicit types over clever type-level programming.\n\n## The `__tjs` Metadata\n\nEvery TJS function has attached metadata:\n\n```javascript\nfunction createUser(name: 'Anonymous', age = 0) -> { id: '', name: '', age: 0 } {\n  return { id: crypto.randomUUID(), name, age }\n}\n\ncreateUser.__tjs = {\n  params: {\n    name: { type: 'string', required: true, default: 'Anonymous' },\n    age: { type: 'number', required: false, default: 0 }\n  },\n  returns: { type: 'object', shape: { id: 'string', name: 'string', age: 'number' } },\n  // For generic functions:\n  typeParams: {\n    T: { constraint: '{ id: 0 }', default: null }\n  }\n}\n```\n\nThis metadata enables:\n\n1. **Runtime validation** via `wrap()`\n2. **Documentation generation** via `generateDocs()`\n3. **API schema export** (OpenAPI, JSON Schema)\n4. **IDE autocompletion**\n5. **Version-safe serialization**\n\n## CLI Tools\n\n### `tjs` - The TJS Compiler\n\n```bash\ntjs check file.tjs      # Parse and type check\ntjs emit file.tjs       # Output transpiled JavaScript\ntjs run file.tjs        # Transpile and execute\ntjs types file.tjs      # Output type metadata as JSON\n```\n\n### `tjsx` - Quick Execution\n\n```bash\ntjsx script.tjs                    # Run a TJS file\ntjsx script.tjs --name=value       # Pass arguments\ntjsx -e \"function f() { return 42 }\"  # Evaluate inline\necho '{\"x\": 1}' | tjsx script.tjs --json  # JSON from stdin\n```\n\n## Best Practices\n\n### 1. Use Examples That Document\n\n```javascript\n// Bad - meaningless example\nfunction send(to: '', subject: '', body: '') {}\n\n// Good - self-documenting\nfunction send(\n  to: 'user@example.com',\n  subject: 'Hello!',\n  body: 'Message content here...'\n) {}\n```\n\n### 2. Validate at Boundaries\n\n```javascript\n// Public API - safe by default\nexport function createUser(name: '', email: '') -> { id: '', name: '', email: '' } {\n  return createUserImpl(name, email)\n}\n\n// Internal - mark as unsafe for speed\nfunction createUserImpl(! name: '', email: '') -> { id: '', name: '', email: '' } {\n  return { id: crypto.randomUUID(), name, email }\n}\n```\n\n### 3. Return Errors, Don't Throw\n\n```javascript\n// Bad\nfunction divide(a: 0, b: 0) -> 0 {\n  if (b === 0) throw new Error('Division by zero')\n  return a / b\n}\n\n// Good\nfunction divide(a: 0, b: 0) -> 0 {\n  if (b === 0) return error('Division by zero')\n  return a / b\n}\n```\n\n### 4. Keep Types Simple\n\n```javascript\n// Bad - over-engineered\nfunction process(data: {\n  items: [{ id: '', meta: { created: 0, tags: [''] } }],\n}) {}\n\n// Good - extract complex types\nconst Item = { id: '', meta: { created: 0, tags: [''] } }\nfunction process(data: { items: [Item] }) {}\n```\n\n## Transpilation\n\nTJS transpiles to standard JavaScript:\n\n```javascript\n// Input (TJS)\nfunction greet(name: 'World') -> '' {\n  return `Hello, ${name}!`\n}\n\n// Output (JavaScript)\nfunction greet(name = 'World') {\n  return `Hello, ${name}!`\n}\ngreet.__tjs = {\n  params: { name: { type: 'string', required: true, default: 'World' } },\n  returns: { type: 'string' }\n}\n```\n\nThe output is valid ES modules that work with any bundler (Vite, esbuild, webpack, Bun).\n\n## Further Reading\n\n- [Benchmarks](./benchmarks.md) - Performance characteristics\n- [ajs.md](./ajs.md) - The sandboxed agent language\n- [API Documentation](./docs/) - Generated from source\n",
    "title": "TJS: Typed JavaScript",
    "filename": "tjs.md",
    "path": "guides/tjs.md"
  },
  {
    "text": "# tosijs-agent Guides\n\nDetailed documentation for tosijs-agent.\n\n## Language References\n\n- **[ajs.md](./ajs.md)** - AJS language reference (the main language for writing agents)\n- **[ajs-llm-prompt.md](./ajs-llm-prompt.md)** - System prompt for LLM code generation\n- **[tjs.md](./tjs.md)** - TJS (Typed JavaScript) specification\n\n## Patterns & Best Practices\n\n- **[patterns.md](./patterns.md)** - Common patterns and workarounds for AJS\n\n## Reference\n\n- **[tosijs-schema.md](./tosijs-schema.md)** - Guide to the tosijs-schema validation library\n- **[benchmarks.md](./benchmarks.md)** - Performance benchmarks\n\n## See Also\n\n- [README.md](../README.md) - Main project overview and quick start\n- [CONTEXT.md](../CONTEXT.md) - Technical architecture deep-dive\n",
    "title": "tosijs-agent Guides",
    "filename": "README.md",
    "path": "guides/README.md"
  },
  {
    "text": "# tosijs-agent Technical Context\n\n**Note:** This document provides a technical deep-dive into tosijs-agent's architecture and security model. For a general overview, installation instructions, and usage examples, please refer to the main [README.md](./README.md).\n\n**tosijs-agent** is a secure, environment-agnostic runtime for executing AI agents and logic chains defined as JSON ASTs.\n\n**Bundle Size:** ~17KB gzipped. Expressions are evaluated via lightweight AST nodes at runtime, eliminating the need for a parser library (the previous JSEP-based approach was ~50KB gzipped).\n\n## 1. Architecture\n\n### The Builder (`TypedBuilder`)\n\nA fluent TypeScript API that generates a portable JSON AST. It uses a `Proxy` to dynamically infer methods from the registered Atoms, providing a strongly-typed developer experience.\n\nIt is important to understand that the builder is only for constructing the AST; it does not contain any of the actual implementation logic for the atoms. All execution is handled by the Runtime.\n\n**Usage Pattern:**\n\n- All logic chains **must** start with `Agent.take()` to define the input schema for the agent.\n- Subsequent atom calls are chained together fluently (e.g., `.varSet(...)`, `.httpFetch(...)`). This creates an implicit `seq` (sequence) of operations.\n- The chain is terminated by calling `.toJSON()` to produce the serializable AST.\n\nYou can access the builder via `Agent` (for core atoms) or `vm.Agent` (the recommended way to access both core and any custom atoms registered with the VM instance).\n\n```typescript\nimport { Agent, s, AgentVM } from 'tosijs-agent'\n\n// Global Builder (Core Atoms)\nconst logic = Agent.take(s.object({ input: s.string }))\n  .varSet({ key: 'sum', value: { $expr: 'binary', op: '+', left: { $expr: 'literal', value: 1 }, right: { $expr: 'literal', value: 1 } } })\n\n// VM Builder (Custom Atoms)\nconst vm = new AgentVM({ myAtom })\nconst customLogic = vm.Agent\n  .myAtom({ ... })\n  .varSet({ ... })\n```\n\n### The Runtime (`AgentVM`)\n\nA stateless Virtual Machine that executes the AST. The runtime contains all the actual implementation logic for the atoms.\n\n- **Sandboxed:** No `eval()`. Math/Logic is evaluated safely via AST expression nodes.\n- **Resource Limited:** Enforces `fuel` (gas) limits and execution timeouts per atom.\n- **Capability-Based:** All IO (Network, DB, AI) must be injected via `capabilities` object.\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\nconst vm = new AgentVM()\nconst { result, fuelUsed } = await vm.run(ast, args, {\n  capabilities,\n  fuel: 1000,\n})\n```\n\n## 2. Expression Syntax (ExprNode)\n\nExpressions use AST expression nodes (`$expr`) for safe, sandboxed evaluation. Conditions in `if` and `while` atoms use expression strings that are parsed at transpile time.\n\nFor security, expressions are sandboxed and cannot directly access the agent's state. Use the `vars` parameter to explicitly pass variables from state into the expression scope.\n\n### ExprNode Types\n\n- **literal:** `{ $expr: 'literal', value: 5 }` - A constant value\n- **ident:** `{ $expr: 'ident', name: 'x' }` - A variable reference\n- **member:** `{ $expr: 'member', object: {...}, property: 'foo' }` - Property access\n- **binary:** `{ $expr: 'binary', op: '+', left: {...}, right: {...} }` - Binary operations\n- **unary:** `{ $expr: 'unary', op: '-', argument: {...} }` - Unary operations\n- **conditional:** `{ $expr: 'conditional', test: {...}, consequent: {...}, alternate: {...} }` - Ternary\n\n### Supported Operators\n\n- **Binary ops:** `+`, `-`, `*`, `/`, `%`, `**`\n- **Logic:** `&&`, `||`\n- **Comparison:** `==`, `!=`, `>`, `<`, `>=`, `<=`\n- **Member Access:** `obj.prop`, `arr[0]`\n\n### Security\n\n- **Forbidden:** Function calls, `new`, `this`, global access\n- **Blocked:** Prototype access (`__proto__`, `constructor`)\n\n### Fuel Consumption\n\nEach expression node evaluation consumes **0.01 fuel**. This prevents deeply nested or recursive expressions from running unchecked. A simple `a + b` costs ~0.03 fuel (two identifiers + one binary op), while complex nested expressions accumulate cost proportionally.\n\n## 3. Security Model\n\n- **Capabilities:** The VM has no default IO. You must provide `fetch`, `store`, etc., allowing you to mock, proxy, or limit access.\n- **Fuel:** Every atom consumes \"fuel\". Execution aborts if fuel reaches 0.\n- **Execution Timeout:** The VM enforces a global timeout based on fuel budget (see below).\n- **Atom Timeouts:** Individual atoms have a default timeout (1s) to prevent hangs.\n- **State Isolation:** Each run creates a fresh context. Scopes (loops/maps) use prototype inheritance to isolate local variables.\n\n### Execution Timeout\n\nThe VM enforces a hard timeout on execution to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n**How it works:**\n\n1. **Automatic Safety Net:** By default, timeout = `fuel × 10ms`. So 1000 fuel = 10 seconds. _For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n2. **Explicit SLA:** Pass `timeoutMs` to enforce a strict time limit regardless of fuel.\n3. **External Cancellation:** Pass an `AbortSignal` to integrate with external controllers (user cancellation, HTTP timeouts, etc.).\n\n```typescript\n// Default: 1000 fuel = 10 second timeout\nawait vm.run(ast, args, { fuel: 1000 })\n\n// Explicit timeout: 5 seconds regardless of fuel\nawait vm.run(ast, args, { fuel: 10000, timeoutMs: 5000 })\n\n// External abort signal\nconst controller = new AbortController()\nsetTimeout(() => controller.abort(), 3000) // Cancel after 3s\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom via `ctx.signal`. Loop atoms (`while`, `map`, `filter`, `reduce`, `find`) check the signal between iterations. `httpFetch` passes the signal to `fetch` for immediate request cancellation.\n\n**Timeout vs Fuel:**\n\n- **Fuel** protects against CPU-bound abuse (tight loops burning compute)\n- **Timeout** protects against IO-bound abuse (slow network calls, hung promises)\n\nBoth work together to ensure the VM cannot be held hostage by untrusted code.\n\n**Trust Boundary:** The sandbox protects against malicious _agents_ (untrusted AST), not malicious _atom implementations_. Atoms are registered by the host and are trusted to:\n\n1. Be non-blocking (no synchronous CPU-heavy work)\n2. Respect `ctx.signal` for cancellation\n3. Clean up resources when aborted\n\nIf you write custom atoms, ensure they check `ctx.signal?.aborted` in loops and pass `ctx.signal` to any async operations like `fetch`.\n\n### Cost Overrides\n\nDefault atom costs are guesses. Override them per-run to match your deployment reality:\n\n```typescript\nawait vm.run(ast, args, {\n  costOverrides: {\n    // Static: fixed cost per invocation\n    httpFetch: 50,\n    llmPredict: 500,\n\n    // Dynamic: cost based on input\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n  },\n})\n```\n\nUse cases:\n\n- **API rate limits:** Make external API calls expensive to stay under quota\n- **Metered billing:** Reflect actual dollar costs in fuel consumption\n- **Resource protection:** Make database writes cost more than reads\n- **Testing:** Set all costs to 0 to focus on logic, not budgeting\n\n### Request Context\n\nThe `context` option passes request-scoped metadata to atoms. Unlike `args` (agent input) or `capabilities` (IO implementations), context carries ambient data like auth, permissions, and request tracing.\n\n```typescript\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    role: 'admin',\n    permissions: ['read:data', 'write:data', 'fetch:external'],\n    requestId: 'req-abc-123',\n  },\n})\n```\n\nAtoms access it via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    // Check permissions\n    if (!ctx.context?.permissions?.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\n**Design rationale:**\n\n- **Immutable:** Context is read-only; agents cannot modify their own permissions\n- **Separate from args:** Auth data doesn't pollute the agent's input schema\n- **Separate from capabilities:** Same capability implementation, different authorization\n- **Composable:** Works with cost overrides for user-tier-based fuel costs\n\n**Production patterns:**\n\n```typescript\n// Firebase/Express integration\napp.post('/run-agent', async (req, res) => {\n  const ast = req.body.ast\n  const args = req.body.args\n\n  // Extract auth from request\n  const user = await verifyToken(req.headers.authorization)\n\n  const result = await vm.run(ast, args, {\n    context: {\n      userId: user.id,\n      role: user.role,\n      permissions: user.permissions,\n      requestId: req.id,\n    },\n    // User-tier-based costs\n    costOverrides: {\n      llmPredict: user.tier === 'premium' ? 10 : 100,\n    },\n  })\n\n  res.json(result)\n})\n```\n\n## 4. Stored Procedures\n\nThe procedure store provides a built-in mechanism for storing ASTs as callable tokens. This enables function-pointer-like patterns where behavior can be passed as data.\n\n### Storage Model\n\n```typescript\n// Module-level storage in runtime.ts\nconst procedureStore = new Map<\n  string,\n  {\n    ast: any\n    createdAt: number\n    expiresAt: number\n  }\n>()\n```\n\n**Constants:**\n\n- `PROCEDURE_TOKEN_PREFIX`: `'proc_'` - All tokens start with this prefix\n- `DEFAULT_PROCEDURE_TTL`: 3,600,000ms (1 hour)\n- `DEFAULT_MAX_AST_SIZE`: 102,400 bytes (100KB)\n\n### Token Resolution\n\nTokens can be used anywhere an AST is accepted:\n\n1. **`vm.run(token, args)`** - Direct execution via VM\n2. **`agentRun({ agentId: token, input })`** - Execution from within an agent\n3. **`agentRun({ agentId: ast, input })`** - Raw AST also accepted (no storage needed)\n\nResolution happens at runtime. If a string starts with `proc_`, the VM looks it up in the store. Expired or missing tokens throw clear errors.\n\n### Fuel Costs\n\n| Atom                     | Cost | Notes                           |\n| ------------------------ | ---- | ------------------------------- |\n| `storeProcedure`         | 1.0  | Plus 0.001 per byte of AST      |\n| `releaseProcedure`       | 0.5  | Constant                        |\n| `clearExpiredProcedures` | 0.5  | Plus 0.01 per procedure scanned |\n\n### Security Considerations\n\n**Memory bounds:** The `maxSize` parameter prevents storing arbitrarily large ASTs. Default 100KB is generous for most agents.\n\n**Expiry:** TTL prevents memory leaks from abandoned procedures. The store is in-memory, so procedures don't survive process restarts.\n\n**No capability escalation:** Stored procedures inherit the capabilities of the calling context, not the storing context. A malicious agent cannot store a procedure that later executes with elevated privileges.\n\n**Token predictability:** Tokens are UUIDs, not sequential. They cannot be enumerated or guessed.\n\n### Use Cases\n\n**Dynamic dispatch (strategy pattern):**\n\n```typescript\nconst strategies = ajs`\n  function dispatch({ strategyToken, data }) {\n    let result = agentRun({ agentId: strategyToken, input: { data } })\n    return result\n  }\n`\n```\n\n**Worker pool:**\n\n```typescript\nconst orchestrator = ajs`\n  function orchestrate({ workers, tasks }) {\n    let results = []\n    for (let i = 0; i < tasks.length; i = i + 1) {\n      let workerToken = workers[i % workers.length]\n      let r = agentRun({ agentId: workerToken, input: tasks[i] })\n      results.push(r)\n    }\n    return { results }\n  }\n`\n```\n\n**Callback registration:**\n\n```typescript\nconst registerCallback = ajs`\n  function register({ handler }) {\n    let token = storeProcedure({ ast: handler, ttl: 300000 })\n    return { callbackId: token }\n  }\n`\n```\n\n## 5. Production Considerations\n\n### Recursive Agent Fuel\n\nWhen an agent calls sub-agents via `agentRun`, each sub-agent gets its own fuel budget (passed via the capability). Fuel is **not shared** across the call tree by default.\n\n**Why:** The `agentRun` atom delegates to `ctx.capabilities.agent.run`, which the host implements. This gives operators full control over sub-agent resource allocation.\n\n**Patterns for shared fuel:**\n\n```typescript\n// Option 1: Pass remaining fuel to children\nconst sharedFuel = { current: 1000 }\n\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      if (sharedFuel.current <= 0) throw new Error('Out of shared fuel')\n      const result = await vm.run(agents[agentId], input, {\n        fuel: sharedFuel.current,\n        capabilities: caps,\n      })\n      sharedFuel.current -= result.fuelUsed\n      return result.result\n    },\n  },\n}\n\n// Option 2: Fixed budget per recursion depth\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      // Each child gets 10% of parent's budget\n      return vm.run(agents[agentId], input, {\n        fuel: 100, // Fixed small budget\n        capabilities: caps,\n      })\n    },\n  },\n}\n```\n\n### Streaming and Long-Running Agents\n\nThe VM returns results only after complete execution. For long-running agents:\n\n- Use `timeoutMs` to enforce SLAs\n- Use `AbortSignal` for user-initiated cancellation\n- Use `trace: true` for post-hoc debugging\n\n**For real-time streaming**, implement a custom atom that emits intermediate results:\n\n```typescript\nconst streamingAtom = defineAtom(\n  'streamChunk',\n  s.object({ data: s.any }),\n  s.null,\n  async ({ data }, ctx) => {\n    // ctx.context contains your streaming callback\n    await ctx.context?.onChunk?.(data)\n    return null\n  }\n)\n\n// Usage\nawait vm.run(ast, args, {\n  context: {\n    onChunk: (data) => res.write(JSON.stringify(data) + '\\n'),\n  },\n})\n```\n\n### Condition String Syntax\n\nThe condition parser in `if`/`while` atoms supports a subset of expression syntax:\n\n| Supported     | Example                           |\n| ------------- | --------------------------------- |\n| Comparisons   | `a > b`, `x == 'hello'`, `n != 0` |\n| Logical       | `a && b`, `a \\|\\| b`, `!a`        |\n| Arithmetic    | `a + b * c`, `(a + b) / c`        |\n| Member access | `obj.foo.bar`                     |\n| Literals      | `42`, `\"string\"`, `true`, `null`  |\n\n| **Unsupported**        | Alternative                        |\n| ---------------------- | ---------------------------------- |\n| Ternary `a ? b : c`    | Use nested `if` atoms              |\n| Array index `a[0]`     | Use ExprNode with `computed: true` |\n| Function calls `fn(x)` | Use atoms                          |\n| Chained `a > b > c`    | Use `a > b && b > c`               |\n\nUnsupported syntax now throws a clear error at build time with suggestions.\n\n### State Semantics\n\nAgents are **not transactional**. If an atom fails mid-execution:\n\n- Previous state changes persist\n- No automatic rollback\n- Error is captured in monadic flow (`ctx.error`)\n\nThis is by design—agents are stateful pipelines, not database transactions. If you need atomicity, implement checkpoint/restore in your capabilities:\n\n```typescript\nconst caps = {\n  store: {\n    set: async (key, value) => {\n      await db.runTransaction(async (tx) => {\n        await tx.set(key, value)\n      })\n    },\n  },\n}\n```\n\n### Error Handling Granularity\n\nThe `try/catch` atom catches all errors in the try block. There's no selective catch by error type.\n\n**Pattern for error type handling:**\n\n```typescript\nAgent.take(s.object({})).try({\n  try: (b) => b.httpFetch({ url: '...' }).as('response'),\n  catch: (b) =>\n    b\n      .varSet({ key: 'errorType', value: 'unknown' })\n      // Check error message patterns\n      .if(\n        'msg.includes(\"timeout\")',\n        { msg: 'error.message' },\n        (then) => then.varSet({ key: 'errorType', value: 'timeout' }),\n        (el) =>\n          el.if('msg.includes(\"404\")', { msg: 'error.message' }, (then) =>\n            then.varSet({ key: 'errorType', value: 'not_found' })\n          )\n      ),\n})\n```\n\n## 9. Test Coverage\n\n**Summary (as of January 2025):**\n\n| Metric    | Value  |\n| --------- | ------ |\n| Tests     | 508    |\n| Functions | 84.77% |\n| Lines     | 80.36% |\n\n### Coverage by Component\n\n**Core Runtime (security-critical):**\n\n| File                      | Functions | Lines   | Notes                        |\n| ------------------------- | --------- | ------- | ---------------------------- |\n| `src/runtime.ts`          | 100%      | 100%    | Re-exports                   |\n| `src/vm.ts`               | 100%      | 100%    | Re-exports                   |\n| `src/vm/runtime.ts`       | 84%       | **98%** | Atoms, expression eval, fuel |\n| `src/vm/vm.ts`            | 90%       | 94%     | VM entry point               |\n| `src/transpiler/index.ts` | 100%      | 100%    | AJS transpiler               |\n| `src/builder.ts`          | 92%       | 90%     | Fluent builder               |\n\n**Language/Transpiler:**\n\n| File                       | Functions | Lines | Notes                           |\n| -------------------------- | --------- | ----- | ------------------------------- |\n| `src/lang/emitters/ast.ts` | 94%       | 83%   | TJS → AST                       |\n| `src/lang/parser.ts`       | 92%       | 82%   | TJS parser                      |\n| `src/lang/inference.ts`    | 57%       | 60%   | Type inference (lower priority) |\n\n**Test Categories:**\n\n| Category                   | Tests | Coverage                                             |\n| -------------------------- | ----- | ---------------------------------------------------- |\n| Security (malicious actor) | 10    | Prototype access, SSRF, ReDoS, path traversal        |\n| Runtime core               | 25+   | Fuel, timeout, tracing, expressions                  |\n| Stress/Memory              | 6     | Large arrays, deep nesting, memory pressure          |\n| Capability failures        | 10    | Network errors, store failures, partial capabilities |\n| Allocation fuel            | 4     | Proportional charging for strings/arrays             |\n| Transpiler                 | 50+   | Language features, edge cases                        |\n| Use cases                  | 100+  | RAG, orchestration, client-server patterns           |\n\n### Running Tests\n\n```bash\n# Full suite\nbun test\n\n# Fast (skip LLM and benchmarks)\nSKIP_LLM_TESTS=1 AGENT99_TESTS_SKIP_BENCHMARKS=1 bun test\n\n# With coverage\nbun test --coverage\n```\n\n## 10. Dependencies\n\n### Runtime Dependencies\n\nThese ship with the library and affect bundle size and security posture.\n\n| Package         | Version | Size  | Purpose                                     | Risk                                                 |\n| --------------- | ------- | ----- | ------------------------------------------- | ---------------------------------------------------- |\n| `acorn`         | ^8.15.0 | ~30KB | JavaScript parser for AJS transpilation     | **Low** - Mature, widely audited, Mozilla-maintained |\n| `tosijs-schema` | ^1.2.0  | ~5KB  | JSON Schema validation                      | **Low** - Our library, 96.6% coverage, zero deps     |\n| `@codemirror/*` | various | ~50KB | Editor syntax highlighting (optional)       | **Low** - Only loaded for editor integration         |\n\n**Total runtime footprint:** ~33KB gzipped (core), ~83KB with editor support.\n\n### tosijs-schema 1.2.0 Coverage\n\nOur validation dependency maintains comprehensive test coverage:\n\n- **98.25% function coverage, 96.62% line coverage** (146 tests, 349 assertions)\n- **Edge cases tested:** NaN, Infinity, -0, sparse arrays, unicode, deeply nested structures\n- **Complex unions:** nested unions, discriminated unions, union of arrays, union with null/undefined\n- **Format validators:** email, ipv4 boundaries, url protocols, datetime variants\n- **Strict mode:** `validate(data, schema, { strict: true })` validates every item\n\nBecause tosijs-schema schemas are JSON data (not code), library coverage extends to user-defined schemas—unlike Zod where user schema compositions are untested code.\n\n### Development Dependencies\n\nNot shipped to users. Used for building, testing, and development.\n\n| Package                | Purpose                       | Notes                   |\n| ---------------------- | ----------------------------- | ----------------------- |\n| `typescript`           | Type checking and compilation | Standard                |\n| `bun`                  | Runtime, bundler, test runner | Fast, modern            |\n| `eslint` / `prettier`  | Code quality                  | Standard                |\n| `acorn-walk`           | AST traversal for transpiler  | Only used at build time |\n| `codemirror`           | Editor components for demo    | Demo only               |\n| `tosijs` / `tosijs-ui` | Demo UI framework             | Demo only               |\n| `happy-dom`            | DOM mocking for tests         | Test only               |\n| `vitest`               | Alternative test runner       | Optional                |\n\n### Dependency Risk Assessment\n\n**Supply Chain:**\n\n| Risk                     | Mitigation                                               |\n| ------------------------ | -------------------------------------------------------- |\n| Acorn compromise         | Mature project (10+ years), Mozilla backing, widely used |\n| tosijs-schema compromise | We control this library                                  |\n| Transitive dependencies  | Minimal—acorn has 0 deps, tosijs-schema has 0 deps       |\n\n**Version Pinning:**\n\n- Production dependencies use caret (`^`) for patch updates\n- Consider using exact versions or lockfile for production deployments\n\n**Audit:**\n\n```bash\n# Check for known vulnerabilities\nbun audit\n# or\nnpm audit\n```\n\n### What We Don't Depend On\n\nNotably absent from our dependency tree:\n\n| Common Dependency | Why We Don't Use It                     |\n| ----------------- | --------------------------------------- |\n| lodash            | Native JS methods suffice               |\n| axios             | Native fetch + capability injection     |\n| moment/dayjs      | Built-in Date wrapper in expressions    |\n| zod/yup           | tosijs-schema is lighter and sufficient |\n| jsep              | Replaced with acorn + custom AST nodes  |\n\nThis minimal dependency approach reduces supply chain risk and bundle size.\n",
    "title": "tosijs-agent Technical Context",
    "filename": "CONTEXT.md",
    "path": "CONTEXT.md"
  },
  {
    "text": "# Using Haltija with tosijs-agent\n\nThis project uses [Haltija](https://github.com/tonioloewald/haltija) for AI-assisted browser debugging and testing.\n\n## Quick Start\n\n```bash\n# Terminal 1: Start tosijs-agent playground\nbun run dev\n\n# Terminal 2: Start haltija\ncd ~/Documents/GitHub/haltija\nbunx haltija\n```\n\nThen add this one-liner to your browser console or the app's entry point:\n\n```javascript\n;/^localhost$|^127\\./.test(location.hostname) &&\n  import('http://localhost:8700/dev.js')\n```\n\n## Why We Use It\n\nBefore haltija, debugging frontend issues was painful:\n\n1. Describe what's wrong → AI guesses → doesn't work → repeat\n2. Screenshots, copy-pasted HTML, \"it's still not working\"\n3. Context lost, velocity destroyed\n\nWith haltija:\n\n1. AI sees the actual DOM via `/tree`\n2. Understands immediately: \"the selector expects `.tab-bar > .active` but structure is `.tab-bar > .tab-container > .tab.active`\"\n3. Fixes it in one shot\n\n## Common Commands\n\n```bash\n# What page am I on?\ncurl http://localhost:8700/location\n\n# See DOM structure\ncurl -X POST http://localhost:8700/tree -d '{\"selector\":\"body\",\"depth\":3}'\n\n# Find all buttons\ncurl -X POST http://localhost:8700/inspectAll -d '{\"selector\":\"button\"}'\n\n# Click something\ncurl -X POST http://localhost:8700/click -d '{\"selector\":\"#submit\"}'\n\n# Watch for DOM changes\ncurl -X POST http://localhost:8700/mutations/watch -d '{\"preset\":\"smart\"}'\ncurl http://localhost:8700/messages\n\n# Full docs\ncurl http://localhost:8700/docs\n```\n\n## Semantic Events (for debugging)\n\nInstead of raw DOM events, haltija captures meaningful actions:\n\n- `input:typed` - \"user typed 'hello@example.com'\"\n- `interaction:click` - \"user clicked Submit button\"\n- `navigation:navigate` - \"user went from /login to /dashboard\"\n\n```bash\ncurl -X POST http://localhost:8700/events/watch -d '{\"preset\":\"interactive\"}'\ncurl http://localhost:8700/events\n```\n\n## Reference Docs\n\n```bash\n# List available docs\ncurl http://localhost:8700/docs/list\n\n# UX anti-patterns database\ncurl http://localhost:8700/docs/ux-crimes\n```\n\n## Repo Location\n\nHaltija source: `~/Documents/GitHub/haltija`\n",
    "title": "Using Haltija with tosijs-agent",
    "filename": ".haltija.md",
    "path": ".haltija.md"
  }
]