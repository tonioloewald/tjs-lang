[
  {
    "text": "<!--{\"pin\": \"top\"}-->\n\n# tosijs-agent\n\n[github](https://github.com/tonioloewald/tosijs-agent#readme) | [npm](https://www.npmjs.com/package/tosijs-agent) | [discord](https://discord.gg/ramJ9rgky5)\n\n<img src=\"/tosijs-agent.svg\" alt=\"tosijs-agent logo\" width=\"300\" height=\"300\">\n\nA **type-safe-by-design, cost-limited virtual machine** that enables the **safe execution of untrusted code** anywhere.\n\nIt's **safe eval** in the cloud.\n\nAnd it's **tiny**, ![bundlejs bundle including dependencies](https://deno.bundlejs.com/badge?q=tosijs-agent).\n\ntosijs-agent allows you to define complex logic chains, agents, and data pipelines—_computer programs_—using a fluent TypeScript builder. These definitions compile to a safe, JSON-serializable AST ([Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)) that can be executed in the browser, on the server, or at the edge.\n\nFor a deeper dive into the architecture and security model, see the [Technical Context](./CONTEXT.md).\n\n### Why do you care?\n\n- **Service-as-a-Service:** Define a complete backend service—including database fetches, API calls, and logic—entirely as data, and execute it safely on a server.\n- **Agents-as-Data:** Build AI agents entirely as JSON objects. Send them to a server to run instantly—no deployment, no build steps, no spin-up time.\n- **Universal Runtime:** Run your agent logic in the browser for zero-latency UI updates, or move it to the server for heavy lifting. Because the AST is strongly typed JSON, it is easy to build a runtime for any language or hardware stack, or even compile it directly to LLVM.\n\n### The Holy Grail\n\ntosijs-agent solves fundamental problems in distributed computing:\n\n- **Safe \"Useful Mining\":** Allows distributed nodes to execute productive, arbitrary work safely (sandboxed & gas-limited) — e.g. replacing Proof-of-Work with distributed data processing.\n- **Code is Data:** Logic is defined as a portable AST, making execution language-agnostic and portable.\n- **True Network Agents:** Write code that travels to the data, rather than moving petabytes of data to the code.\n- **Type-Safe Composition:** Build robust pipelines where inputs and outputs are strictly validated at every step.\n\n## Comparison: tosijs-agent vs LangChain\n\nConsider building a \"Research Agent\" that searches for a topic, summarizes it, critiques the summary, and refines the search if needed.\n\n### LangChain\n\nRequires defining Tools, PromptTemplates, Chains (or Graph nodes), and wiring them up with complex state management classes. To refine the logic, you must redeploy the application code.\n\n### tosijs-agent\n\nThe entire logic is a single, fluent expression that compiles to JSON. You can refine the agent's behavior by simply sending a new JSON payload to the server—no deployment required.\n\n```typescript\n// Research Agent: Search -> Summarize -> Critique -> Loop\nconst agent = Agent.take(s.object({ topic: s.string })).while(\n  '!good && tries < 3',\n  {},\n  (loop) =>\n    loop\n      .storeSearch({ query: 'topic' })\n      .as('results')\n      .llmPredict({ system: 'Summarize', user: 'results' })\n      .as('summary')\n      .llmPredict({ system: 'Critique', user: 'summary' })\n      .as('feedback')\n      .if(\n        'feedback == \"OK\"',\n        {},\n        (yes) => yes.varSet({ key: 'good', value: true }),\n        (no) => no.llmPredict({ system: 'Refine', user: 'topic' }).as('topic')\n      )\n)\n```\n\n## Interactive Example: Cover Version Finder\n\nThis example shows the complete loop: a UI form captures user input, AsyncJS code processes it (calling an API and using an LLM to analyze results), and displays the output with album artwork.\n\n```css\n.cover-finder {\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  box-sizing: border-box;\n}\n.cover-finder form {\n  display: flex;\n  gap: 8px;\n  margin-bottom: 16px;\n  flex-wrap: wrap;\n  flex-shrink: 0;\n}\n.cover-finder input {\n  padding: 8px 12px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  flex: 1;\n  min-width: 120px;\n}\n.cover-finder button {\n  padding: 8px 20px;\n  background: #6366f1;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n.cover-finder #results {\n  flex: 1;\n  overflow-y: auto;\n  min-height: 0;\n}\n.cover-finder .cover-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));\n  gap: 16px;\n}\n.cover-finder .cover-card {\n  background: #f5f5f5;\n  border-radius: 8px;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n.cover-finder .cover-card img {\n  width: 100%;\n  aspect-ratio: 1;\n  object-fit: cover;\n}\n.cover-finder .cover-card .info {\n  padding: 10px;\n  flex: 1;\n}\n.cover-finder .cover-card .track {\n  font-weight: bold;\n  font-size: 0.9em;\n  margin-bottom: 4px;\n  line-height: 1.2;\n}\n.cover-finder .cover-card .artist {\n  color: #666;\n  font-size: 0.85em;\n  line-height: 1.2;\n}\n```\n\n```html\n<div class=\"cover-finder\">\n  <form id=\"cover-search\">\n    <input type=\"text\" id=\"song\" placeholder=\"Song name\" value=\"Yesterday\" />\n    <input\n      type=\"text\"\n      id=\"artist\"\n      placeholder=\"Original artist\"\n      value=\"Beatles\"\n    />\n    <button type=\"submit\">Find Covers</button>\n  </form>\n  <div id=\"results\"></div>\n</div>\n```\n\n```js\n// Wire up the form to AsyncJS\n// Uses demoRuntime which gets LLM settings from the Settings dialog\nimport { ajs } from 'tosijs-agent'\n\n// The AsyncJS code - searches iTunes and uses LLM to find covers\nconst findCovers = ajs`\n  function findCovers({ song, artist }) {\n    let query = song + ' ' + artist\n    let url = \\`https://itunes.apple.com/search?term=\\${query}&limit=25&media=music\\`\n    let raw = httpFetch({ url, cache: 3600 })\n    let itunesData = JSON.parse(raw)\n    \n    let results = itunesData.results || []\n    \n    // Build track list with indices for the LLM\n    let tracks = []\n    let i = 0\n    for (let x of results) {\n      tracks.push(\\`[\\${i}] \"\\${x.trackName}\" by \\${x.artistName} (\\${x.collectionName})\\`)\n      i = i + 1\n    }\n    let trackList = tracks.join('\\\\n')\n    \n    // Schema.response builds the responseFormat structure from an example\n    let schema = Schema.response('cover_versions', {\n      covers: [{ index: 0, track: '', artist: '', album: '' }]\n    })\n    \n    let prompt = \\`Search results for \"\\${song}\" by \\${artist}:\n\n\\${trackList}\n\nList cover versions (tracks NOT by \\${artist}). Include the index number.\\`\n\n    let llmResponse = llmPredict({ prompt, options: { responseFormat: schema } })\n    let parsed = JSON.parse(llmResponse)\n    \n    // Return covers with itunesData for artwork lookup in JS\n    return { song, artist, covers: parsed.covers, itunesData }\n  }\n`\n\n// Handle form submission\ndocument.getElementById('cover-search').onsubmit = async (e) => {\n  e.preventDefault()\n  const resultsDiv = document.getElementById('results')\n  resultsDiv.textContent = 'Searching...'\n\n  // demoRuntime uses API keys from Settings dialog\n  const { result, error } = await demoRuntime.run(\n    findCovers,\n    {\n      song: document.getElementById('song').value,\n      artist: document.getElementById('artist').value,\n    },\n    { fuel: 5000 }\n  )\n\n  if (error) {\n    resultsDiv.textContent = `Error: ${error.message}`\n  } else if (result.covers.length === 0) {\n    resultsDiv.textContent = 'No cover versions found.'\n  } else {\n    const itunesResults = result.itunesData?.results || []\n    // Match covers to artwork using index from results\n    const covers = result.covers.map((c) => {\n      const source = itunesResults[c.index]\n      return {\n        ...c,\n        artwork: source?.artworkUrl100?.replace('100x100', '200x200'),\n      }\n    })\n    resultsDiv.innerHTML = `<h3>Cover versions of \"${result.song}\":</h3>\n      <div class=\"cover-grid\">${covers\n        .map((c) =>\n          c.artwork\n            ? `\n        <div class=\"cover-card\">\n          <img src=\"${c.artwork}\" alt=\"${c.album || 'Album art'}\">\n          <div class=\"info\">\n            <div class=\"track\">${c.track || 'Unknown track'}</div>\n            <div class=\"artist\">${c.artist || 'Unknown artist'}</div>\n          </div>\n        </div>`\n            : `\n        <div class=\"cover-card\">\n          <div class=\"info\" style=\"padding-top:60px\">\n            <div class=\"track\">${c.track || 'Unknown track'}</div>\n            <div class=\"artist\">${c.artist || 'Unknown artist'}</div>\n          </div>\n        </div>`\n        )\n        .join('')}\n      </div>`\n  }\n}\n```\n\nThis demonstrates:\n\n- **Safe execution**: The AsyncJS code runs in a sandboxed VM with fuel limits\n- **Structured output**: JSON schema guarantees valid response format from the LLM\n- **Capability injection**: LLM access is provided by the host, not the untrusted code\n- **Portable logic**: The `findCovers` AST could be sent to a server for execution instead\n\n## Example Project\n\nTo see a complete, working example of how to build an agent with a simple UI, check out the official playground project:\n\n**[https://github.com/brainsnorkel/agent99-playground](https://github.com/brainsnorkel/agent99-playground)**\n\n## Installation\n\n```bash\nbun add tosijs-agent\n# or\nnpm install tosijs-agent\n```\n\n## Quick Start\n\n### 1. Write Logic (AsyncJS)\n\nWrite agents in AsyncJS—a JavaScript subset that compiles to a safe, serializable AST.\n\n```typescript\nimport { ajs, AgentVM } from 'tosijs-agent'\n\n// Define a calculation agent using familiar JavaScript syntax\nconst calculateTotal = ajs`\n  function calculate({ price, taxRate }) {\n    let total = price * (1 + taxRate)\n    return { total }\n  }\n`\n\n// Run it\nconst vm = new AgentVM()\nconst result = await vm.run(calculateTotal, { price: 100, taxRate: 0.2 })\n\nconsole.log(result.result) // { total: 120 }\nconsole.log(result.fuelUsed) // Fuel consumed\n```\n\nAsyncJS supports most JavaScript expressions, loops, try/catch, and more. See [ASYNCJS.md](./ASYNCJS.md) for the full language reference.\n\n### 2. Advanced: The Builder API\n\nFor programmatic AST construction (e.g., dynamic agent generation, metaprogramming), use the fluent builder:\n\n```typescript\nimport { Agent, s } from 'tosijs-agent'\n\nconst calculateTotal = Agent.take(\n  s.object({ price: s.number, taxRate: s.number })\n)\n  .varSet({\n    key: 'total',\n    value: {\n      $expr: 'binary',\n      op: '*',\n      left: Agent.args('price'),\n      right: {\n        $expr: 'binary',\n        op: '+',\n        left: { $expr: 'literal', value: 1 },\n        right: Agent.args('taxRate'),\n      },\n    },\n  })\n  .return(s.object({ total: s.number }))\n\nconst ast = calculateTotal.toJSON() // JSON-serializable AST\n```\n\nThe Builder is lower-level but gives you full control over AST construction.\n\n## Tracing and Debugging\n\nFor debugging and testing, you can enable trace mode to get a detailed log of the agent's execution path.\n\n```typescript\nconst { result, trace } = await vm.run(\n  ast,\n  { price: 100, taxRate: 0.2 },\n  { trace: true } // Enable trace mode\n)\n\nconsole.log(trace)\n```\n\nThe `trace` output is an array of `TraceEvent` objects, where each event records the state of the agent before and after an atom's execution, along with the inputs, outputs, and fuel consumption.\n\n```typescript\ninterface TraceEvent {\n  op: string\n  input: any\n  stateBefore: any\n  stateAfter: any\n  result?: any\n  error?: string\n  fuelBefore: number\n  fuelAfter: number\n  timestamp: string\n}\n```\n\n## Core Atoms\n\nThe standard library includes essential primitives:\n\n| Category         | Atoms                                                              | Description                                                                                                           |\n| ---------------- | ------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |\n| **Flow**         | `seq`, `if`, `while`, `return`, `try`                              | Control flow and loops.                                                                                               |\n| **State**        | `varSet`, `varGet`, `varsLet`, `varsImport`, `varsExport`, `scope` | Variable management, including batch operations for importing variables from arguments and exporting them as results. |\n| **Expressions**  | ExprNode (`$expr`)                                                 | Safe expression evaluation via AST nodes (binary, unary, member, etc.).                                               |\n| **Logic**        | `eq`, `gt`, `and`, `not`, ...                                      | Boolean logic.                                                                                                        |\n| **IO**           | `httpFetch`                                                        | HTTP requests.                                                                                                        |\n| **Store**        | `storeGet`, `storeSet`                                             | Key-Value storage.                                                                                                    |\n| **AI**           | `llmPredict`, `agentRun`                                           | LLM calls and sub-agent recursion.                                                                                    |\n| **Utils**        | `random`, `uuid`, `hash`                                           | Random generation, UUIDs, and hashing.                                                                                |\n| **Optimization** | `memoize`, `cache`                                                 | In-memory memoization and persistent caching. Keys are optional and will be auto-generated if not provided.           |\n\n## Expression Builtins\n\nAsyncJS expressions have access to safe built-in objects:\n\n| Builtin  | Description                                                                 |\n| -------- | --------------------------------------------------------------------------- |\n| `Math`   | All standard math functions (`abs`, `floor`, `sqrt`, `sin`, `random`, etc.) |\n| `JSON`   | `parse()` and `stringify()`                                                 |\n| `Array`  | `isArray()`, `from()`, `of()`                                               |\n| `Object` | `keys()`, `values()`, `entries()`, `fromEntries()`, `assign()`              |\n| `String` | `fromCharCode()`, `fromCodePoint()`                                         |\n| `Number` | Constants and type checks (`MAX_VALUE`, `isNaN`, `isFinite`, etc.)          |\n| `Set`    | Set-like operations with `add`, `remove`, `union`, `intersection`, `diff`   |\n| `Date`   | Date factory with arithmetic and formatting                                 |\n| `Schema` | Schema builder for structured LLM responses (see below)                     |\n| `filter` | Schema-based data filtering                                                 |\n\n### Schema Builder\n\nThe `Schema` builtin exposes [tosijs-schema](https://github.com/nicholascross/tosijs-schema)'s fluent API for building JSON Schemas. This is especially useful for LLM structured outputs.\n\n```javascript\n// Simple: build responseFormat from an example object\nlet schema = Schema.response('person', { name: '', age: 0 })\n\n// With constraints: use the fluent API\nlet schema = Schema.response(\n  'user',\n  Schema.object({\n    email: Schema.string.email,\n    age: Schema.number.int.min(0).max(150).optional,\n    role: Schema.enum(['admin', 'user', 'guest']),\n  })\n)\n```\n\n**Available methods:**\n\n| Category        | Methods                                                                   |\n| --------------- | ------------------------------------------------------------------------- |\n| **Primitives**  | `string`, `number`, `integer`, `boolean`, `any`                           |\n| **String**      | `.min(n)`, `.max(n)`, `.pattern(regex)`, `.email`, `.url`, `.uuid`        |\n| **Number**      | `.min(n)`, `.max(n)`, `.step(n)`, `.int`                                  |\n| **Combinators** | `array(items)`, `object(props)`, `record(value)`, `tuple(items)`          |\n| **Union/Enum**  | `union([...])`, `enum([...])`, `const(value)`                             |\n| **Metadata**    | `.title(s)`, `.describe(s)`, `.default(v)`, `.optional`                   |\n| **Helpers**     | `response(name, schema)`, `fromExample(example)`, `isValid(data, schema)` |\n\n## Capabilities & Security\n\ntosijs-agent uses a **[Capability-Based Security](https://en.wikipedia.org/wiki/Capability-based_security)** model. The VM cannot access the network, file system, or database unless provided with a Capability.\n\n**Zero Config Defaults:** The runtime provides sensible defaults for local development:\n\n- `httpFetch` uses the global `fetch`.\n- `store` uses an in-memory `Map` (ephemeral).\n- `random`/`uuid` use `crypto` or `Math`.\n\nIn production, you should inject secure, instrumented, or cloud-native implementations (e.g., restricted fetch, Postgres, Redis).\n\n### Execution Timeout\n\nThe VM enforces a hard timeout to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n- **Automatic Safety Net:** Defaults to `fuel × 10ms` (e.g., 1000 fuel ≈ 10s budget). _Note: For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n- **Explicit Control:** Pass `timeoutMs` to enforce a strict Service Level Agreement (SLA).\n- **Cancellation:** Pass an `AbortSignal` to integrate with external cancellation controllers (e.g., user cancellation buttons or HTTP request timeouts).\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom (via `ctx.signal`). Atoms implementing cancellation (like `httpFetch`) will abort their network requests immediately.\n\n```typescript\n// 1. Default Safety Net (good for compute-heavy logic)\nawait vm.run(ast, args, { fuel: 1000 })\n\n// 2. SLA Enforcement: \"This agent must finish in 5s or we drop it\"\nawait vm.run(ast, args, { fuel: 5000, timeoutMs: 5000 })\n\n// 3. User Cancellation: connect UI \"Stop\" button to the Agent\nconst controller = new AbortController()\nstopButton.onClick(() => controller.abort())\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Fuel vs Timeout:** Fuel protects against CPU-bound abuse (tight loops). Timeout protects against IO-bound abuse (slow network calls). Together they ensure the VM cannot be held hostage.\n\n### Cost Overrides\n\nDefault fuel costs are context-agnostic guesses. In production, you'll want to tune costs for your specific deployment—an LLM call to a local model vs OpenAI has very different resource implications.\n\n```typescript\n// Static overrides\nawait vm.run(ast, args, {\n  fuel: 1000,\n  costOverrides: {\n    httpFetch: 50, // We pay per API request\n    llmPredict: 500, // LLM calls are expensive\n    storeGet: 0.5, // Redis is cheap\n  },\n})\n\n// Dynamic overrides based on input\nawait vm.run(ast, args, {\n  costOverrides: {\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n  },\n})\n```\n\nThis lets operators tune fuel costs for their reality rather than relying on universal defaults.\n\n### Request Context\n\nFor production deployments, you often need to pass request-scoped metadata (auth, permissions, request IDs) to atoms. The `context` option provides a clean mechanism for this.\n\n```typescript\n// Pass auth/permissions from your request handler\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    permissions: ['read:data', 'fetch:external'],\n    requestId: crypto.randomUUID(),\n  },\n})\n```\n\nAtoms access context via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    const permissions = ctx.context?.permissions ?? []\n    if (!permissions.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\nUse cases:\n\n- **Authorization:** Check user permissions before executing sensitive operations\n- **Multi-tenancy:** Route storage/database calls to tenant-specific resources\n- **Audit logging:** Include request IDs in all log entries\n- **Dynamic costs:** Combine with `costOverrides` for user-tier-based pricing\n\n**Security Note:** The sandbox protects against malicious _agents_, not malicious _atom implementations_. Atoms are registered by the host and are trusted to be non-blocking and to respect `ctx.signal` for cancellation.\n\n## Batteries Included (Zero-Dependency Local AI)\n\nFor local AI development, Agent99 provides a \"Batteries Included\" setup that runs out-of-the-box with **zero external dependencies or API keys**. It features a built-in vector search and connects to [LM Studio](https://lmstudio.ai/) for local model inference.\n\n### 1. Setup LM Studio\n\nTo use the batteries, you need to have LM Studio running in the background.\n\n1.  **Download and Install:** Get LM Studio from [lmstudio.ai](https://lmstudio.ai/).\n2.  **Download Models:** You'll need at least one LLM and one embedding model. We recommend:\n    - **LLM:** Search for a [GGUF](https://github.com/ggerganov/ggml/blob/master/docs/gguf.md) model like `Meta-Llama-3-8B-Instruct.Q4_K_M.gguf` for a good balance of performance and size.\n    - **Embedding:** Search for `nomic-embed-text-v1.5.Q8_0.gguf`.\n3.  **Start the Server:** Go to the \"Local Server\" tab (icon: `<-->`) and click \"Start Server\".\n\n### 2. How it Works\n\nWhen you first import the `batteries` from `tosijs-agent`, the runtime performs a one-time audit of the models available on your LM Studio server. It automatically detects which models are for embeddings and which are for chat, and caches the results to avoid re-auditing during the same session.\n\nThis allows Agent99 to automatically select the correct models for different tasks without any configuration. The cache uses `localStorage` if available (in a browser environment), or a simple in-memory cache otherwise.\n\n### 3. Usage\n\nThe `batteries` export contains the necessary capabilities. To use them, register the `batteryAtoms` with the `AgentVM` and pass the `batteries` object to the `run` method's capabilities.\n\n> **Note on Breaking Change:** Previously, battery atoms were exported individually. They are now consolidated into a single `batteryAtoms` object. This simplifies registration with the `AgentVM`.\n>\n> **Old Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, storeVectorize, storeSearch } from 'tosijs-agent'\n> const vm = new AgentVM({ storeVectorize, storeSearch, ... })\n> ```\n>\n> **New Way:**\n>\n> ```typescript\n> import { AgentVM, batteries, batteryAtoms } from 'tosijs-agent'\n> const vm = new AgentVM(batteryAtoms)\n> ```\n\n```typescript\nimport { AgentVM, batteries, batteryAtoms, Agent } from 'tosijs-agent'\n\n// Register the battery atoms\nconst vm = new AgentVM(batteryAtoms)\n\n// The batteries are audited on import.\nconst logic = vm.Agent.storeVectorize({ text: 'Hello' }).as('vector')\n\nconst { result } = await vm.run(logic.toJSON(), {}, { capabilities: batteries })\n\nconsole.log(result)\n```\n\n### 4. Vector Search Performance\n\nThe built-in vector search is implemented with a highly optimized **[cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity) function** that operates directly on arrays. It is designed for serverless and edge environments where low-latency is critical. Benchmarks run on a 2023 M3 Max using `bun test` show the following performance characteristics:\n\n| Vector Count | Dimensions | Search Time |\n| :----------- | :--------- | :---------- |\n| 10,000       | 500        | ~15 ms      |\n| 10,000       | 1000       | ~22 ms      |\n| 100,000      | 500        | ~101 ms     |\n\nThese results demonstrate that the in-memory vector store is suitable for a wide range of real-time applications without requiring a dedicated vector database.\n\n> **cosine similarity** is the most popular algorithm for vector search, but there are many others (along with strategies for dealing with extremely large data-sets). For more information you can start with this Wikipedia article [Vector database](https://en.wikipedia.org/wiki/Vector_database).\n\n### 5. Structured Outputs\n\nYou can request structured JSON responses (e.g., JSON Schema) from compatible models using `responseFormat`:\n\n```typescript\nconst logic = vm.Agent.llmPredictBattery({\n  system: 'Extract data.',\n  user: 'John Doe, 30',\n  responseFormat: {\n    type: 'json_schema',\n    json_schema: {\n      name: 'person',\n      schema: {\n        type: 'object',\n        properties: {\n          name: { type: 'string' },\n          age: { type: 'number' },\n        },\n        required: ['name', 'age'],\n      },\n    },\n  },\n})\n```\n\n### 5. Troubleshooting\n\n- **Connection Error:** If you see an error like `Failed to connect to LM Studio`, make sure the LM Studio server is running on the default port (`1234`).\n- **No Models Found:** Ensure you have downloaded compatible GGUF models and they are loaded in LM Studio. The audit process will warn you if it cannot find suitable LLM or embedding models.\n\n## Self-Documentation for Agents\n\nThe VM can describe itself to an LLM, generating an [OpenAI-compatible Tool Schema](https://platform.openai.com/docs/guides/function-calling) for its registered atoms.\n\n```typescript\n// Get all tools\nconst tools = vm.getTools()\n\n// Get only flow control tools\nconst flowTools = vm.getTools('flow')\n\n// Get specific tools\nconst myTools = vm.getTools(['httpFetch', 'template'])\n```\n\n## Implementing Real-World Atoms\n\nTo enable custom capabilities like Database Access or Web Scraping, you inject them into the `VM.run` call.\n\n#### Example: Providing a Database\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\n\nconst vm = new AgentVM()\n\nconst capabilities = {\n  store: {\n    get: async (key) => {\n      // Connect to Redis/Postgres here\n      return await db.find(key)\n    },\n    set: async (key, value) => {\n      await db.insert(key, value)\n    },\n  },\n}\n\nawait vm.run(ast, args, { capabilities })\n```\n\n#### Example: Web Scraping Agent\n\nYou can expose a custom capability or use the standard `httpFetch` if trusted.\n\n```typescript\nconst capabilities = {\n  fetch: async (url, options) => {\n    // Implement secure fetch, possibly with proxy rotation or rate limiting\n    return fetch(url, options)\n  },\n}\n```\n\n## Custom Atoms\n\nYou can extend the runtime with your own atomic operations.\n\n```typescript\nimport { defineAtom, AgentVM, s, Agent } from 'tosijs-agent'\n\n// 1. Define the Atom\nconst myScraper = defineAtom(\n  'scrape', // OpCode\n  s.object({ url: s.string }), // Input Schema\n  s.string, // Output Schema\n  async ({ url }, ctx) => {\n    // Implementation logic\n    const res = await ctx.capabilities.fetch(url)\n    return await res.text()\n  },\n  { cost: 5 } // Gas cost\n)\n\n// 2. Register with Custom VM\nconst myVM = new AgentVM({ scrape: myScraper })\n\n// 3. Use in Builder (Types are inferred!)\n// The `vm.Agent` property is the recommended way to get a builder\n// that includes any custom atoms you have registered.\nconst builder = myVM.Agent\n\nconst logic = builder\n  .scrape({ url: 'https://example.com' })\n  .as('html')\n  .return(s.object({ html: s.string }))\n```\n\n## Control Flow\n\nAtoms like `if` and `while` evaluate expression strings. For security and predictability, these expressions are not granted access to the full agent state. Instead, you must use the `vars` parameter to explicitly pass in any state variables that the expression needs.\n\nThis mapping allows you to alias variables, making your expressions cleaner and more readable.\n\n### If / Else\n\n```typescript\nchain.if(\n  'p > 100 && itemsLeft > 0',\n  { p: 'product.price', itemsLeft: 'inventory.stockCount' }, // Map state to expression variables\n  (then) => then.varSet({ key: 'discount', value: true }),\n  (elseBranch) => elseBranch.varSet({ key: 'discount', value: false })\n)\n```\n\n### While Loop\n\n```typescript\n// The `vars` map works identically here, creating a scope for the condition.\n// Use ExprNode for arithmetic operations\nchain.while('n > 0', { n: 'counter' }, (loop) =>\n  loop.varSet({\n    key: 'counter',\n    value: {\n      $expr: 'binary',\n      op: '-',\n      left: { $expr: 'ident', name: 'counter' },\n      right: { $expr: 'literal', value: 1 },\n    },\n  })\n)\n```\n\n### Try / Catch\n\n```typescript\nchain.try({\n  try: (b) => b.httpFetch({ url: '...' }),\n  catch: (b) => b.varSet({ key: 'error', value: 'failed' }),\n})\n```\n\n## Editor Support\n\ntosijs-agent includes syntax highlighting for AsyncJS (the JavaScript subset used by `ajs` template literals).\n\n### Quick Install\n\n```bash\n# VS Code\nnpx ajs-install-vscode\n\n# Cursor\nnpx ajs-install-cursor\n```\n\nFeatures:\n\n- Syntax highlighting for `.ajs` files\n- Embedded highlighting inside `ajs`...`` template literals\n- Error highlighting for forbidden syntax (`new`, `class`, `async`, etc.)\n\n### Web Editors\n\n**Monaco:**\n\n```typescript\nimport { registerAjsLanguage } from 'tosijs-agent/editors/monaco'\nregisterAjsLanguage(monaco)\n```\n\n**CodeMirror 6:**\n\n```typescript\nimport { ajs } from 'tosijs-agent/editors/codemirror'\n// Use ajs() in your extensions\n```\n\n### Tree-sitter Editors (Zed, Nova, Helix)\n\nAssociate `.ajs` files with JavaScript syntax in your editor config. See [editors/README.md](./editors/README.md) for details.\n\n> **Note:** If you modify AsyncJS syntax (e.g., adding/removing forbidden keywords), update the grammar files in `editors/` to match. See [editors/README.md](./editors/README.md) for grammar locations.\n\n## Development\n\n### Testing\n\nThe test suite includes performance benchmarks for the in-memory vector search. These benchmarks can be sensitive to the performance of the host machine and may fail in slower CI/CD environments. To avoid this, you can skip the benchmark tests by setting the `AGENT99_TESTS_SKIP_BENCHMARKS` environment variable.\n\n```bash\n# Run tests\nbun test\n\n# Skip benchmark tests\nAGENT99_TESTS_SKIP_BENCHMARKS=1 bun test\n\n# Type check\nbun run typecheck\n\n# Build blueprint\nbun run make\n```\n",
    "title": "tosijs-agent",
    "filename": "README.md",
    "path": "README.md",
    "pin": "top"
  },
  {
    "text": "# Agent-99 Improvement Plan\n\nBased on comprehensive code review. Items organized by priority.\n\n---\n\n## P0 - Security (DONE)\n\n- [x] SSRF protection for default fetch - block private IPs, localhost, metadata endpoints\n- [x] ReDoS detection - reject dangerous regex patterns before execution\n- [x] Tests for security fixes\n\n---\n\n## P1 - High Priority (DONE)\n\n### 1.1 Fix Confusing Value Resolution - SKIPPED\n\n**Status:** Working as designed. Type-by-example is intentional for AsyncJS.\n\n---\n\n### 1.2 Add Null Coalescing Operator (`??`) - DONE\n\nAdded `??` operator handling in `evaluateExpr()`.\n\n---\n\n### 1.3 Transpiler/Parser Test Coverage - DONE\n\nAdded `src/transpiler/transpiler.test.ts` with comprehensive coverage.\n\n---\n\n### 1.4 Edge Case Test Coverage - PARTIAL\n\nSome edge cases added. Remaining items are low priority enhancements.\n\n---\n\n### 1.5 Improve Weak Error Messages - DONE\n\nImproved error messages for unsupported syntax with helpful suggestions.\n\n---\n\n### 1.6 Remove Redundant Test Script - DONE\n\nAdded `test:fast` script for quick iteration (skips LLM tests and benchmarks).\n\n---\n\n## P2 - Medium Priority (DONE)\n\n### 2.1 Create test-utils.ts - DONE\n\nCreated `src/test-utils.ts` with mock factories for store, fetch, LLM, vector, XML.\n\n---\n\n### 2.2 Document Default Store as Non-Production - DONE\n\nDefault in-memory store now emits warning via `result.warnings` on first use.\n\n---\n\n### 2.3 Clarify Builder API vs AsyncJS Emphasis - DONE\n\nUpdated README to lead with AsyncJS, Builder positioned as \"Advanced\" for metaprogramming.\n\n---\n\n### 2.4 Improve Syntax Highlighting for Unsupported Patterns - DONE\n\nEditor grammars highlight forbidden keywords distinctly.\n\n---\n\n### 2.4b Unify Editor Grammar Implementations - DONE\n\nCreated `editors/ajs-syntax.ts` as single source of truth. Added `build:grammars` script to generate VSCode JSON from TypeScript source.\n\n---\n\n### 2.5 Fix Builder Footguns - DONE\n\n- Added `warnMissingVars()` to warn when Builder conditions reference unmapped variables\n- Removed legacy comparison atoms (eq, neq, gt, lt, and, or, not) - replaced by ExprNode\n\n---\n\n### 2.6 Replace Problematic `any` Types - DONE\n\n- Added `VarMapping` type for condition variables\n- Added `ItemsRef` type for iteration items\n- Added generic `<T>` to `reduce` for typed initial values\n- Remaining internal `any` uses are justified\n\n---\n\n### 2.7 Leverage Playground Inline Docs - DONE\n\nAdded `/*# markdown */` documentation to key atoms in runtime.ts. Fixed docs.js to combine blocks per file.\n\n---\n\n## P3 - Low Priority / Future (DONE)\n\n### 3.1 Missing Agent Patterns - DONE\n\nCreated `PATTERNS.md` documenting:\n\n- Parallel execution (not supported, capability workaround)\n- Retry/backoff (manual while loop pattern)\n- Rate limiting (capability responsibility)\n- Break/continue (use condition variables)\n- Switch statements (use chained if/else)\n- Error handling patterns\n- Expression limitations\n\n---\n\n### 3.2 Half-Implemented Features - DONE\n\nDocumented as limitations in PATTERNS.md:\n\n- Template literals in expressions (now throws helpful error instead of `'__template__'`)\n- Computed member access (`obj[variable]`) not supported\n- Atom calls in expressions not supported\n\n---\n\n### 3.3 Batteries Tests - SKIPPED\n\nTested implicitly via integration tests. Mock-based unit tests are low priority.\n\n---\n\n### 3.4 Builtin Object Test Coverage - DONE\n\nAdded tests for:\n\n- Date factory and methods (creation, properties, format, add, diff, comparison)\n- Set factory and methods (has, size, add, union, intersection, diff)\n\n---\n\n### 3.5 Documentation Improvements - PARTIAL\n\n- PATTERNS.md covers common patterns and limitations\n- Expression syntax documented in PATTERNS.md\n- API reference generation deferred (low priority)\n\n---\n\n## Questions Resolved\n\n1. **Default store:** Documented as non-production via runtime warning.\n\n2. **Value resolution:** Kept current (type-by-example is intentional).\n\n3. **Builder footguns:** Added warning for missing vars, recommend AsyncJS instead.\n\n4. **Half-implemented features:** Documented as unsupported in PATTERNS.md with workarounds.\n\n---\n\n## Not Doing\n\n- **LLM prompt injection protection** - Out of scope. Users are responsible for their LLM prompts.\n\n- **Test execution order dependencies** - Tests are independent. Repeated setup code is acceptable.\n\n---\n\n## Summary\n\nAll P0-P3 items have been addressed. The codebase now has:\n\n- Improved type safety in Builder API\n- Comprehensive documentation (PATTERNS.md, inline docs)\n- Better error messages for unsupported syntax\n- Unified editor grammar source\n- Test utilities for mocking capabilities\n- Runtime warnings for development footguns\n",
    "title": "Agent-99 Improvement Plan",
    "filename": "PLAN.md",
    "path": "PLAN.md"
  },
  {
    "text": "# AsyncJS (.ajs) - A Better JavaScript for AI Agents\n\nAsyncJS is a JavaScript subset designed for writing AI agent logic. It compiles to Agent99's secure JSON AST format, providing familiar syntax with cleaner semantics.\n\n> **For LLM Integration:** See [ASYNCJS_LLM_PROMPT.md](./ASYNCJS_LLM_PROMPT.md) for a system prompt optimized for code generation.\n\n## File Extension\n\nAsyncJS files use the `.ajs` extension to distinguish them from standard JavaScript:\n\n```\nmy-agent.ajs\nsearch-tool.ajs\n```\n\n## Why AsyncJS?\n\n| Problem with JavaScript       | AsyncJS Solution                                |\n| ----------------------------- | ----------------------------------------------- |\n| `async/await` boilerplate     | All calls are implicitly async                  |\n| Complex error handling        | Monadic error flow - errors propagate as values |\n| No built-in type safety       | Types through example values                    |\n| Security concerns with `eval` | Compiles to sandboxed VM                        |\n\n## Quick Example\n\n```javascript\n// search-agent.ajs\n\n/**\n * Search and summarize information about a topic\n * @param topic - The topic to research\n * @param maxResults - Maximum number of results\n */\nfunction searchAgent(topic: 'climate change', maxResults = 5) {\n  let results = search({ query: topic, limit: maxResults })\n\n  if (results.length == 0) {\n    return { summary: 'No results found', sources: [] }\n  }\n\n  let summary = llmPredict({\n    system: 'Summarize these search results concisely',\n    user: results,\n  })\n\n  return { summary, sources: results }\n}\n```\n\n## Core Differences from JavaScript\n\n### 1. Implicit Async\n\nAll function calls that invoke atoms are automatically awaited. No `async/await` keywords needed.\n\n```javascript\n// AsyncJS - clean and simple\nfunction agent(topic: 'machine learning') {\n  let results = search({ query: topic })\n  let summary = summarize({ text: results })\n  return { summary }\n}\n\n// Equivalent JavaScript would require:\n// async function agent(topic) {\n//   let results = await search({ query: topic })\n//   let summary = await summarize({ text: results })\n//   return { summary }\n// }\n```\n\n### 2. Types Through Example Values\n\nTypes are inferred from example values. The example shows both the type AND a realistic value:\n\n```javascript\nfunction greet(\n  name: 'Anne Example', // required string\n  age: 21, // required number\n  greeting = 'Hello' // optional string, defaults to 'Hello'\n) {\n  // ...\n}\n```\n\n- **Colon (`:`)** = required parameter, example shows the type\n- **Equals (`=`)** = optional parameter with default value\n\nThe example value IS the type. `age: 21` means \"required number\". `name: 'Anne'` means \"required string\".\n\n### 3. Monadic Error Flow\n\nErrors propagate automatically as values. When an atom fails, subsequent steps are skipped and the error flows through to the result.\n\n```javascript\nfunction pipeline(topic: 'quantum computing') {\n  let results = search({ query: topic }) // might fail\n  let summary = summarize({ text: results }) // skipped if search fails\n  let formatted = format({ content: summary }) // skipped if any above fails\n  return { formatted }\n}\n// If search() fails, the error flows through without executing subsequent steps\n// The result will have an `error` property containing the AgentError\n```\n\nThe VM returns a `RunResult` with both `result` and `error` fields:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  console.log('Failed:', error.message)\n  console.log('Failed at atom:', error.op)\n} else {\n  console.log('Success:', result)\n}\n```\n\nUse `try/catch` to recover from errors:\n\n```javascript\nfunction resilientPipeline(topic: 'neural networks') {\n  let data = null\n  try {\n    data = fetchData({ topic })\n  } catch (e) {\n    data = fallbackData({ topic })\n  }\n  return { data }\n}\n```\n\n### 4. Function Introspection\n\nEvery function has a `.signature` property for self-documentation:\n\n```javascript\n/**\n * Search the knowledge base\n * @param query - The search query\n * @param limit - Max results to return\n */\nfunction search(\n  query: 'example query',\n  limit = 10\n) -> [{ title: 'Example Title', url: 'https://example.com' }] {\n  // implementation\n}\n\n// Automatically gets:\nsearch.signature = {\n  name: 'search',\n  description: 'Search the knowledge base',\n  parameters: {\n    query: { type: 'string', required: true, description: 'The search query' },\n    limit: { type: 'number', required: false, default: 10, description: 'Max results to return' }\n  },\n  returns: { type: 'array', items: { type: 'object', shape: { title: 'string', url: 'string' } } }\n}\n```\n\n## Type System Reference\n\n### Parameter Types\n\n| Syntax                  | Meaning          | Example                          |\n| ----------------------- | ---------------- | -------------------------------- |\n| `name: 'Anne'`          | Required string  | The example value shows the type |\n| `age: 21`               | Required number  |                                  |\n| `active: true`          | Required boolean |                                  |\n| `tags: ['a', 'b']`      | Required array   |                                  |\n| `user: { name: 'Bob' }` | Required object  |                                  |\n| `limit = 10`            | Optional number  | Defaults to 10                   |\n| `query = 'default'`     | Optional string  | Defaults to 'default'            |\n\n### Destructured Parameter Defaults\n\nAsyncJS supports default values in destructured object parameters. Unlike JavaScript/TypeScript where destructuring defaults can be tricky, AsyncJS makes them work reliably:\n\n```javascript\nfunction calculate({ a = 10, b = 5 }) {\n  return { sum: a + b, product: a * b }\n}\n\n// Called with no arguments - uses defaults\ncalculate({}) // { sum: 15, product: 50 }\n\n// Called with partial arguments - missing ones use defaults\ncalculate({ a: 20 }) // { sum: 25, product: 100 }\n\n// Called with all arguments - no defaults used\ncalculate({ a: 3, b: 7 }) // { sum: 10, product: 21 }\n```\n\nThis works seamlessly with type annotations too:\n\n```javascript\nfunction greet({ name: 'World', greeting = 'Hello' }) {\n  return { message: `${greeting}, ${name}!` }\n}\n\ngreet({})  // { message: \"Hello, World!\" }\ngreet({ name: 'Alice' })  // { message: \"Hello, Alice!\" }\ngreet({ greeting: 'Hi' })  // { message: \"Hi, World!\" }\n```\n\n### Return Types\n\nReturn types can be specified with arrow syntax:\n\n```javascript\nfunction search(query: 'search term') -> { results: [], count: 0 } {\n  // Must return object with results array and count number\n}\n```\n\nOr inferred from the return statement:\n\n```javascript\nfunction search(query: 'search term') {\n  return { results: [], count: 0 } // Return type inferred\n}\n```\n\n## Supported Constructs\n\n### Variables\n\n```javascript\nlet x = 5 // Variable declaration\nx = 10 // Assignment\nlet { a, b } = obj // Destructuring (limited)\n```\n\n### Control Flow\n\n```javascript\n// Conditionals\nif (condition) {\n  // ...\n} else {\n  // ...\n}\n\n// Loops\nwhile (condition) {\n  // ...\n}\n\nfor (const item of items) {\n  // Becomes a map operation\n}\n\n// Error handling\ntry {\n  // ...\n} catch (e) {\n  // ...\n}\n```\n\n### Expressions\n\n```javascript\n// Arithmetic\na + b, a - b, a * b, a / b, a % b\n\n// Comparison\na == b, a != b, a < b, a > b, a <= b, a >= b\n\n// Logical\na && b, a || b, !a\n\n// Member access\nobj.property\nobj.nested.property\narr[0]\n\n// Optional chaining (safe access)\nobj?.property\nobj?.nested?.value\narr?.[0]\n\n// Template literals\n`Hello ${name}!`\n\n// Function calls\natomName({ param1: value1, param2: value2 })\n```\n\n### Built-in Objects\n\nAsyncJS provides safe implementations of common JavaScript built-in objects:\n\n#### Math\n\nAll standard Math methods and constants are available:\n\n```javascript\nlet floor = Math.floor(3.7) // 3\nlet ceil = Math.ceil(3.2) // 4\nlet abs = Math.abs(-5) // 5\nlet max = Math.max(1, 5, 3) // 5\nlet sqrt = Math.sqrt(16) // 4\nlet pi = Math.PI // 3.14159...\nlet random = Math.random() // Cryptographically secure when available\n```\n\n**Note:** `Math.random()` uses `crypto.getRandomValues()` when available for cryptographically secure random numbers.\n\n#### JSON\n\n```javascript\nlet obj = { name: 'test', value: 42 }\nlet str = JSON.stringify(obj) // '{\"name\":\"test\",\"value\":42}'\nlet parsed = JSON.parse(str) // { name: 'test', value: 42 }\n```\n\n#### Array Static Methods\n\n```javascript\nlet isArr = Array.isArray([1, 2, 3]) // true\nlet arr = Array.from([1, 2, 3]) // Creates new array\nlet created = Array.of(1, 2, 3) // [1, 2, 3]\n```\n\n#### Object Static Methods\n\n```javascript\nlet obj = { a: 1, b: 2, c: 3 }\nlet keys = Object.keys(obj) // ['a', 'b', 'c']\nlet values = Object.values(obj) // [1, 2, 3]\nlet entries = Object.entries(obj) // [['a',1], ['b',2], ['c',3]]\n```\n\n#### Number Static Methods\n\n```javascript\nlet isInt = Number.isInteger(5) // true\nlet isNan = Number.isNaN(NaN) // true\nlet max = Number.MAX_SAFE_INTEGER // 9007199254740991\n```\n\n#### Global Functions\n\n```javascript\nlet n = parseInt('42') // 42\nlet f = parseFloat('3.14') // 3.14\nlet encoded = encodeURIComponent('hello world') // 'hello%20world'\n```\n\n#### String Instance Methods\n\n```javascript\nlet str = 'hello world'\nlet upper = str.toUpperCase() // 'HELLO WORLD'\nlet parts = str.split(' ') // ['hello', 'world']\nlet trimmed = '  padded  '.trim() // 'padded'\nlet replaced = str.replace('world', 'there') // 'hello there'\n```\n\n#### Array Instance Methods\n\n```javascript\nlet arr = [3, 1, 4, 1, 5]\nlet joined = arr.join('-') // '3-1-4-1-5'\nlet has = arr.includes(4) // true\nlet idx = arr.indexOf(1) // 1\nlet sliced = arr.slice(1, 3) // [1, 4]\n```\n\n### Set and Date Builtins\n\nAsyncJS provides `Set()` and `Date()` as factory functions - no `new` keyword needed.\n\n#### Set\n\nCreate sets with `Set([items])`. Sets have both mutable operations (modify in place) and immutable set algebra (return new sets):\n\n```javascript\n// Create a Set\nlet tags = Set(['javascript', 'typescript', 'rust'])\nlet empty = Set()\n\n// Mutable operations (modify the set, return this for chaining)\ntags.add('go') // Add item\ntags.remove('rust') // Remove item\ntags.clear() // Remove all items\n\n// Query operations\nlet has = tags.has('typescript') // true/false\nlet count = tags.size // Number of items\nlet arr = tags.toArray() // Convert to array\n\n// Immutable set algebra (return NEW sets)\nlet a = Set([1, 2, 3])\nlet b = Set([2, 3, 4])\n\nlet union = a.union(b) // Set([1, 2, 3, 4])\nlet inter = a.intersection(b) // Set([2, 3])\nlet diff = a.diff(b) // Set([1]) - items in a but not b\n```\n\n#### Date\n\nCreate dates with `Date()` or `Date(initializer)`. Date objects are **immutable** - methods like `add()` return new Date objects:\n\n```javascript\n// Create a Date\nlet now = Date() // Current date/time\nlet specific = Date('2024-06-15') // From ISO string\nlet fromTs = Date(1718409600000) // From timestamp\n\n// Static methods\nlet timestamp = Date.now() // Current timestamp (number)\nlet parsed = Date.parse('2024-06-15T10:30:00Z') // Parse to Date object\n\n// Component accessors (read-only)\nlet d = Date('2024-06-15T10:30:45Z')\nd.year // 2024\nd.month // 6 (1-12, not 0-11 like JS!)\nd.day // 15\nd.hours // 10\nd.minutes // 30\nd.seconds // 45\nd.timestamp // Unix timestamp in ms\nd.value // ISO string\n\n// Immutable arithmetic (returns NEW Date)\nlet later = d.add({ days: 5, hours: 3 })\nlet earlier = d.add({ months: -1 })\n// Supported: years, months, days, hours, minutes, seconds\n\n// Comparison\nlet before = d.isBefore(later) // true\nlet after = later.isAfter(d) // true\nlet diffDays = d.diff(later, 'days') // -5\n\n// Formatting\nlet formatted = d.format('date') // '2024-06-15'\nlet iso = d.format('iso') // '2024-06-15T10:30:45.000Z'\nlet time = d.format('time') // '10:30:45'\n```\n\n**Note:** Unlike JavaScript's `Date`, months are 1-12 (not 0-11), and all methods are immutable.\n\n#### Serialization\n\nSets and Dates serialize cleanly to JSON:\n\n```javascript\nlet result = {\n  tags: Set(['a', 'b', 'c']),\n  created: Date('2024-06-15'),\n}\n// JSON.stringify(result) produces:\n// { \"tags\": [\"a\", \"b\", \"c\"], \"created\": \"2024-06-15T00:00:00.000Z\" }\n```\n\n- **Sets** serialize to arrays\n- **Dates** serialize to ISO 8601 strings\n\n### Schema Filtering\n\nThe `filter()` builtin validates and strips extra properties from objects based on a schema:\n\n```javascript\n// Strip extra properties from an object\nlet raw = { name: 'Alice', age: 30, secret: 'password', extra: 123 }\nlet clean = filter(raw, { name: 'string', age: 0 })\n// clean = { name: 'Alice', age: 30 }\n\n// Works with nested objects\nlet data = {\n  user: { name: 'Bob', age: 25, ssn: '123-45-6789' },\n  tags: ['a', 'b'],\n  internal: 'hidden',\n}\nlet filtered = filter(data, {\n  user: { name: 'string', age: 0 },\n  tags: ['string'],\n})\n// filtered = { user: { name: 'Bob', age: 25 }, tags: ['a', 'b'] }\n\n// Throws on validation failure (missing required fields)\nlet bad = filter({ name: 'Alice' }, { name: 'string', age: 0 })\n// Error: Missing age\n```\n\n**Use cases:**\n\n- Sanitize LLM outputs - strip unexpected properties from JSON responses\n- API input validation - accept only the fields you expect\n- Data projection - reduce objects to a known shape\n\n**Note:** Return values are automatically filtered when a return type is declared. This makes return types act as projections:\n\n```javascript\nfunction getUser(id: 'user-123') -> { name: 'string', email: 'string' } {\n  let user = fetchUser({ id })  // might return { name, email, password, ... }\n  return { user }               // password automatically stripped\n}\n```\n\n### Array Methods with Lambdas\n\n```javascript\n// Map - transform each element\nitems.map((x) => x * 2)\nitems.map((x) => {\n  let doubled = x * 2\n  return doubled\n})\n\n// Filter - keep elements matching condition\nitems.filter((x) => x > 5)\nitems.filter((x) => x % 2 == 0)\n\n// Find - get first matching element\nitems.find((x) => x.id == targetId)\nusers.find((u) => u.age >= 18)\n\n// Reduce - accumulate to single value\nitems.reduce((acc, x) => acc + x, 0)\nitems.reduce((sum, item) => sum + item.price, 0)\n\n// Other array operations\nitems.push(newItem) // Add to array\nstr.split(',') // Split string to array\nparts.join('-') // Join array to string\n```\n\nLambdas support closures - they can access variables from the outer scope:\n\n```javascript\nfunction processItems({ items, threshold }) {\n  let above = items.filter((x) => x >= threshold) // threshold from outer scope\n  let scaled = above.map((x) => x * threshold) // still accessible\n  return { scaled }\n}\n```\n\n## Unsupported Constructs\n\nThese JavaScript features are intentionally not supported:\n\n| Feature            | Reason                       | Alternative         |\n| ------------------ | ---------------------------- | ------------------- |\n| `class`            | Use functional composition   | Plain functions     |\n| `this`             | Implicit state is confusing  | Explicit parameters |\n| `new`              | Classes not supported        | Factory functions   |\n| `import/require`   | Atoms must be registered     | Register with VM    |\n| `async/await`      | Implicit async               | Just call functions |\n| `yield/generators` | Complex control flow         | Use `map`/`while`   |\n| `eval`             | Security (though VM is safe) | Use transpiler      |\n| `with`             | Deprecated                   | Explicit references |\n| `var`              | Scoping issues               | Use `let`           |\n\n## API Usage\n\n### transpile()\n\nFull transpilation with signature and metadata:\n\n```typescript\nimport { transpile } from 'tosijs-agent'\n\nconst { ast, signature, warnings } = transpile(`\n  function greet(name: 'World') {\n    let msg = template({ tmpl: 'Hello {{name}}!', vars: { name } })\n    return { msg }\n  }\n`)\n\nconsole.log(signature.parameters.name.type) // 'string'\nconsole.log(signature.parameters.name.required) // true\n```\n\n### ajs()\n\nConvenience function returning just the AST (works as both a function and tagged template literal):\n\n```typescript\nimport { ajs } from 'tosijs-agent'\n\nconst ast = ajs(`\n  function add(a: 5, b: 3) {\n    let sum = a + b\n    return { sum }\n  }\n`)\n\n// Execute with VM\nconst vm = new AgentVM()\nconst result = await vm.run(ast, { a: 5, b: 3 })\nconsole.log(result.result.sum) // 8\n```\n\n### agent\\`\\`\n\nTagged template for inline definitions:\n\n```typescript\nimport { agent } from 'tosijs-agent'\n\nconst searchAST = agent`\n  function search(query: 'example search', limit = 10) {\n    let results = storeSearch({ query, limit })\n    return { results }\n  }\n`\n```\n\n### getToolDefinitions()\n\nGenerate OpenAI-compatible tool schemas for LLM integration:\n\n```typescript\nimport { getToolDefinitions, transpile } from 'tosijs-agent'\n\nconst { signature } = transpile(source)\nconst tools = getToolDefinitions([signature])\n\n// Returns format compatible with OpenAI/Anthropic tool calling:\n// [{\n//   type: 'function',\n//   function: {\n//     name: 'search',\n//     description: 'Search the knowledge base',\n//     parameters: { type: 'object', properties: {...}, required: [...] }\n//   }\n// }]\n```\n\n## Error Handling\n\n### Monadic Error Flow\n\nAgent99 uses monadic error flow - when an atom fails, the error becomes a value that propagates through the pipeline:\n\n```typescript\nconst { result, error, fuelUsed } = await vm.run(ast, args)\n\nif (error) {\n  // error is an AgentError with:\n  // - message: string - the error message\n  // - op: string - the atom that failed\n  // - cause?: Error - the original exception\n  console.log(`Error in ${error.op}: ${error.message}`)\n} else {\n  // Success - use result\n  console.log(result)\n}\n```\n\n### Checking for Errors\n\n```typescript\nimport { isAgentError } from 'tosijs-agent'\n\nconst { result, error } = await vm.run(ast, args)\n\nif (isAgentError(result)) {\n  // result itself is the error (when error occurs before return)\n}\n```\n\n### Recovery with try/catch\n\nUse `try/catch` in your AsyncJS code to handle errors gracefully:\n\n```javascript\nfunction resilientAgent({ query }) {\n  let result = null\n\n  try {\n    result = riskyOperation({ query })\n  } catch (e) {\n    // e contains the error message\n    result = safeDefault({ error: e })\n  }\n\n  return { result }\n}\n```\n\n### Triggering Errors with Error()\n\nUse the `Error()` built-in to trigger monadic error flow from your AsyncJS code:\n\n```javascript\nfunction validateInput({ value }) {\n  if (value < 0) {\n    Error('Value must be non-negative')\n    // Execution stops here - subsequent code is skipped\n  }\n\n  return { validated: value }\n}\n```\n\nWhen `Error()` is called:\n\n- The error message is stored in the context\n- Subsequent operations are skipped (monadic error flow)\n- The error can be caught with `try/catch` or returned to the caller\n\n```javascript\nfunction safeDivide({ a, b }) {\n  if (b === 0) {\n    Error('Division by zero')\n  }\n  return { result: a / b }\n}\n\nfunction calculate({ x, y }) {\n  let result = null\n\n  try {\n    result = safeDivide({ a: x, b: y })\n  } catch (e) {\n    result = { result: 0, error: e }\n  }\n\n  return result\n}\n```\n\n### Why No `throw` Statement?\n\nAsyncJS intentionally does not support the `throw` statement. Instead, use `Error()`:\n\n```javascript\n// DON'T DO THIS - throw is not supported:\nif (invalid) {\n  throw new Error('Something went wrong') // Transpiler error!\n}\n\n// DO THIS INSTEAD:\nif (invalid) {\n  Error('Something went wrong') // Triggers monadic error flow\n}\n```\n\nThe `throw` keyword will show as an error in your editor (red underline) and the transpiler will provide a helpful error message pointing you to use `Error()` instead.\n\n## Gotchas and Common Pitfalls\n\n### Unavailable JavaScript Features\n\nThese common JavaScript APIs are **not available** in AsyncJS. The transpiler will catch these and provide helpful error messages:\n\n| Feature          | Error Message              | Alternative                            |\n| ---------------- | -------------------------- | -------------------------------------- |\n| `setTimeout`     | Use the `delay` atom       | `delay({ ms: 1000 })`                  |\n| `setInterval`    | Use while loops with delay | `while (cond) { delay({ ms: 1000 }) }` |\n| `fetch`          | Use the `httpFetch` atom   | `httpFetch({ url })`                   |\n| `RegExp`         | Use string methods         | `str.match()`, `str.replace()`         |\n| `Promise`        | Implicit async             | All calls are automatically awaited    |\n| `Map`            | Use plain objects          | `{ key: value }`                       |\n| `require/import` | Register atoms with VM     | `new AgentVM({ customAtom })`          |\n\n### The `new` Keyword\n\nThe `new` keyword is not supported. AsyncJS provides factory functions instead:\n\n```javascript\n// DON'T DO THIS - the transpiler catches these with helpful errors:\nlet date = new Date() // Error: Use Date() or Date('2024-01-15') instead\nlet set = new Set([1, 2]) // Error: Use Set([items]) instead\nlet arr = new Array(5) // Error: Use array literals like [1, 2, 3] instead\n\n// DO THIS INSTEAD - no 'new' needed:\nlet date = Date() // Current date/time\nlet date2 = Date('2024-06-15') // Specific date\nlet set = Set([1, 2, 3]) // Create a Set\nlet arr = [1, 2, 3, 4, 5] // Array literal\n```\n\nSee [Set and Date Builtins](#set-and-date-builtins) for full documentation.\n\n### No `this` or Classes\n\nAsyncJS is purely functional. There's no `this`, no classes, no prototypes:\n\n```javascript\n// DON'T DO THIS\nclass Agent {\n  constructor(name) {\n    this.name = name\n  }\n}\n\n// DO THIS INSTEAD\nfunction createAgent(name: 'Agent Smith') {\n  return { name }\n}\n```\n\n### Equality Semantics\n\nAsyncJS uses JavaScript's standard equality (`==` and `===`). There is no special deep equality:\n\n```javascript\nlet a = { x: 1 }\nlet b = { x: 1 }\nlet same = a == b // false (reference comparison)\n\n// For deep comparison, use JSON.stringify or write a comparison function\nlet equal = JSON.stringify(a) == JSON.stringify(b) // true\n```\n\n### Optional Chaining (`?.`)\n\nOptional chaining is fully supported for safe property access:\n\n```javascript\nlet x = obj?.nested?.value // Returns null if any step is null/undefined\nlet result = user?.profile?.name\n\n// Works with method calls too\nlet len = items?.length\nlet upper = str?.toUpperCase()\n```\n\n**Note:** Nullish coalescing (`??`) is not yet supported. Use explicit checks:\n\n```javascript\nlet x = obj?.nested?.value\nif (x == null) {\n  x = 'default'\n}\n```\n\n### Atom Calls vs Built-in Methods\n\nAtoms use object parameter syntax, while built-ins use normal function syntax:\n\n```javascript\n// Atom call - object parameter\nlet result = search({ query: 'hello', limit: 10 })\n\n// Built-in method - normal parameters\nlet floor = Math.floor(3.7)\nlet upper = str.toUpperCase()\n```\n\n### Async Is Implicit\n\nAll atom calls are automatically awaited. Don't use `async/await`:\n\n```javascript\n// DON'T DO THIS\nasync function search(query) {\n  let result = await fetch(query) // Error: async/await not supported\n}\n\n// DO THIS INSTEAD\nfunction search(query: 'https://api.example.com') {\n  let result = httpFetch({ url: query }) // Automatically awaited\n  return { result }\n}\n```\n\n### Error Propagation\n\nErrors propagate monadically - if one step fails, subsequent steps are skipped:\n\n```javascript\nfunction pipeline(input: 'raw data') {\n  let a = stepOne({ input }) // If this fails...\n  let b = stepTwo({ data: a }) // ...this is skipped\n  let c = stepThree({ data: b }) // ...and this too\n  return { c } // Result contains the error\n}\n```\n\nUse `try/catch` to recover from expected errors:\n\n```javascript\nfunction resilient(input: 'user input') {\n  let result = null\n  try {\n    result = riskyStep({ input })\n  } catch (e) {\n    result = fallback({ error: e })\n  }\n  return { result }\n}\n```\n\n### Fuel Limits\n\nAll operations consume fuel. Complex operations may hit limits:\n\n```javascript\n// This might run out of fuel for large arrays\nfunction processLarge({ items }) {\n  let mapped = items.map((x) => complexOperation({ x }))\n  return { mapped }\n}\n\n// Run with higher fuel limit\nconst result = await vm.run(ast, args, { fuel: 10000 })\n```\n\n## Security Model\n\nAsyncJS compiles to Agent99's JSON AST, which executes in a completely sandboxed VM:\n\n- **No file system access** - unless explicitly provided via atoms\n- **No network access** - unless explicitly provided via atoms\n- **No global state** - each execution is isolated\n- **Fuel-limited execution** - prevents infinite loops and runaway expressions\n- **Type-checked at runtime** - invalid operations fail safely\n- **Prototype access blocked** - `__proto__`, `constructor`, `prototype` are forbidden\n\nThe transpiler is permissive because security is enforced at the VM level, not the language level. Even if malicious code somehow made it through, the VM cannot execute dangerous operations unless atoms for those operations are registered.\n\n### Fuel System\n\nEvery operation consumes fuel. When fuel runs out, execution stops with an `Out of Fuel` error:\n\n```typescript\nconst result = await vm.run(ast, args, { fuel: 100 })\n// Limits total computation to prevent infinite loops\n```\n\nExpression evaluation also consumes fuel (0.01 per node), preventing deeply nested or recursive expressions from running unchecked.\n\n## Migration from TypedBuilder\n\nIf you have existing TypedBuilder code, here's how to convert:\n\n```typescript\n// Before: TypedBuilder\nconst ast = Agent.take()\n  .varsImport(['topic'])\n  .step({ op: 'search', query: 'topic', result: 'results' })\n  .if('results.length > 0', { results: 'results' }, (b) =>\n    b.step({ op: 'summarize', text: 'results', result: 'summary' })\n  )\n  .return({ properties: { results: {}, summary: {} } })\n  .toJSON()\n\n// After: AsyncJS\nconst ast = ajs(`\n  function searchAgent(topic: 'climate change') {\n    let results = search({ query: topic })\n    if (results.length > 0) {\n      let summary = summarize({ text: results })\n    }\n    return { results, summary }\n  }\n`)\n```\n\n## Best Practices\n\n1. **Use descriptive JSDoc comments** - They become part of the function signature for LLM agents\n2. **Prefer explicit types** - Even though inference works, explicit types document intent\n3. **Keep functions small** - Each function should do one thing\n4. **Use meaningful variable names** - The VM state is inspectable during debugging\n5. **Return structured objects** - Makes output types clear and composable\n6. **Handle errors appropriately** - Use try/catch for expected failures, let others propagate\n7. **Set appropriate fuel limits** - Balance between allowing complex operations and preventing abuse\n",
    "title": "AsyncJS (.ajs) - A Better JavaScript for AI Agents",
    "filename": "ASYNCJS.md",
    "path": "ASYNCJS.md"
  },
  {
    "text": "# AsyncJS LLM System Prompt\n\n> **Maintenance Note:** This prompt must be updated when [ASYNCJS.md](./ASYNCJS.md) changes.\n> Key areas to sync: type syntax, built-ins (Set/Date), control flow, and forbidden constructs.\n\nUse this system prompt when asking an LLM to generate AsyncJS code.\n\n---\n\n## System Prompt\n\n````\nYou are an expert code generator for **AsyncJS**, a specialized subset of JavaScript for AI Agents.\nAsyncJS looks like JavaScript but has strict differences. You must adhere to these rules:\n\n### 1. SYNTAX & TYPES\n- **Types by Example:** Do NOT use TypeScript types (`x: string`). Use \"Example Types\" where the value implies the type.\n  - WRONG: `function search(query: string, limit?: number)`\n  - RIGHT: `function search(query: 'search term', limit = 10)`\n  - `name: 'value'` means REQUIRED string. `count: 5` means REQUIRED number. `name = 'value'` means OPTIONAL.\n  - For numbers, use a number literal: `function factorial(n: 5)` or `function add(a: 0, b: 0)`\n- **No Classes:** Do NOT use `class`, `new`, `this`, or `prototype`.\n- **No Async/Await:** Do NOT use `async` or `await`. All functions are implicitly asynchronous.\n  - WRONG: `let x = await fetch(...)`\n  - RIGHT: `let x = httpFetch({ url: '...' })`\n\n### 2. BUILT-INS & FACTORIES\n- **No `new` Keyword:** Never use `new`. Use factory functions.\n  - WRONG: `new Date()`, `new Set()`, `new Array()`\n  - RIGHT: `Date()`, `Set([1,2])`, `['a','b']`\n- **Date Objects:** `Date()` returns an **immutable** object.\n  - Months are 1-indexed (1=Jan, not 0=Jan).\n  - Methods like `.add({ days: 5 })` return a NEW Date object.\n  - Access components: `.year`, `.month`, `.day`, `.hours`, `.minutes`, `.seconds`\n  - Format: `.format('date')`, `.format('iso')`, `.format('YYYY-MM-DD')`\n- **Set Objects:** `Set([items])` returns an object with:\n  - Mutable: `.add(x)`, `.remove(x)`, `.clear()`\n  - Immutable algebra: `.union(other)`, `.intersection(other)`, `.diff(other)` - return NEW Sets\n  - Query: `.has(x)`, `.size`, `.toArray()`\n- **Optional Chaining:** Use `?.` for safe property access: `obj?.nested?.value`\n- **Schema Filtering:** `filter(data, schema)` strips extra properties:\n  - `filter({ a: 1, b: 2, extra: 3 }, { a: 0, b: 0 })` returns `{ a: 1, b: 2 }`\n  - Useful for sanitizing LLM outputs or API responses\n\n### 3. ATOMS VS. BUILT-INS\n- **Atoms (External Tools):** ALWAYS accept a single object argument.\n  - Pattern: `atomName({ param: value })`\n  - Examples: `search({ query: topic })`, `llmPredict({ system: '...', user: '...' })`\n  - **template atom:** `template({ tmpl: 'Hello, {{name}}!', vars: { name } })` - for string interpolation\n- **Built-ins (Math, JSON, String, Array):** Use standard JS syntax.\n  - `Math.max(1, 2)`, `JSON.parse(str)`, `str.split(',')`, `arr.map(x => x * 2)`\n\n### 4. ERROR HANDLING\n- Errors propagate automatically (Monadic flow). If one step fails, subsequent steps are skipped.\n- Only use `try/catch` if you need to recover from a failure and continue.\n\n### 5. FORBIDDEN CONSTRUCTS\nThese will cause transpile errors:\n- `async`, `await` - not needed, all calls are implicitly async\n- `new` - use factory functions instead\n- `class`, `this` - use plain functions and objects\n- `var` - use `let` instead\n- `import`, `require` - atoms must be registered with the VM\n- `console.log` - use trace capabilities if needed\n\n### EXAMPLES\n\n**Example 1: Search Agent**\n```javascript\nfunction researchAgent(topic: 'quantum computing') {\n  let searchResults = search({ query: topic, limit: 5 })\n  if (searchResults?.length == 0) {\n    return { error: 'No results found' }\n  }\n  let summary = summarize({ text: JSON.stringify(searchResults), length: 'short' })\n  return { summary }\n}\n```\n\n**Example 2: Factorial with while loop (number parameter)**\n```javascript\nfunction factorial(n: 5) {\n  let result = 1\n  let i = n\n  while (i > 1) {\n    result = result * i\n    i = i - 1\n  }\n  return { result }\n}\n```\n\n**Example 3: Greeting with template atom**\n```javascript\nfunction greet(name: 'World', greeting = 'Hello') {\n  let message = template({ tmpl: '{{greeting}}, {{name}}!', vars: { greeting, name } })\n  return { message }\n}\n```\n````\n\n```\n\n---\n\n## Self-Correction Loop\n\nWhen testing with local LLMs, implement error feedback:\n\n1. Run the LLM with this prompt\n2. If output contains `async`, `await`, `new`, `class`, or `this`, feed back:\n   > \"Error: You used '[keyword]'. AsyncJS forbids '[keyword]'. [Alternative].\"\n3. The model typically fixes it on the second attempt\n\nExample corrections:\n- `new Date()` → \"Use `Date()` factory function instead\"\n- `await fetch()` → \"Remove `await`, use `httpFetch({ url })` - all calls are implicitly async\"\n- `class Agent` → \"Use plain functions, AsyncJS is purely functional\"\n\n---\n\n## Compact Version (for context-limited models)\n\n```\n\nYou generate AsyncJS code. Rules:\n\n1. Types by example: `fn(name: 'string', count = 10)` - colon=required, equals=optional\n2. NO: async/await, new, class, this, var, import\n3. Atoms use object args: `search({ query: x })`. Built-ins normal: `Math.max(1,2)`\n4. Factories: `Date()`, `Set([1,2])` - no `new` keyword\n5. Date is immutable, months 1-12. Set has .add/.remove (mutable) and .union/.diff (immutable)\n6. Use `?.` for optional chaining: `obj?.prop?.value`\n7. Use `filter(data, schema)` to strip extra properties from objects\n\n```\n\n```\n",
    "title": "AsyncJS LLM System Prompt",
    "filename": "ASYNCJS_LLM_PROMPT.md",
    "path": "ASYNCJS_LLM_PROMPT.md"
  },
  {
    "text": "# AsyncJS Patterns\n\nThis document covers common patterns and workarounds for features not directly supported in AsyncJS.\n\n## Table of Contents\n\n- [Parallel Execution](#parallel-execution)\n- [Retry with Backoff](#retry-with-backoff)\n- [Rate Limiting](#rate-limiting)\n- [Break/Continue](#breakcontinue)\n- [Switch Statements](#switch-statements)\n- [Error Handling Patterns](#error-handling-patterns)\n- [Expression Limitations](#expression-limitations)\n\n---\n\n## Parallel Execution\n\n**Status:** Not supported\n\nAsyncJS executes sequentially by design. This is intentional for:\n\n- Predictable fuel consumption\n- Deterministic execution order\n- Simpler debugging and tracing\n\n**Workaround:** If you need parallel execution, orchestrate at the capability level:\n\n```javascript\n// Capability that handles parallelism\nconst parallelFetch = {\n  fetchAll: async (urls) => {\n    return Promise.all(urls.map((url) => fetch(url).then((r) => r.json())))\n  },\n}\n\n// AsyncJS code calls the capability\nconst results = parallelFetch.fetchAll(urls)\n```\n\n**Future:** Parallel execution may be added as an explicit atom (e.g., `parallel([...steps])`) where fuel is consumed for the most expensive branch.\n\n---\n\n## Retry with Backoff\n\n**Status:** Manual pattern required\n\nAsyncJS doesn't have built-in retry. Implement with a while loop:\n\n```javascript\nlet attempts = 0\nlet result = null\nlet success = false\n\nwhile (attempts < 3 && !success) {\n  attempts = attempts + 1\n\n  try {\n    result = fetch(url)\n    success = true\n  } catch (err) {\n    // Exponential backoff: 100ms, 200ms, 400ms\n    // Note: sleep is a capability, not built-in\n    if (attempts < 3) {\n      sleep(100 * Math.pow(2, attempts - 1))\n    }\n  }\n}\n\nif (!success) {\n  console.error('Failed after 3 attempts')\n}\nreturn result\n```\n\n**Note:** The `sleep` capability must be injected. AsyncJS doesn't include timing primitives to keep the VM deterministic.\n\n---\n\n## Fetch Security\n\n**Status:** Capability responsibility\n\n### The Problem: Recursive Agent Attacks\n\nA malicious or buggy agent could use `fetch` to call other agent endpoints, creating:\n\n- **Amplification attacks** - One request triggers many downstream requests\n- **Ping-pong loops** - Two endpoints repeatedly calling each other\n- **Resource exhaustion** - Consuming compute/tokens across multiple services\n\nFuel budgets only protect the _current_ VM, not downstream services. SSRF protection blocks private IPs but not public agent endpoints.\n\n### The Solution: Capability-Level Enforcement\n\nSince agents are untrusted code, security must be enforced at the **capability layer**:\n\n1. **Depth tracking** - The fetch capability (not the agent) adds/increments an `X-Agent-Depth` header\n2. **Domain allowlist** - Fetch only works for explicitly allowed domains\n3. **Receiving endpoints** - Check depth headers and reject requests that are too deep\n\n```typescript\n// Host provides a secure fetch capability\ncapabilities: {\n  fetch: createSecureFetch({\n    allowedDomains: ['api.weather.com', 'api.github.com'],\n    maxDepth: 5,\n    currentDepth: requestDepth, // From incoming request header\n  })\n}\n```\n\nThe agent cannot bypass this because:\n\n- It only has access to the capability, not raw `fetch`\n- The capability is trusted code provided by the host\n- Headers are added automatically - the agent can't see or modify them\n\n### Why This Can't Be Solved in Agent Code\n\n- **Agent honors depth?** - A malicious agent would just not increment it\n- **Agent checks allowlist?** - A malicious agent would skip the check\n- **Request budget in agent?** - Agent could ignore or reset it\n\nThe **capability is the trust boundary**. Agent code is untrusted; capabilities are trusted code injected by the host.\n\n### Built-in Fetch Behavior\n\nThe default fetch atom:\n\n- Requires a domain allowlist OR restricts to localhost only\n- Automatically adds `X-Agent-Depth` header based on `ctx.context.requestDepth`\n- Rejects requests exceeding `MAX_AGENT_DEPTH` (default: 10)\n\nFor production, always provide a custom fetch capability with appropriate restrictions.\n\n---\n\n## Rate Limiting\n\n**Status:** Capability responsibility\n\nRate limiting should be implemented in the capability layer, not in AsyncJS:\n\n```typescript\n// Inject a rate-limited fetch capability\nconst rateLimitedFetch = createRateLimitedFetch({\n  requestsPerSecond: 10,\n  burstSize: 5,\n})\n\nconst result = await runAgent(ast, {\n  capabilities: {\n    fetch: rateLimitedFetch,\n  },\n})\n```\n\n**Rationale:** Rate limits are deployment-specific. A sandboxed agent shouldn't control its own rate limits since that would allow circumvention.\n\n---\n\n## Break/Continue\n\n**Status:** Not supported\n\nUse conditional logic instead:\n\n```javascript\n// Instead of break:\nlet found = null\nlet i = 0\nwhile (i < items.length && found === null) {\n  if (items[i].matches) {\n    found = items[i]\n  }\n  i = i + 1\n}\n\n// Instead of continue (skip items):\nfor (const item of items) {\n  if (!item.shouldProcess) {\n    // Just don't do anything - effectively a continue\n  } else {\n    processItem(item)\n  }\n}\n\n// Or use filter to pre-process:\nconst toProcess = items.filter((item) => item.shouldProcess)\nfor (const item of toProcess) {\n  processItem(item)\n}\n```\n\n---\n\n## Switch Statements\n\n**Status:** Not supported\n\nUse chained if/else:\n\n```javascript\n// Instead of switch(action):\nlet result\nif (action === 'create') {\n  result = handleCreate(data)\n} else if (action === 'update') {\n  result = handleUpdate(data)\n} else if (action === 'delete') {\n  result = handleDelete(data)\n} else {\n  result = { error: 'Unknown action' }\n}\n\n// For many cases, consider a lookup object:\nconst handlers = {\n  create: () => handleCreate(data),\n  update: () => handleUpdate(data),\n  delete: () => handleDelete(data),\n}\nconst handler = handlers[action]\nif (handler) {\n  result = handler()\n} else {\n  result = { error: 'Unknown action' }\n}\n```\n\n---\n\n## Error Handling Patterns\n\n### Monadic Error Flow\n\nAsyncJS uses monadic error handling. When an error occurs, subsequent atoms are skipped until a `try/catch` block handles it:\n\n```javascript\ntry {\n  const data = fetch(url) // If this fails...\n  const parsed = JSON.parse(data) // ...this is skipped\n  storeSet('data', parsed) // ...this is skipped too\n} catch (err) {\n  console.warn('Fetch failed, using cached data')\n  const cached = storeGet('data')\n  return cached ?? { fallback: true }\n}\n```\n\n### Graceful Degradation\n\nUse `try/catch` with fallbacks:\n\n```javascript\nlet result\n\ntry {\n  result = llmPredict(prompt, { model: 'gpt-4' })\n} catch (err) {\n  // Fall back to simpler model\n  try {\n    result = llmPredict(prompt, { model: 'gpt-3.5-turbo' })\n  } catch (err2) {\n    // Fall back to static response\n    result = \"I'm unable to process your request right now.\"\n  }\n}\n\nreturn result\n```\n\n### Error Aggregation\n\nCollect errors without stopping execution:\n\n```javascript\nconst errors = []\nconst results = []\n\nfor (const item of items) {\n  try {\n    const result = processItem(item)\n    results.push(result)\n  } catch (err) {\n    errors.push({ item: item.id, error: err.message })\n    // Continue processing - no re-throw\n  }\n}\n\nreturn {\n  results: results,\n  errors: errors,\n  success: errors.length === 0,\n}\n```\n\n---\n\n## Unsupported JavaScript Features\n\nThese JavaScript features are intentionally not supported:\n\n| Feature         | Reason                         | Alternative           |\n| --------------- | ------------------------------ | --------------------- |\n| `async/await`   | All atoms are already async    | Direct calls work     |\n| `class`         | OOP not needed for agent logic | Use plain objects     |\n| `this`          | No object context              | Pass data explicitly  |\n| `new`           | No constructors                | Use factory functions |\n| `import/export` | Single-file execution          | Use capabilities      |\n| `eval`          | Security                       | N/A                   |\n| `throw`         | Use monadic errors             | `console.error()`     |\n| `typeof`        | Limited runtime type info      | Use Schema validation |\n| `instanceof`    | No classes                     | Use duck typing       |\n\n---\n\n## Performance Patterns\n\n### Memoization\n\nUse the built-in `memoize` atom for expensive operations:\n\n```javascript\n// Builder API\nAgent.take().memoize(\n  (b) => b.llmPredict({ prompt: expensivePrompt }).as('result'),\n  'expensive-key'\n)\n\n// Results are cached by key within the execution\n```\n\n### Caching\n\nUse `cache` atom with TTL for persistence across executions:\n\n```javascript\n// Cache for 1 hour\nconst result = cache('weather-' + city, 3600000, () => {\n  return fetch('https://api.weather.com/' + city)\n})\n```\n\n### Fuel Budgeting\n\nMonitor and limit computation:\n\n```javascript\n// Check remaining fuel before expensive operation\nif (fuel.current < 100) {\n  console.warn('Low fuel, using cached result')\n  return storeGet('cached-result')\n}\n\n// Proceed with expensive operation\nconst result = complexComputation()\n```\n\n---\n\n## Testing Patterns\n\n### Mock Capabilities\n\n```typescript\nimport {\n  createMockStore,\n  createMockLLM,\n  createCapabilities,\n} from 'tosijs-agent/test-utils'\n\nconst caps = createCapabilities({\n  store: createMockStore({ key: 'value' }),\n  llm: createMockLLM('mocked response'),\n})\n\nconst result = await runAgent(ast, { capabilities: caps })\n```\n\n### Snapshot Testing\n\n```typescript\nconst ast = ajs`\n  const x = 1 + 2\n  return x\n`\n\n// Snapshot the AST for regression testing\nexpect(ast).toMatchSnapshot()\n```\n\n### Trace Inspection\n\n```typescript\nconst result = await runAgent(ast, {\n  trace: true,\n  capabilities: caps,\n})\n\n// Inspect execution trace\nexpect(result.trace).toContainEqual(expect.objectContaining({ op: 'storeGet' }))\n```\n\n---\n\n## Expression Limitations\n\nSome JavaScript expressions have limitations in AsyncJS due to the compilation model.\n\n### Template Literals in Nested Expressions\n\nTemplate literals work at statement level but not inside other expressions:\n\n```javascript\n// Works - statement level\nconst greeting = `Hello, ${name}!`\n\n// Does NOT work - nested in object\nconst obj = { msg: `Hello, ${name}!` } // Error\n\n// Workaround - assign first\nconst msg = `Hello, ${name}!`\nconst obj = { msg: msg } // Works\n```\n\n### Computed Member Access\n\nDynamic property access with variables is not supported:\n\n```javascript\n// Works - literal index\nconst first = items[0]\nconst name = user.name\n\n// Does NOT work - variable index\nconst key = 'name'\nconst value = obj[key] // Error\n\n// Workaround - use Object.entries or restructure\nconst entries = Object.entries(obj)\nconst found = entries.find((e) => e[0] === key)\nconst value = found ? found[1] : null\n```\n\n### Atom Calls in Expressions\n\nAtom/function calls that produce side effects cannot be embedded in expressions:\n\n```javascript\n// Does NOT work - call inside expression\nconst result = items.map((x) => fetch(url + x)) // Error\n\n// Workaround - use explicit loop\nconst results = []\nfor (const x of items) {\n  const res = fetch(url + x)\n  results.push(res)\n}\n```\n\nThese limitations exist because AsyncJS compiles to a JSON AST that executes step-by-step. Complex nested expressions would require runtime evaluation that could bypass fuel tracking and capability checks.\n",
    "title": "AsyncJS Patterns",
    "filename": "PATTERNS.md",
    "path": "PATTERNS.md"
  },
  {
    "text": "# Context: Working with `tosijs-schema`\n\nYou are an expert in `tosijs-schema`, a lightweight, schema-first, LLM-native replacement for Zod. Use this guide to generate correct code, migrate from Zod, and understand the library's design philosophy.\n\n## 1. Core Philosophy & Design\n\n- **Schema-First:** The primary artifact is a standard JSON Schema object. `tosijs-schema` is a fluent API to generate these schemas.\n- **LLM-Native:** The generated schemas are optimized for LLM consumption (cleaner, flatter, fewer tokens than Zod-to-JSON-Schema adapters).\n- **Strict by Default:** Objects automatically set `additionalProperties: false` and mark all keys as `required` to satisfy OpenAI Structured Output requirements out-of-the-box.\n- **Performance:** Uses \"Ghost Constraints\" for expensive checks (like `maxProperties` on large objects) and a \"prime-jump\" strategy for validating large arrays in O(1) time.\n- **Validation Separation:** Separates \"Is this valid?\" (fast, boolean return) from \"Why is it invalid?\" (detailed debugging).\n\n## 2. Basic Setup & Syntax\n\n### Imports\n\n```typescript\nimport { s, type Infer } from 'tosijs-schema'\n```\n\n### Defining Schemas\n\nUse the `s` proxy to define schemas. The syntax is property-based and chainable.\n\n```typescript\nconst UserSchema = s.object({\n  id: s.string.uuid, // Format shorthand\n  username: s.string.min(3).max(20), // Chainable constraints\n  email: s.email, // First-class email type (no .string wrapper needed)\n  age: s.integer.min(0).optional, // Optional integer\n  tags: s.array(s.string).min(1), // Array with constraints\n  role: s.enum(['admin', 'user']), // Enums\n  meta: s.record(s.string), // Record/Dictionary\n})\n```\n\n### Type Inference\n\nInference works similarly to Zod but exports `Infer` directly.\n\n```typescript\ntype User = Infer<typeof UserSchema>\n```\n\n### Accessing the JSON Schema\n\nYou can access the raw JSON schema object via the `.schema` property.\n\n```typescript\nconsole.log(UserSchema.schema)\n// Outputs standard JSON Schema object: { type: \"object\", properties: { ... } }\n```\n\n## 3. Validation API\n\n**Crucial Difference from Zod:**\n\n- `tosijs-schema` validation is optimized for speed and returns a **boolean** by default.\n- It does **not** throw errors or return a parsed object like Zod's `.parse()`.\n\n```typescript\nconst data = { ... };\n\n// Fast validation (returns true/false)\nif (UserSchema.validate(data)) {\n  // logic here\n} else {\n  // Handle invalid data\n}\n```\n\n## 4. Migration Guide (Zod vs. tosijs-schema)\n\n| Feature         | Zod (`z`)                  | tosijs-schema (`s`)                      |\n| --------------- | -------------------------- | ---------------------------------------- |\n| **String**      | `z.string()`               | `s.string`                               |\n| **Email**       | `z.string().email()`       | `s.email` (First-class citizen)          |\n| **UUID**        | `z.string().uuid()`        | `s.string.uuid` or `s.uuid`              |\n| **Optional**    | `schema.optional()`        | `schema.optional` (Property, not method) |\n| **Objects**     | `z.object({...})`          | `s.object({...})`                        |\n| **Strict Mode** | `z.object({...}).strict()` | **Default** (No method needed)           |\n| **Arrays**      | `z.array(schema)`          | `s.array(schema)`                        |\n| **Enums**       | `z.enum(['a', 'b'])`       | `s.enum(['a', 'b'])`                     |\n| **Unions**      | `z.union([a, b])`          | `s.union([a, b])`                        |\n| **Inference**   | `z.infer<typeof T>`        | `Infer<typeof T>`                        |\n| **Metadata**    | `.describe(\"...\")`         | `.describe(\"...\")` / `.title(\"...\")`     |\n\n## 5. Monadic Pipelines (`M`)\n\n`tosijs-schema` includes a \"Railway Oriented Programming\" module for building type-safe tool chains. This is especially useful for **AI Agents**, ensuring that hallucinations or bad data are caught immediately at the source (Input vs Output) rather than cascading.\n\n### 1. Guarded Functions (`M.func`)\n\nCreate functions that enforce schemas on both input and output.\n\n```typescript\nimport { M, s } from 'tosijs-schema'\n\n// M.func(InputSchema, OutputSchema, Implementation)\nconst getSize = M.func(s.string, s.number, (str) => {\n  return str.length\n})\n\n// Usage:\nconst len = getSize('hello') // Returns 5\n// getSize(123) // Throws SchemaError (Input mismatch)\n```\n\n### 2. Execution Contexts (`new M`)\n\nChain multiple functions together. The execution context handles error propagation automatically.\n\n```typescript\nconst pipeline = new M({\n  getSize,\n  isEven: M.func(s.number, s.boolean, (n) => n % 2 === 0),\n})\n\nconst result = pipeline\n  .getSize('hello') // Output: 5\n  .isEven() // Input: 5 -> Output: false\n  .result() // Returns false | Error\n\n// If any step fails schema validation, .result() returns the specific error.\n```\n\n## 6. Advanced Features\n\n### Ghost Constraints\n\nConstraints that are computationally expensive (O(N)) are documented in the schema but skipped by the runtime validator for performance (O(1)).\n\n- **Example:** `.max(n)` on Objects/Records.\n- `minProperties` is strictly validated.\n- `maxProperties` is a \"Ghost\" constraint (documentation only).\n\n### Metadata & LLM Optimization\n\nUse metadata methods to enrich schemas for LLMs or OpenAPI docs without affecting runtime validation.\n\n```typescript\nconst ApiKey = s.string\n  .min(32)\n  .describe(\"The user's secret API key\") // standard JSON schema \"description\"\n  .title('API Key')\n  .default('sk-...')\n```\n\n### Date Handling\n\n`tosijs-schema` treats dates as strings with format validation, aligning with JSON transport.\n\n```typescript\nconst Timestamp = s.string.datetime // Validates ISO string format\n```\n\n## 6. Common Patterns & Gotchas\n\n1. **Chaining Order:** Primitives (like `s.string`) start the chain. Constraints (`.min()`) and metadata (`.describe()`) follow. The `.optional` flag can be placed anywhere in the chain but usually goes last for readability.\n2. **No Transformers:** Unlike Zod, `tosijs` is a pure validation/schema library. It does not \"transform\" data (e.g., string to number coercion) during validation.\n3. **Strict Objects:** Remember that `s.object()` disallows unknown keys by default. If you need a flexible object, use `s.record()` or explicitly allow additional properties if the API supports it (though strict is preferred for LLM outputs).\n4. **Tuples:** Use `s.tuple([s.string, s.number])` for fixed-length arrays.\n\n## 7. Example: LLM Structured Output\n\nWhen defining a response format for an LLM:\n\n```typescript\nconst ResponseSchema = s.object({\n  reasoning: s.string.describe('Step-by-step thinking process'),\n  final_answer: s.string.describe('The concise final answer'),\n  confidence: s.number\n    .min(0)\n    .max(1)\n    .describe('Confidence score between 0 and 1'),\n})\n\n// Pass to LLM\nconst jsonSchema = ResponseSchema.schema\n```\n",
    "title": "Context: Working with tosijs-schema",
    "filename": "CTX_TOSIJS_SCHEMA.md",
    "path": "CTX_TOSIJS_SCHEMA.md"
  },
  {
    "text": "## seq (Sequence)\n\nThe root atom for all agent programs. Executes steps in order.\n\n- Stops on `return` (when `ctx.output` is set)\n- Stops on error (monadic error flow)\n- Cost: 0.1\n\n```javascript\n// AsyncJS compiles to seq at the top level\nconst x = 1\nconst y = 2\nreturn { sum: x + y }\n```\n\n---\n\n## if (Conditional)\n\nConditional branching based on expression evaluation.\n\n```javascript\nif (count > 0) {\n  console.log(\"Has items\")\n} else {\n  console.log(\"Empty\")\n}\n```\n\n---\n\n## while (Loop)\n\nRepeats body while condition is truthy. Consumes fuel each iteration.\n\n```javascript\nlet i = 0\nwhile (i < 10) {\n  console.log(i)\n  i = i + 1\n}\n```\n\n**Note:** No `break`/`continue`. Use condition variables instead.\n\n---\n\n## return\n\nEnds execution and returns values from state. The schema defines which\nstate variables to include in the output.\n\n```javascript\nconst result = compute()\nreturn { result }  // Returns { result: <computed value> }\n```\n\n---\n\n## try/catch\n\nError handling with monadic error flow. When an error occurs, subsequent\nsteps are skipped until caught.\n\n```javascript\ntry {\n  const data = fetch(url)\n  processData(data)\n} catch (err) {\n  console.warn(\"Failed: \" + err)\n  return { error: err }\n}\n```\n\nThe catch block receives:\n- `err` (or custom name): error message\n- `errorOp`: the atom that failed\n\n---\n\n## for...of / map\n\nTransforms each item in an array. The `result` variable in each iteration\nbecomes the new item value.\n\n```javascript\nconst doubled = items.map(x => x * 2)\n\n// Or with for...of:\nconst results = []\nfor (const item of items) {\n  results.push(process(item))\n}\n```\n\n---\n\n## filter\n\nKeeps items that match a condition.\n\n```javascript\nconst adults = users.filter(u => u.age >= 18)\n```\n\n---\n\n## reduce\n\nAccumulates a single value from an array.\n\n```javascript\nconst sum = numbers.reduce((acc, n) => acc + n, 0)\n```\n\n---\n\n## find\n\nReturns first item matching condition, or null.\n\n```javascript\nconst admin = users.find(u => u.role === \"admin\")\n```\n\n---\n\n## fetch\n\nHTTP requests. Requires `fetch` capability or uses global fetch with SSRF protection.\n\n```javascript\nconst data = fetch(\"https://api.example.com/data\")\nconst posted = fetch(\"https://api.example.com/items\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: { name: \"New Item\" }\n})\n```\n\nResponse types: `\"json\"` (default for JSON content-type), `\"text\"`, `\"dataUrl\"` (for images)\n\nSecurity:\n- Requires `ctx.context.allowedFetchDomains` allowlist OR restricts to localhost\n- Automatically adds `X-Agent-Depth` header to prevent recursive agent loops\n- Custom fetch capability can override all restrictions\n\n---\n\n## storeGet / storeSet\n\nPersistent key-value storage. Requires `store` capability.\n\n```javascript\n// Save data\nstoreSet(\"user:123\", { name: \"Alice\", prefs: {} })\n\n// Retrieve later\nconst user = storeGet(\"user:123\")\n```\n\n**Warning:** Default in-memory store is not suitable for production.\n\n---\n\n## llmPredict\n\nCall language model. Requires `llm` capability with `predict` method.\n\n```javascript\nconst response = llmPredict(\"Summarize this: \" + text)\n\n// With options\nconst structured = llmPredict(prompt, {\n  model: \"gpt-4\",\n  temperature: 0.7,\n  responseFormat: { type: \"json_object\" }\n})\n```\n\n---\n\n## transpileCode (Code to AST)\n\nTranspiles AsyncJS code to an AST without executing it.\nUseful for generating agents to send to other services via fetch.\n\n```javascript\n// Generate an agent and send it to a worker\nlet code = llmPredict({ prompt: 'Write an AsyncJS data processor' })\nlet ast = transpileCode({ code })\nlet result = httpFetch({ \n  url: 'https://worker.example.com/run',\n  method: 'POST',\n  body: JSON.stringify({ ast, args: { data: myData } })\n})\n```\n\nSecurity: Only available when the `code.transpile` capability is provided.\n\n---\n\n## runCode (Dynamic Code Execution)\n\nTranspiles and executes AsyncJS code at runtime. The generated code\nruns in the same context, sharing fuel budget, capabilities, and trace.\n\nThis enables agents to write and execute code to solve problems.\n\n```javascript\n// Agent writes code to solve a problem\nlet code = llmPredict({ prompt: 'Write AsyncJS to calculate fibonacci(10)' })\nlet result = runCode({ code, args: {} })\nreturn { answer: result }\n```\n\nThe code must be a valid AsyncJS function. The function's return value\nbecomes the result of runCode.\n\nSecurity: Only available when the `code.transpile` capability is provided.\nThe transpiled code runs with the same permissions as the parent.\nRecursion depth is limited to prevent stack overflow.\n\n---\n\n## memoize\n\nIn-memory caching within a single execution. Same key returns cached result.\n\n```javascript\n// Expensive computation cached by key\nconst result = memoize(\"expensive-\" + id, () => {\n  return heavyComputation(data)\n})\n```\n\n---\n\n## cache\n\nPersistent caching across executions using store capability.\n\n```javascript\n// Cache API result for 1 hour (3600000 ms)\nconst weather = cache(\"weather-\" + city, 3600000, () => {\n  return fetch(\"https://api.weather.com/\" + city)\n})\n```\n\n---\n\n## console.log / console.warn / console.error\n\nLogging utilities that integrate with trace and error flow.\n\n```javascript\nconsole.log(\"Debug info: \" + value)   // Adds to trace\nconsole.warn(\"Potential issue\")        // Adds to trace + warnings summary\nconsole.error(\"Fatal: \" + msg)         // Triggers monadic error flow\n```\n\n- `log`: trace only (no side effects)\n- `warn`: trace + appears in `result.warnings`\n- `error`: stops execution, sets `result.error`",
    "title": "runtime (inline docs)",
    "filename": "runtime.ts",
    "path": "src/vm/runtime.ts"
  },
  {
    "text": "# tosijs-agent Technical Context\n\n**Note:** This document provides a technical deep-dive into tosijs-agent's architecture and security model. For a general overview, installation instructions, and usage examples, please refer to the main [README.md](./README.md).\n\n**tosijs-agent** is a secure, environment-agnostic runtime for executing AI agents and logic chains defined as JSON ASTs.\n\n**Bundle Size:** ~17KB gzipped. Expressions are evaluated via lightweight AST nodes at runtime, eliminating the need for a parser library (the previous JSEP-based approach was ~50KB gzipped).\n\n## 1. Architecture\n\n### The Builder (`TypedBuilder`)\n\nA fluent TypeScript API that generates a portable JSON AST. It uses a `Proxy` to dynamically infer methods from the registered Atoms, providing a strongly-typed developer experience.\n\nIt is important to understand that the builder is only for constructing the AST; it does not contain any of the actual implementation logic for the atoms. All execution is handled by the Runtime.\n\n**Usage Pattern:**\n\n- All logic chains **must** start with `Agent.take()` to define the input schema for the agent.\n- Subsequent atom calls are chained together fluently (e.g., `.varSet(...)`, `.httpFetch(...)`). This creates an implicit `seq` (sequence) of operations.\n- The chain is terminated by calling `.toJSON()` to produce the serializable AST.\n\nYou can access the builder via `Agent` (for core atoms) or `vm.Agent` (the recommended way to access both core and any custom atoms registered with the VM instance).\n\n```typescript\nimport { Agent, s, AgentVM } from 'tosijs-agent'\n\n// Global Builder (Core Atoms)\nconst logic = Agent.take(s.object({ input: s.string }))\n  .varSet({ key: 'sum', value: { $expr: 'binary', op: '+', left: { $expr: 'literal', value: 1 }, right: { $expr: 'literal', value: 1 } } })\n\n// VM Builder (Custom Atoms)\nconst vm = new AgentVM({ myAtom })\nconst customLogic = vm.Agent\n  .myAtom({ ... })\n  .varSet({ ... })\n```\n\n### The Runtime (`AgentVM`)\n\nA stateless Virtual Machine that executes the AST. The runtime contains all the actual implementation logic for the atoms.\n\n- **Sandboxed:** No `eval()`. Math/Logic is evaluated safely via AST expression nodes.\n- **Resource Limited:** Enforces `fuel` (gas) limits and execution timeouts per atom.\n- **Capability-Based:** All IO (Network, DB, AI) must be injected via `capabilities` object.\n\n```typescript\nimport { AgentVM } from 'tosijs-agent'\nconst vm = new AgentVM()\nconst { result, fuelUsed } = await vm.run(ast, args, {\n  capabilities,\n  fuel: 1000,\n})\n```\n\n## 2. Expression Syntax (ExprNode)\n\nExpressions use AST expression nodes (`$expr`) for safe, sandboxed evaluation. Conditions in `if` and `while` atoms use expression strings that are parsed at transpile time.\n\nFor security, expressions are sandboxed and cannot directly access the agent's state. Use the `vars` parameter to explicitly pass variables from state into the expression scope.\n\n### ExprNode Types\n\n- **literal:** `{ $expr: 'literal', value: 5 }` - A constant value\n- **ident:** `{ $expr: 'ident', name: 'x' }` - A variable reference\n- **member:** `{ $expr: 'member', object: {...}, property: 'foo' }` - Property access\n- **binary:** `{ $expr: 'binary', op: '+', left: {...}, right: {...} }` - Binary operations\n- **unary:** `{ $expr: 'unary', op: '-', argument: {...} }` - Unary operations\n- **conditional:** `{ $expr: 'conditional', test: {...}, consequent: {...}, alternate: {...} }` - Ternary\n\n### Supported Operators\n\n- **Binary ops:** `+`, `-`, `*`, `/`, `%`, `**`\n- **Logic:** `&&`, `||`\n- **Comparison:** `==`, `!=`, `>`, `<`, `>=`, `<=`\n- **Member Access:** `obj.prop`, `arr[0]`\n\n### Security\n\n- **Forbidden:** Function calls, `new`, `this`, global access\n- **Blocked:** Prototype access (`__proto__`, `constructor`)\n\n### Fuel Consumption\n\nEach expression node evaluation consumes **0.01 fuel**. This prevents deeply nested or recursive expressions from running unchecked. A simple `a + b` costs ~0.03 fuel (two identifiers + one binary op), while complex nested expressions accumulate cost proportionally.\n\n## 3. Security Model\n\n- **Capabilities:** The VM has no default IO. You must provide `fetch`, `store`, etc., allowing you to mock, proxy, or limit access.\n- **Fuel:** Every atom consumes \"fuel\". Execution aborts if fuel reaches 0.\n- **Execution Timeout:** The VM enforces a global timeout based on fuel budget (see below).\n- **Atom Timeouts:** Individual atoms have a default timeout (1s) to prevent hangs.\n- **State Isolation:** Each run creates a fresh context. Scopes (loops/maps) use prototype inheritance to isolate local variables.\n\n### Execution Timeout\n\nThe VM enforces a hard timeout on execution to prevent hung agents—safeguarding against code that effectively halts by waiting on slow or non-responsive IO.\n\n**How it works:**\n\n1. **Automatic Safety Net:** By default, timeout = `fuel × 10ms`. So 1000 fuel = 10 seconds. _For IO-heavy agents with low fuel costs, explicitly set `timeoutMs` to prevent premature timeouts._\n2. **Explicit SLA:** Pass `timeoutMs` to enforce a strict time limit regardless of fuel.\n3. **External Cancellation:** Pass an `AbortSignal` to integrate with external controllers (user cancellation, HTTP timeouts, etc.).\n\n```typescript\n// Default: 1000 fuel = 10 second timeout\nawait vm.run(ast, args, { fuel: 1000 })\n\n// Explicit timeout: 5 seconds regardless of fuel\nawait vm.run(ast, args, { fuel: 10000, timeoutMs: 5000 })\n\n// External abort signal\nconst controller = new AbortController()\nsetTimeout(() => controller.abort(), 3000) // Cancel after 3s\nawait vm.run(ast, args, { signal: controller.signal })\n```\n\n**Resource Cleanup:** When a timeout occurs, the VM passes the abort signal to the currently executing atom via `ctx.signal`. Loop atoms (`while`, `map`, `filter`, `reduce`, `find`) check the signal between iterations. `httpFetch` passes the signal to `fetch` for immediate request cancellation.\n\n**Timeout vs Fuel:**\n\n- **Fuel** protects against CPU-bound abuse (tight loops burning compute)\n- **Timeout** protects against IO-bound abuse (slow network calls, hung promises)\n\nBoth work together to ensure the VM cannot be held hostage by untrusted code.\n\n**Trust Boundary:** The sandbox protects against malicious _agents_ (untrusted AST), not malicious _atom implementations_. Atoms are registered by the host and are trusted to:\n\n1. Be non-blocking (no synchronous CPU-heavy work)\n2. Respect `ctx.signal` for cancellation\n3. Clean up resources when aborted\n\nIf you write custom atoms, ensure they check `ctx.signal?.aborted` in loops and pass `ctx.signal` to any async operations like `fetch`.\n\n### Cost Overrides\n\nDefault atom costs are guesses. Override them per-run to match your deployment reality:\n\n```typescript\nawait vm.run(ast, args, {\n  costOverrides: {\n    // Static: fixed cost per invocation\n    httpFetch: 50,\n    llmPredict: 500,\n\n    // Dynamic: cost based on input\n    storeSet: (input) => JSON.stringify(input.value).length * 0.001,\n    llmPredict: (input) => (input.model?.includes('gpt-4') ? 1000 : 100),\n  },\n})\n```\n\nUse cases:\n\n- **API rate limits:** Make external API calls expensive to stay under quota\n- **Metered billing:** Reflect actual dollar costs in fuel consumption\n- **Resource protection:** Make database writes cost more than reads\n- **Testing:** Set all costs to 0 to focus on logic, not budgeting\n\n### Request Context\n\nThe `context` option passes request-scoped metadata to atoms. Unlike `args` (agent input) or `capabilities` (IO implementations), context carries ambient data like auth, permissions, and request tracing.\n\n```typescript\nawait vm.run(ast, args, {\n  context: {\n    userId: 'user-123',\n    role: 'admin',\n    permissions: ['read:data', 'write:data', 'fetch:external'],\n    requestId: 'req-abc-123',\n  },\n})\n```\n\nAtoms access it via `ctx.context`:\n\n```typescript\nconst secureFetch = defineAtom(\n  'secureFetch',\n  s.object({ url: s.string }),\n  s.any,\n  async (input, ctx) => {\n    // Check permissions\n    if (!ctx.context?.permissions?.includes('fetch:external')) {\n      throw new Error('Not authorized for external fetch')\n    }\n    return ctx.capabilities.fetch(input.url)\n  }\n)\n```\n\n**Design rationale:**\n\n- **Immutable:** Context is read-only; agents cannot modify their own permissions\n- **Separate from args:** Auth data doesn't pollute the agent's input schema\n- **Separate from capabilities:** Same capability implementation, different authorization\n- **Composable:** Works with cost overrides for user-tier-based fuel costs\n\n**Production patterns:**\n\n```typescript\n// Firebase/Express integration\napp.post('/run-agent', async (req, res) => {\n  const ast = req.body.ast\n  const args = req.body.args\n\n  // Extract auth from request\n  const user = await verifyToken(req.headers.authorization)\n\n  const result = await vm.run(ast, args, {\n    context: {\n      userId: user.id,\n      role: user.role,\n      permissions: user.permissions,\n      requestId: req.id,\n    },\n    // User-tier-based costs\n    costOverrides: {\n      llmPredict: user.tier === 'premium' ? 10 : 100,\n    },\n  })\n\n  res.json(result)\n})\n```\n\n## 4. Production Considerations\n\n### Recursive Agent Fuel\n\nWhen an agent calls sub-agents via `agentRun`, each sub-agent gets its own fuel budget (passed via the capability). Fuel is **not shared** across the call tree by default.\n\n**Why:** The `agentRun` atom delegates to `ctx.capabilities.agent.run`, which the host implements. This gives operators full control over sub-agent resource allocation.\n\n**Patterns for shared fuel:**\n\n```typescript\n// Option 1: Pass remaining fuel to children\nconst sharedFuel = { current: 1000 }\n\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      if (sharedFuel.current <= 0) throw new Error('Out of shared fuel')\n      const result = await vm.run(agents[agentId], input, {\n        fuel: sharedFuel.current,\n        capabilities: caps,\n      })\n      sharedFuel.current -= result.fuelUsed\n      return result.result\n    },\n  },\n}\n\n// Option 2: Fixed budget per recursion depth\nconst caps = {\n  agent: {\n    run: async (agentId, input) => {\n      // Each child gets 10% of parent's budget\n      return vm.run(agents[agentId], input, {\n        fuel: 100, // Fixed small budget\n        capabilities: caps,\n      })\n    },\n  },\n}\n```\n\n### Streaming and Long-Running Agents\n\nThe VM returns results only after complete execution. For long-running agents:\n\n- Use `timeoutMs` to enforce SLAs\n- Use `AbortSignal` for user-initiated cancellation\n- Use `trace: true` for post-hoc debugging\n\n**For real-time streaming**, implement a custom atom that emits intermediate results:\n\n```typescript\nconst streamingAtom = defineAtom(\n  'streamChunk',\n  s.object({ data: s.any }),\n  s.null,\n  async ({ data }, ctx) => {\n    // ctx.context contains your streaming callback\n    await ctx.context?.onChunk?.(data)\n    return null\n  }\n)\n\n// Usage\nawait vm.run(ast, args, {\n  context: {\n    onChunk: (data) => res.write(JSON.stringify(data) + '\\n'),\n  },\n})\n```\n\n### Condition String Syntax\n\nThe condition parser in `if`/`while` atoms supports a subset of expression syntax:\n\n| Supported     | Example                           |\n| ------------- | --------------------------------- |\n| Comparisons   | `a > b`, `x == 'hello'`, `n != 0` |\n| Logical       | `a && b`, `a \\|\\| b`, `!a`        |\n| Arithmetic    | `a + b * c`, `(a + b) / c`        |\n| Member access | `obj.foo.bar`                     |\n| Literals      | `42`, `\"string\"`, `true`, `null`  |\n\n| **Unsupported**        | Alternative                        |\n| ---------------------- | ---------------------------------- |\n| Ternary `a ? b : c`    | Use nested `if` atoms              |\n| Array index `a[0]`     | Use ExprNode with `computed: true` |\n| Function calls `fn(x)` | Use atoms                          |\n| Chained `a > b > c`    | Use `a > b && b > c`               |\n\nUnsupported syntax now throws a clear error at build time with suggestions.\n\n### State Semantics\n\nAgents are **not transactional**. If an atom fails mid-execution:\n\n- Previous state changes persist\n- No automatic rollback\n- Error is captured in monadic flow (`ctx.error`)\n\nThis is by design—agents are stateful pipelines, not database transactions. If you need atomicity, implement checkpoint/restore in your capabilities:\n\n```typescript\nconst caps = {\n  store: {\n    set: async (key, value) => {\n      await db.runTransaction(async (tx) => {\n        await tx.set(key, value)\n      })\n    },\n  },\n}\n```\n\n### Error Handling Granularity\n\nThe `try/catch` atom catches all errors in the try block. There's no selective catch by error type.\n\n**Pattern for error type handling:**\n\n```typescript\nAgent.take(s.object({})).try({\n  try: (b) => b.httpFetch({ url: '...' }).as('response'),\n  catch: (b) =>\n    b\n      .varSet({ key: 'errorType', value: 'unknown' })\n      // Check error message patterns\n      .if(\n        'msg.includes(\"timeout\")',\n        { msg: 'error.message' },\n        (then) => then.varSet({ key: 'errorType', value: 'timeout' }),\n        (el) =>\n          el.if('msg.includes(\"404\")', { msg: 'error.message' }, (then) =>\n            then.varSet({ key: 'errorType', value: 'not_found' })\n          )\n      ),\n})\n```\n",
    "title": "tosijs-agent Technical Context",
    "filename": "CONTEXT.md",
    "path": "CONTEXT.md"
  }
]